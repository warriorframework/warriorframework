/home/khusain/Projects/forDemo/warriorframework/warrior
>>> source directory: /home/khusain/Projects/forDemo/warriorframework/warrior
/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/common_driver.py
is a file: /home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/common_driver.py
not init hence accepting
/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/network_driver.py
is a file: /home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/network_driver.py
not init hence accepting
/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/cloudshell_driver.py
is a file: /home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/cloudshell_driver.py
not init hence accepting
/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/demo_driver.py
is a file: /home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/demo_driver.py
not init hence accepting
/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/ci_regression_driver.py
is a file: /home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/ci_regression_driver.py
not init hence accepting
/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/fw9500_driver.py
is a file: /home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/fw9500_driver.py
not init hence accepting
/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/file_driver.py
is a file: /home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/file_driver.py
not init hence accepting
/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/server_driver.py
is a file: /home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/server_driver.py
not init hence accepting
/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/driver_template.py
is a file: /home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/driver_template.py
not init hence accepting
/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/netconf_driver.py
is a file: /home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/netconf_driver.py
not init hence accepting
/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/cli_driver.py
is a file: /home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/cli_driver.py
not init hence accepting
/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/rest_driver.py
is a file: /home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/rest_driver.py
not init hence accepting
/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/snmp_driver.py
is a file: /home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/snmp_driver.py
not init hence accepting
/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/__init__.py
is a file: /home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/__init__.py
/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/selenium_driver.py
is a file: /home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/selenium_driver.py
not init hence accepting

***** drivers nameonly: 

['common_driver.py', 'network_driver.py', 'cloudshell_driver.py', 'demo_driver.py', 'ci_regression_driver.py', 'fw9500_driver.py', 'file_driver.py', 'server_driver.py', 'driver_template.py', 'netconf_driver.py', 'cli_driver.py', 'rest_driver.py', 'snmp_driver.py', 'selenium_driver.py']

 action package list:  ['Actions.CiRegressionActions']
Actions.CiRegressionActions
Actions.CiRegressionActions
Actions.CiRegressionActions

 action package list:  ['Actions.CliActions']
Actions.CliActions
Actions.CliActions
Actions.CliActions

 action package list:  ['Actions.CloudshellActions']
Actions.CloudshellActions
Actions.CloudshellActions
Actions.CloudshellActions

 action package list:  ['Actions.CommonActions']
Actions.CommonActions
Actions.CommonActions
Actions.CommonActions

 action package list:  ['Actions.DemoActions']
Actions.DemoActions
Actions.DemoActions
Actions.DemoActions

 action package list:  ['Actions.ExampleActions']
Actions.ExampleActions
Actions.ExampleActions
Actions.ExampleActions

 action package list:  ['Actions.FileActions']
Actions.FileActions
Actions.FileActions
Actions.FileActions

 action package list:  ['Actions.Fw9500Actions']
Actions.Fw9500Actions
Actions.Fw9500Actions
Actions.Fw9500Actions
the actions package /home/khusain/warriorframework/warrior//Actions/Fw9500Actions does not exist or the location is not compatible with warrior framework:

 action package list:  ['Actions.NetconfActions']
Actions.NetconfActions
Actions.NetconfActions
Actions.NetconfActions

 action package list:  ['Actions.NetworkActions.Diagnostics', '\n                    Actions.NetworkActions.FileOps']
Actions.NetworkActions.Diagnostics
Actions.NetworkActions.Diagnostics
Actions.NetworkActions.Diagnostics

                    Actions.NetworkActions.FileOps
Actions.NetworkActions.FileOps

Actions.NetworkActions.FileOps

 action package list:  ['Actions.RestActions']
Actions.RestActions
Actions.RestActions
Actions.RestActions

 action package list:  ['Actions.SeleniumActions']
Actions.SeleniumActions
Actions.SeleniumActions
Actions.SeleniumActions

 action package list:  ['Actions.ServerActions']
Actions.ServerActions
Actions.ServerActions
Actions.ServerActions

 action package list:  ['Actions.SnmpActions']
Actions.SnmpActions
Actions.SnmpActions
Actions.SnmpActions


 drivers: 

[
  "/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/ci_regression_driver.py", 
  "/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/cli_driver.py", 
  "/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/cloudshell_driver.py", 
  "/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/common_driver.py", 
  "/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/demo_driver.py", 
  "/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/driver_template.py", 
  "/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/file_driver.py", 
  "/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/fw9500_driver.py", 
  "/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/netconf_driver.py", 
  "/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/network_driver.py", 
  "/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/rest_driver.py", 
  "/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/selenium_driver.py", 
  "/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/server_driver.py", 
  "/home/khusain/Projects/forDemo/warriorframework/warrior/ProductDrivers/snmp_driver.py"
]
going to delete send_testdata_command_kw in list 12
driver:docs
{
  "ci_regression_driver": [
    [
      {
        "comment": [
          "import datetime", 
          "from Framework import Utils", 
          "from Framework.Utils import data_Utils, file_Utils", 
          "import os", 
          "import time", 
          "from Framework.Utils.testcase_Utils import pNote"
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "ci_regression_actions.py", 
        "line": 1, 
        "type": "package", 
        "fn": "ci_regression_actions"
      }, 
      {
        "comment": [
          "class CIregressionActions(object):"
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "CIregressionActions(object):", 
        "line": 20, 
        "type": "class", 
        "fn": "CIregressionActions"
      }, 
      {
        "comment": [
          "def __init__(self):", 
          "", 
          "", 
          "self.resultfile = Utils.config_Utils.resultfile", 
          "self.datafile = Utils.config_Utils.datafile", 
          "self.logsdir = Utils.config_Utils.logsdir", 
          "self.filename = Utils.config_Utils.filename", 
          "self.logfile = Utils.config_Utils.logfile"
        ], 
        "wdesc": "__init__", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def __init__(self):", 
        "line": 25, 
        "type": "fn", 
        "fn": "__init__"
      }, 
      {
        "comment": [
          "def write_to_file(self, key, system_name):", 
          "", 
          "", 
          "data_Utils.update_datarepository({\"output_file\":self.logfile})", 
          "with open(self.logfile,\"a+\") as fo:", 
          "fo.write(\"\\n\"+\"****************************\")", 
          "fo.write(\"\\n\"+key+\" ran\")", 
          "fo.write(\"\\n\"+\"Ran on \"+system_name)", 
          "fo.write(\"\\n\"+\"****************************\"+\"\\n\")", 
          "return True"
        ], 
        "wdesc": "write_to_file", 
        "args": [
          "self", 
          "key", 
          "system_name"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "key": ""
        }, 
        "def": "def write_to_file(self, key, system_name):", 
        "line": 35, 
        "type": "fn", 
        "fn": "write_to_file"
      }, 
      {
        "comment": [
          "def once_per_tc_with_system_name_given(self, system_name, step_num):", 
          "", 
          "", 
          "", 
          "wdesc = \"Once per tese case with system name given\"", 
          "pNote(wdesc)", 
          "key = 'once_per_tc_with_system_name_given_'+str(step_num)", 
          "self.write_to_file(key, system_name)", 
          "return True"
        ], 
        "wdesc": "Once per tese case with system name given", 
        "args": [
          "self", 
          "system_name", 
          "step_num"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "step_num": ""
        }, 
        "def": "def once_per_tc_with_system_name_given(self, system_name, step_num):", 
        "line": 53, 
        "type": "fn", 
        "fn": "once_per_tc_with_system_name_given"
      }, 
      {
        "comment": [
          "def once_per_tc_with_no_name_given(self, system_name, step_num):", 
          "", 
          "", 
          "", 
          "wdesc = \"Once per testcase with system name not given\"", 
          "pNote(wdesc)", 
          "key = 'once_per_tc_with_no_name_given_'+str(step_num)", 
          "self.write_to_file(key, system_name)", 
          "return True"
        ], 
        "wdesc": "Once per testcase with system name not given", 
        "args": [
          "self", 
          "system_name", 
          "step_num"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "step_num": ""
        }, 
        "def": "def once_per_tc_with_no_name_given(self, system_name, step_num):", 
        "line": 69, 
        "type": "fn", 
        "fn": "once_per_tc_with_no_name_given"
      }, 
      {
        "comment": [
          "def once_per_tc_with_error(self, system_name, step_num):", 
          "", 
          "", 
          "", 
          "wdesc = \"Once per testcase with error\"", 
          "pNote(wdesc)", 
          "key = 'once_per_tc_with_error_'+str(step_num)", 
          "self.write_to_file(key, system_name)", 
          "raise Exception(\"This is raised in CIregressionActions.once_per_tc_with_error\")", 
          "return False"
        ], 
        "wdesc": "Once per testcase with error", 
        "args": [
          "self", 
          "system_name", 
          "step_num"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "step_num": ""
        }, 
        "def": "def once_per_tc_with_error(self, system_name, step_num):", 
        "line": 85, 
        "type": "fn", 
        "fn": "once_per_tc_with_error"
      }, 
      {
        "comment": [
          "def standard_with_system_name_given(self, system_name, step_num):", 
          "", 
          "", 
          "", 
          "wdesc = \"Standard with system name given\"", 
          "pNote(wdesc)", 
          "key = 'standard_with_system_name_given_'+str(step_num)", 
          "self.write_to_file(key, system_name)", 
          "return True"
        ], 
        "wdesc": "Standard with system name given", 
        "args": [
          "self", 
          "system_name", 
          "step_num"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "step_num": ""
        }, 
        "def": "def standard_with_system_name_given(self, system_name, step_num):", 
        "line": 102, 
        "type": "fn", 
        "fn": "standard_with_system_name_given"
      }, 
      {
        "comment": [
          "def standard_with_system_name_not_given(self, system_name, step_num):", 
          "", 
          "", 
          "", 
          "wdesc = \"Standard with system name not given\"", 
          "pNote(wdesc)", 
          "key = 'standard_with_system_name_not_given_'+str(step_num)", 
          "self.write_to_file(key, system_name)", 
          "return True"
        ], 
        "wdesc": "Standard with system name not given", 
        "args": [
          "self", 
          "system_name", 
          "step_num"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "step_num": ""
        }, 
        "def": "def standard_with_system_name_not_given(self, system_name, step_num):", 
        "line": 118, 
        "type": "fn", 
        "fn": "standard_with_system_name_not_given"
      }, 
      {
        "comment": [
          "def standard_with_error(self, system_name, step_num):", 
          "", 
          "", 
          "wdesc = \"Standard with error\"", 
          "pNote(wdesc)", 
          "key = 'standard_with_error_'+str(step_num)", 
          "self.write_to_file(key, system_name)", 
          "raise Exception(\"This is raised in CIregressionActions.standard_with_error\")", 
          "return False"
        ], 
        "wdesc": "Standard with error", 
        "args": [
          "self", 
          "system_name", 
          "step_num"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "step_num": ""
        }, 
        "def": "def standard_with_error(self, system_name, step_num):", 
        "line": 134, 
        "type": "fn", 
        "fn": "standard_with_error"
      }, 
      {
        "comment": [
          "def end_of_tc_with_system_name_given(self, system_name, step_num):", 
          "", 
          "", 
          "wdesc = \"End of testcase with system name given\"", 
          "pNote(wdesc)", 
          "key = 'end_of_tc_with_system_name_given_'+str(step_num)", 
          "self.write_to_file(key, system_name)", 
          "return True"
        ], 
        "wdesc": "End of testcase with system name given", 
        "args": [
          "self", 
          "system_name", 
          "step_num"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "step_num": ""
        }, 
        "def": "def end_of_tc_with_system_name_given(self, system_name, step_num):", 
        "line": 150, 
        "type": "fn", 
        "fn": "end_of_tc_with_system_name_given"
      }, 
      {
        "comment": [
          "def end_of_tc_with_system_name_not_given(self, system_name, step_num):", 
          "", 
          "", 
          "wdesc = \"End of testcase with system name not given\"", 
          "pNote(wdesc)", 
          "key = 'end_of_tc_with_system_name_not_given_'+str(step_num)", 
          "self.write_to_file(key, system_name)", 
          "return True"
        ], 
        "wdesc": "End of testcase with system name not given", 
        "args": [
          "self", 
          "system_name", 
          "step_num"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "step_num": ""
        }, 
        "def": "def end_of_tc_with_system_name_not_given(self, system_name, step_num):", 
        "line": 165, 
        "type": "fn", 
        "fn": "end_of_tc_with_system_name_not_given"
      }, 
      {
        "comment": [
          "def end_of_tc_with_error(self, system_name, step_num):", 
          "", 
          "", 
          "wdesc = \"End of testcase with error\"", 
          "pNote(wdesc)", 
          "key = 'end_of_tc_with_error_'+str(step_num)", 
          "self.write_to_file(key, system_name)", 
          "raise Exception(\"This is raised in CIregressionActions.end_of_tc_with_error\")", 
          "return False"
        ], 
        "wdesc": "End of testcase with error", 
        "args": [
          "self", 
          "system_name", 
          "step_num"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "step_num": ""
        }, 
        "def": "def end_of_tc_with_error(self, system_name, step_num):", 
        "line": 180, 
        "type": "fn", 
        "fn": "end_of_tc_with_error"
      }, 
      {
        "comment": [
          "def compare_hybrid_tc_result(self,input_file):", 
          "", 
          "", 
          "wdesc = \"Compares the test case result file with expected result file\"", 
          "pNote(wdesc)", 
          "output_file = data_Utils.get_object_from_datarepository(\"output_file\")", 
          "", 
          "f = open(output_file)", 
          "f1 = open(input_file)", 
          "output_content = f.readlines()", 
          "input_content = f1.readlines()", 
          "if output_content == input_content:", 
          "return True", 
          "output_set = set([tuple([i]) for i in output_content])", 
          "input_set = set([tuple([i]) for i in input_content])", 
          "output_set_count = len(output_set)", 
          "input_set_count = len(input_set)", 
          "if output_set_count > input_set_count:", 
          "diff = output_set.difference(input_set)", 
          "result_content = output_content", 
          "else:", 
          "diff = input_set.difference(output_set)", 
          "result_content = input_content", 
          "pNote(\"**************The difference between the files is******************\")", 
          "for j in diff:", 
          "s = str(j[0])", 
          "index = result_content.index(s)", 
          "last_index = result_content.index(\"****************************\\n\",index)", 
          "start_index = last_index-2", 
          "for i in range(start_index-1,last_index+1):", 
          "pNote(result_content[i].strip(\"\\n\"))", 
          "return False"
        ], 
        "wdesc": "Compares the test case result file with expected result file", 
        "args": [
          "self", 
          "input_file"
        ], 
        "argsmap": {
          "self": "", 
          "input_file": ""
        }, 
        "def": "def compare_hybrid_tc_result(self,input_file):", 
        "line": 196, 
        "type": "fn", 
        "fn": "compare_hybrid_tc_result"
      }, 
      {
        "comment": [
          "def increase_value(self, key, status, max_value, max_status):", 
          "", 
          "", 
          "value = data_Utils.get_object_from_datarepository(key)", 
          "if key == False:", 
          "num = 1", 
          "else:", 
          "if isinstance(value, int):", 
          "num = value + 1", 
          "else:", 
          "num = 1", 
          "if num == int(max_value):", 
          "status = max_status", 
          "", 
          "if status == \"pass\":", 
          "status = True", 
          "elif status == \"fail\":", 
          "status = False", 
          "else:", 
          "raise Exception(\"This is raised in ci_regression_actions.increase_value\")", 
          "", 
          "output_dict = {key: num}", 
          "return status, output_dict"
        ], 
        "wdesc": "increase_value", 
        "args": [
          "self", 
          "key", 
          "status", 
          "max_value", 
          "max_status"
        ], 
        "argsmap": {
          "status": "", 
          "max_value": "", 
          "self": "", 
          "max_status": "", 
          "key": ""
        }, 
        "def": "def increase_value(self, key, status, max_value, max_status):", 
        "line": 234, 
        "type": "fn", 
        "fn": "increase_value"
      }, 
      {
        "comment": [
          "def local_data_test(self, desired_status):", 
          "For testing/demo/placeholder", 
          "return true/false/exception based on input", 
          ":Argument:", 
          "desired_status = user desired status", 
          "input pass->true, fail->false and everything else ->exception"
        ], 
        "wdesc": "local_data_test", 
        "args": [
          "self", 
          "desired_status"
        ], 
        "argsmap": {
          "self": "", 
          "desired_status": ""
        }, 
        "def": "def local_data_test(self, desired_status):", 
        "line": 260, 
        "type": "fn", 
        "fn": "local_data_test"
      }, 
      {
        "comment": [
          "Create a temp directory for parallel execution test"
        ], 
        "wdesc": "create_tmp_dir", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def create_tmp_dir(self):", 
        "line": 275, 
        "type": "fn", 
        "fn": "create_tmp_dir"
      }, 
      {
        "comment": [
          "Create temp file for parallel execution test"
        ], 
        "wdesc": "create_sub_tmp_file", 
        "args": [
          "self", 
          "system_name=\"\"", 
          "filename=\"\"", 
          "delete=\"yes\""
        ], 
        "argsmap": {
          "system_name": "\"\"", 
          "self": "", 
          "delete": "\"yes\"", 
          "filename": "\"\""
        }, 
        "def": "def create_sub_tmp_file(self, system_name=\"\", filename=\"\", delete=\"yes\"):", 
        "line": 282, 
        "type": "fn", 
        "fn": "create_sub_tmp_file"
      }, 
      {
        "comment": [
          " count how many files are under the temp dir ", 
          "time.sleep(5)", 
          "path = data_Utils.get_object_from_datarepository(\"parallel_exec_tmp_dir\")", 
          "content = os.listdir(path)", 
          "pNote(content)", 
          "pNote(str(len(content)) + str(int_count))", 
          "return len(content) == int_count"
        ], 
        "wdesc": "tmp_file_count", 
        "args": [
          "self", 
          "int_count"
        ], 
        "argsmap": {
          "self": "", 
          "int_count": ""
        }, 
        "def": "def tmp_file_count(self, int_count):", 
        "line": 306, 
        "type": "fn", 
        "fn": "tmp_file_count"
      }, 
      {
        "comment": [
          "def check_tmp_file_exists(self, system_name=\"\", filename=\"\"):", 
          " check if temp folder exist in the parallel execution result tmp dir "
        ], 
        "wdesc": "check_tmp_file_exists", 
        "args": [
          "self", 
          "system_name=\"\"", 
          "filename=\"\""
        ], 
        "argsmap": {
          "system_name": "\"\"", 
          "self": "", 
          "filename": "\"\""
        }, 
        "def": "def check_tmp_file_exists(self, system_name=\"\", filename=\"\"):", 
        "line": 315, 
        "type": "fn", 
        "fn": "check_tmp_file_exists"
      }, 
      {
        "comment": [
          "Delete temp directory for parallel execution test"
        ], 
        "wdesc": "delete_tmp_dir", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def delete_tmp_dir(self):", 
        "line": 325, 
        "type": "fn", 
        "fn": "delete_tmp_dir"
      }
    ]
  ], 
  "driver_template": [
    [
      {
        "comment": [
          "This is the actions file, keywords are programmed here ", 
          " Warrior uses standard Python programming for its keyword development, however Warrior requires", 
          "the users to adhere to the following rules: ", 
          " Supported Keyword types", 
          "1. The keywords can be methods of a class or they can be a independent function in a library", 
          "", 
          "2. When using classes for keywords:", 
          "a. Users should always use the default __init__  for a class as shown below, and can", 
          "extend it to add more attributes within __init__", 
          "b. Multiple classes are allowed in a single file", 
          "c. Class inheritance is not supported for keyword classes", 
          "d. In Warrior, method names are keywords and hence the method names", 
          "should be unique within the driver's packages.", 
          "e. Users are allowed to use a mix of classes and independent functions", 
          "in a single actions file as long as their names are unique.", 
          "f. Static methods with decorators are not currently supported by the", 
          "Warrior framework for the Action classes.", 
          "Each keyword (along with its driver) is a step in the warrior test case.", 
          "A keyword can have multiple sub-steps that are implemented in the code "
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "example_actions.py", 
        "line": 1, 
        "type": "package", 
        "fn": "example_actions"
      }, 
      {
        "comment": [
          "\" Default __init__ field must be used when using classes for keywords "
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "CliActions(object):", 
        "line": 53, 
        "type": "class", 
        "fn": "CliActions"
      }, 
      {
        "comment": [
          "def __init__(self):", 
          "self.resultfile = Utils.config_Utils.resultfile", 
          "self.datafile = Utils.config_Utils.datafile", 
          "self.logsdir = Utils.config_Utils.logsdir", 
          "self.filename = Utils.config_Utils.filename", 
          "self.logfile = Utils.config_Utils.logfile", 
          "", 
          " Sample method (keyword)  with a single substep and", 
          "some of the most commonly used functions from the data_Utils is given below", 
          "*** Please remember this is only a sample keyword to help a beginner", 
          "in Warrior Framework, and may not work exactly ****"
        ], 
        "wdesc": "__init__", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def __init__(self):", 
        "line": 56, 
        "type": "fn", 
        "fn": "__init__"
      }, 
      {
        "comment": [
          " KEYWORD DOCUMENTATION: A recommended style for keyword documentation is given below", 
          "Connects to the ssh port of the the given system or subsystems", 
          "", 
          ":Datafile usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or subsystem", 
          "If both tag and attribute is provided the attribute will be used.", 
          "", 
          "1. ip = IP address of the system/subsystem", 
          "2. username = username for the ssh session", 
          "3. password = password for the ssh session", 
          "4. timeout = use if you want to set timeout while connecting", 
          "5. prompt = the prompt expected when the connection is successful", 
          "6. ssh_port = use this tag to provide a ssh port to connect to,\\", 
          "if not provided default ssh port 22 will be used.", 
          "", 
          ":Arguments:", 
          "1. system_name (string) = This can be name of the\\", 
          "system or a subsystem.", 
          "", 
          "To connect to a system provided system_name=system_name.", 
          "", 
          "To connect to a single subsystem provide", 
          "system_name=system_name[subsystem_name].", 
          "", 
          "To connect to multiple subsystems provide", 
          "system_name=system_name[subsystem1_name,subsystem2_name..etc..].", 
          "", 
          "To connect to all subsystems under a system provide", 
          "system_name=\"system_name[all]\".", 
          "2. session_name(string) = name of the session to the system/subsystem.", 
          "3. prompt(string) = prompt expected in the terminal", 
          "4. int_timeout(int) = use this to set timeout value for commands\\", 
          "issued in this session.", 
          "", 
          "", 
          ":Returns:", 
          "1. status(bool)= True / False.", 
          "2. session_id (dict element)= an id is generated for each connection\\", 
          "and each connection is stored in the framework's data_repository.\\", 
          "session_id=system_name+subsystem_name+session_name.", 
          "3. response dictionary(dict): an empty dictionary to store the responses of all\\", 
          "commands sent to the particular system or subsystem.\\", 
          "This dictionary is available in warrior frameworks global data_repository\\", 
          "and can be retrieved using the key= \"session_id + _td_response\".", 
          "", 
          "", 
          " THE DESCRIPTION (optional):", 
          "", 
          "- All keywords can have a description variable that gives details", 
          "of what is being performed by the keyword", 
          "- It should be a string enclosed within double or single quotes, no variable", 
          "substitutions to be used here as it is used as just a text for reporting purpose", 
          "- This string will be used in result file for reporting a step.", 
          "- If this variable is missing warrior will just report  the", 
          "keyword name in step description of the result file", 
          "", 
          " PSUBSTEP (optional) :", 
          "", 
          "All keywords can start with the below function-call to", 
          "pSubStep with a single argument describing in short the sub-step's functionality", 
          "If this function-call is missing warrior will not", 
          "report any sub-step in the test case result file", 
          " Some useful Information:", 
          "Warrior provides a data repository within a test case and a test suite.", 
          "- The data repository within a test case contains all the data returned", 
          "by a keyword stored as dictionary entry.", 
          "", 
          "- The data returned by the keywords is stored automatically", 
          "in the data repository and is accessible to the other keywords within the test case.", 
          "", 
          "- The process by which keywords can access the data returned by other keywords is", 
          "described in item #4 below.", 
          "", 
          "- Warrior also provides a data repository within a test suite.", 
          "- The data repository within a test suite contains all the data returned by", 
          "the keywords of the test cases within the suite stored as dictionary entry.", 
          "", 
          "- The data returned by the keywords is stored automatically in the", 
          "data repository and is accessible to the other keywords within the test suite.", 
          "", 
          "- The process by which keywords can access the data returned by other", 
          "keywords is described in item #4 below.", 
          "", 
          "", 
          " 1. Custom Logfile for a Keyword:", 
          "---------------------------------", 
          "- Warrior framework creates a logfile by default with the name of the testcase", 
          "located in 'Warriorspace/Execution/DateTime/logs'.", 
          "- If the keyword is written as class method then it is available as self.logfile.", 
          "- If the keyword is written as a independent function", 
          "then it is available for the user in the test case data repository.", 
          "", 
          "- However user may want to create a separate logfile for each keyword,", 
          "to create a custom logfile for a keyword use the below function from file_Utils", 
          "", 
          "logfile = Utils.file_Utils.getCustomLogFile(self.filename, self.logsdir,", 
          "'NE_TL1_{0}'.format(system_name))", 
          "", 
          "", 
          " 2. Adding Notes to test case result file:", 
          "---------------------------------------------", 
          "Use testcase_Utils.pNote, pNote does the following 3 operations.", 
          "1. Adds notes to the result xml file", 
          "2. Print the same note to the console.", 
          "3. Writes the notes to the console log file.", 
          "refer to testcase_Utils.py for more functions related to testcase result file reporting", 
          "", 
          "Utils.testcase_Utils.pNote(\"Logfile= %s\" % logfile)", 
          "", 
          "", 
          "3. Get details from input datafile:", 
          "--------------------------------------", 
          "- Warrior supports the use of a system input datafile.", 
          "- A sample system data file is located in Warriorspace/Data.", 
          "- get_credentials method from data_Utils can be used to retrieve data", 
          "from an xml tag in the system file.", 
          "", 
          "For eg: In-order to get the ip, ssh_port, username, password,", 
          "prompt of a system called 'dpoe03' from the input datafile.", 
          "", 
          "credentials = Utils.data_Utils.get_credentials(self.datafile, 'dpoe03',", 
          "['ip', 'ssh_port', 'username',", 
          "'password', 'prompt'])", 
          "", 
          " 4. Sharing data between keywords:", 
          "------------------------------------", 
          "- In Warrior Framework all data to be returned by a keyword should be returned", 
          "in a python dictionary, and this data will be stored in the test case", 
          "or test suite data repository as a key-value pair.", 
          "", 
          "- Keywords will have to access the test case data repository to get the", 
          "data returned from a previous keyword.", 
          "", 
          "For eg:", 
          "Lets say a previous keyword has returned ne_location(string), session_id(pexpect object)", 
          "to the test case data repository,in order to use these values in the next keyword", 
          "use 'Utils.data_Utils.get_object_from_datarepository' and pass the key to it.", 
          "", 
          "ne_location = Utils.data_Utils.get_object_from_datarepository('ne_location')", 
          "session_id = Utils.data_Utils.get_object_from_datarepository('session_id')", 
          "", 
          "A sample code of the keyword", 
          "", 
          "WDesc = \"Connect to the ssh port of the system and creates a session\"", 
          "", 
          "Utils.testcase_Utils.pSubStep('Connect to ssh of {0}'.format(system_name))", 
          "", 
          "output_dict = {}", 
          "logfile = Utils.file_Utils.getCustomLogFile(self.filename, self.logsdir,", 
          "'NE_TL1_{0}'.format(system_name))", 
          "Utils.testcase_Utils.pNote(system_name)", 
          "Utils.testcase_Utils.pNote(logfile)", 
          "Utils.testcase_Utils.pNote(Utils.file_Utils.getDateTime())", 
          "", 
          "if session_name is None:", 
          "session_id = system_name", 
          "elif session_name is not None:", 
          "session_id = system_name + session_name", 
          "", 
          "credentials = Utils.data_Utils.get_credentials(self.datafile, system_name,", 
          "['ip', 'ssh_port', 'username',", 
          "'password', 'prompt'])", 
          "ne_location = Utils.data_Utils.get_object_from_datarepository('ne_location')", 
          "Utils.testcase_Utils.pNote(ne_location)", 
          "time.sleep(10)", 
          "if credentials is False:", 
          "status = credentials", 
          "else:", 
          "if credentials['prompt'] is not None:", 
          "expected_prompt = credentials['prompt']", 
          "session_object = Utils.cli_Utils.connect_ssh(credentials['ip'],", 
          "credentials['ssh_port'],", 
          "credentials['username'],", 
          "credentials['password'], logfile,", 
          "prompt_expected=expected_prompt)", 
          "if isinstance(session_object, pexpect.spawn):", 
          "output_dict[session_id] = session_object", 
          "status = True", 
          "else:", 
          "status = False", 
          "", 
          "Reporting status of a sub step:", 
          "---------------------------------", 
          "After executing a sub step in a keyword, use Utils.testcase_Utils.report_substep_status(status)", 
          "to report the status of that substep to the result file.", 
          "", 
          "If a keyword has multiple sub-steps use this for each sub step in the keyword.", 
          "", 
          " Returning Keyword status and data:", 
          "---------------------------------------", 
          "Each keyword should return the status of the keyword in the return command.", 
          "", 
          "- Any Data generated in the keyword can also be returned", 
          "as a key-value pair in a python dictionary.", 
          "", 
          "- This key-value pair will be stored in the  data repository for use by other keywords.", 
          "", 
          "", 
          "RETURN TYPES", 
          "1. Supported return types from keywords.", 
          "a. Only status: True or False only", 
          "b. Only dictionary.", 
          "c. status, dictionary", 
          "d. dictionary, status", 
          "", 
          "2. If a keyword does not return a status,", 
          "it will be declared as failure in the test case results.", 
          "", 
          "3. When a keyword returns a dictionary the test case data repository", 
          "will be updated with the dictionary returned by the keyword.", 
          "", 
          "4. If a keyword returns any unsupported value the keyword will be declared as failure. ", 
          " Sample Return statement", 
          "return status, output_dict"
        ], 
        "wdesc": "Connect to the ssh port of the system and creates a session", 
        "args": [
          "self", 
          "system_name", 
          "session_name=None", 
          "expected_prompt='.*'"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "session_name": "None", 
          "expected_prompt": "'.*'"
        }, 
        "def": "def connect_ssh(self, system_name, session_name=None, expected_prompt='.*'):", 
        "line": 68, 
        "type": "fn", 
        "fn": "connect_ssh"
      }
    ]
  ], 
  "cli_driver": [
    [
      {
        "comment": [
          "This is the cli_actions module that has all cli related keywords "
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "cli_actions.py", 
        "line": 1, 
        "type": "package", 
        "fn": "cli_actions"
      }, 
      {
        "comment": [
          "CliActions class which has methods(keywords)", 
          "related to actions performed on any command line interface "
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "CliActions(object):", 
        "line": 26, 
        "type": "class", 
        "fn": "CliActions"
      }, 
      {
        "comment": [
          "constructor", 
          "self.resultfile = Utils.config_Utils.resultfile", 
          "self.datafile = Utils.config_Utils.datafile", 
          "self.logsdir = Utils.config_Utils.logsdir", 
          "self.filename = Utils.config_Utils.filename", 
          "self.logfile = Utils.config_Utils.logfile"
        ], 
        "wdesc": "__init__", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def __init__(self):", 
        "line": 30, 
        "type": "fn", 
        "fn": "__init__"
      }, 
      {
        "comment": [
          "def connect(self, system_name, session_name=None, prompt=\".*(%|#|\\$)\",", 
          "ip_type=\"ip\", via_host=None):", 
          "", 
          "", 
          "", 
          "wdesc = \"Connect to the ssh/telnet port of the system\"", 
          "pNote(wdesc)", 
          "#Resolve system_name and subsystem_list", 
          "#Removing duplicate subsystem entry and blank spaces in entry name", 
          "system_name, subsystem_list = Utils.data_Utils.resolve_system_subsystem_list(self.datafile,", 
          "system_name)", 
          "output_dict = {}", 
          "status = True", 
          "", 
          "attempt = 1 if subsystem_list is None else len(subsystem_list)", 
          "for i in range(attempt):", 
          "result = False", 
          "subsystem_name = subsystem_list[i] if subsystem_list != None else None", 
          "#Put system_name in system_name[subsystem] format before calling", 
          "#connect_ssh/connect_telnet.", 
          "call_system_name = system_name if subsystem_name is None \\", 
          "else \"{0}[{1}]\".format(system_name, subsystem_name)", 
          "conn_type = getSystemData(self.datafile, call_system_name, \"conn_type\")", 
          "", 
          "if conn_type is not False:", 
          "if conn_type == \"ssh\":", 
          "result, output_dict = self.connect_ssh(call_system_name, session_name, prompt,", 
          "ip_type, via_host=via_host)", 
          "elif conn_type == \"telnet\":", 
          "result, output_dict = self.connect_telnet(call_system_name, session_name,", 
          "ip_type)", 
          "else:", 
          "pNote(\"<conn_type>={0} provided for '{1}' is  not \"\\", 
          "\"supported\".format(conn_type, call_system_name), \"error\")", 
          "else:", 
          "pNote(\"conn_type not provided for system={0}\".format(call_system_name), \"warn\")", 
          "status = status and result", 
          "return status, output_dict"
        ], 
        "wdesc": "Connect to the ssh/telnet port of the system", 
        "args": [
          "self", 
          "system_name", 
          "session_name=None", 
          "prompt=\".*(%|#|\\$)\"", 
          "ip_type=\"ip\"", 
          "via_host=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "prompt": "\".*(%|#|\\$)\"", 
          "self": "", 
          "via_host": "None", 
          "ip_type": "\"ip\"", 
          "session_name": "None"
        }, 
        "def": "def connect(self, system_name, session_name=None, prompt=\".*(%|#|\\$)\",ip_type=\"ip\", via_host=None):", 
        "line": 38, 
        "type": "fn", 
        "fn": "connect"
      }, 
      {
        "comment": [
          "def disconnect(self, system_name, session_name=None):", 
          " Disconnects/Closes  session established with the system", 
          "", 
          ":Arguments:", 
          "1. system_name (string) = This can be name of the\\", 
          "system or a subsystem.", 
          "", 
          "To connect to a system provided system_name=system_name.", 
          "", 
          "To connect to a single subsystem provide", 
          "system_name=system_name[subsystem_name].", 
          "", 
          "To connect to multiple subsystems provide", 
          "system_name=system_name[subsystem1_name,subsystem2_name..etc..].", 
          "", 
          "To connect to all subsystems under a system provide", 
          "system_name=\"system_name[all]\".", 
          "2. session_name(string) = name of the session to the system", 
          "", 
          ":Returns:", 
          "1. status(bool)= True / False"
        ], 
        "wdesc": "Disconnects/Closes  session established with the system/subsystem", 
        "args": [
          "self", 
          "system_name", 
          "session_name=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "session_name": "None"
        }, 
        "def": "def disconnect(self, system_name, session_name=None):", 
        "line": 145, 
        "type": "fn", 
        "fn": "disconnect"
      }, 
      {
        "comment": [
          "Connects to the ssh port of the the given system or subsystems", 
          "", 
          ":Datafile usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or subsystem", 
          "If both tag and attribute is provided the attribute will be used.", 
          "", 
          "1. ip = IP address of the system.\\", 
          "", 
          "Default value for ip type is ip, it can take any type of ip's", 
          "to connect to (like ipv4, ipv6, dns etc)", 
          "", 
          "Users can provide tag/attribute for any ip_type under the system", 
          "in the input datafile and specify the tag/attribute name", 
          "as the value for ip_type argument, then the connection will be", 
          "established using that value.", 
          "", 
          "2. username = username for the ssh session", 
          "3. password = password for the ssh session", 
          "4. timeout = use if you want to set timeout while connecting", 
          "5. prompt = the prompt expected when the connection is successful", 
          "6. ssh_port = use this tag to provide a ssh port to connect to,\\", 
          "if not provided default ssh port 22 will be used.", 
          "7. conn_options = extra arguments that will be used when sending\\", 
          "the ssh/telnet command, default is empty", 
          "8. custom_keystroke = a keystroke that will be sent after the initial\\", 
          "timeout, in case of server require a keystroke to show any prompt.", 
          "Default is the enter key", 
          "", 
          ":Arguments:", 
          "1. system_name (string) = This can be name of the\\", 
          "system or a subsystem.", 
          "", 
          "To connect to a system provided system_name=system_name.", 
          "", 
          "To connect to a single subsystem provide", 
          "system_name=system_name[subsystem_name].", 
          "", 
          "To connect to multiple subsystems provide", 
          "system_name=system_name[subsystem1_name,subsystem2_name..etc..].", 
          "", 
          "To connect to all subsystems under a system provide", 
          "system_name=\"system_name[all]\".", 
          "2. session_name(string) = name of the session to the system/subsystem.", 
          "3. prompt(string) = prompt expected in the terminal", 
          "4. ip_type(string) = type of the ip address(ip, ipv4, ipv6, dns, etc).", 
          "5. int_timeout(int) = use this to set timeout value for commands\\", 
          "issued in this session.", 
          "6. via_host(string) = name of the system in the data file to be", 
          "used as an intermediate system for establishing nested ssh", 
          "connections.", 
          "", 
          ":Returns:", 
          "1. status(bool)= True / False.", 
          "2. session_id (dict element)= an id is generated for each connection\\", 
          "and each connection is stored in the framework's data_repository.\\", 
          "session_id=system_name+subsystem_name+session_name.", 
          "3. response dictionary(dict): an empty dictionary to store the responses of all\\", 
          "commands sent to the particular system or subsystem.\\", 
          "This dictionary is available in warrior frameworks global data_repository\\", 
          "and can be retrieved using the key= \"session_id + _td_response\"."
        ], 
        "wdesc": "Connect to the ssh port of the system/subsystem and creates a session", 
        "args": [
          "self", 
          "system_name", 
          "session_name=None", 
          "prompt=\".*(%|#|\\$)\"", 
          "ip_type=\"ip\"", 
          "int_timeout=60", 
          "via_host=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "prompt": "\".*(%|#|\\$)\"", 
          "self": "", 
          "via_host": "None", 
          "ip_type": "\"ip\"", 
          "session_name": "None", 
          "int_timeout": "60"
        }, 
        "def": "def connect_ssh(self, system_name, session_name=None, prompt=\".*(%|#|\\$)\",ip_type=\"ip\", int_timeout=60, via_host=None):", 
        "line": 215, 
        "type": "fn", 
        "fn": "connect_ssh"
      }, 
      {
        "comment": [
          "Connects to the telnet port of the the given system and/or subsystem and creates a", 
          "pexpect session object for the system", 
          "", 
          "A session_id is created using the combination system_name+session_name,", 
          "system_name+subsystem+session_name and returned by this keyword to be stored", 
          "in Warrior framework's data repository", 
          "", 
          ":Datafile usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or subsystem", 
          "If both tag and attribute is provided the attribute will be used.", 
          "", 
          "1. ip = IP address of the system.\\", 
          "", 
          "Default value for ip type is ip, it can take any type of ip's", 
          "to connect to (like ipv4, ipv6, dns etc)", 
          "", 
          "Users can provide tag/attribute for any ip_type under the system", 
          "in the input datafile and specify the tag/attribute name", 
          "as the value for ip_type argument, then the connection will be", 
          "established using that value.", 
          "", 
          "2. username = username for the ssh session", 
          "3. password = password for the ssh session", 
          "4. prompt = prompt expected in the terminal", 
          "5. timeout = use if you want to set timeout while connecting.", 
          "6. telnet_port = use this tag to provide a telnet port to connect to,\\", 
          "if not provided default telnet port 23 will be used.", 
          "7. conn_options = extra arguments that will be used when sending\\", 
          "the ssh/telnet command, default is empty", 
          "8. custom_keystroke = a keystroke that will be sent after the initial\\", 
          "timeout, in case of server require a keystroke to show any prompt.", 
          "Default is the enter key", 
          "", 
          ":Arguments:", 
          "1. system_name (string) = This can be name of the\\", 
          "system or a subsystem.", 
          "", 
          "To connect to a system provided system_name=system_name.", 
          "", 
          "To connect to a single subsystem provide", 
          "system_name=system_name[subsystem_name].", 
          "", 
          "To connect to multiple subsystems provide", 
          "system_name=system_name[subsystem1_name,subsystem2_name..etc..].", 
          "", 
          "To connect to all subsystems under a system provide", 
          "system_name=\"system_name[all]\".", 
          "2. session_name(string) = name of the session to the system", 
          "3. ip_type(string) = type of the ip address(ip, ipv4, ipv6, dns, etc).", 
          "4. timeout(int) = use this to set timeout value for commands\\", 
          "issued in this session.", 
          "", 
          ":Returns:", 
          "1. status(bool)= True / False.", 
          "2. session_id (dict element)= an id is generated for each connection\\", 
          "and each connection is stored in the framework's data_repository.\\", 
          "session_id=system_name+subsystem_name+session_name", 
          "3. response dictionary(dict): an empty dictionary to store the responses of all\\", 
          "commands sent to the particular system or subsystem.\\", 
          "This dictionary is available in warrior frameworks global data_repository\\", 
          "and can be retrieved using the key= \"session_id + _td_response\"."
        ], 
        "wdesc": "Connect to the telnet port of the system and creates a session", 
        "args": [
          "self", 
          "system_name", 
          "session_name=None", 
          "ip_type=\"ip\"", 
          "int_timeout=60"
        ], 
        "argsmap": {
          "system_name": "", 
          "ip_type": "\"ip\"", 
          "self": "", 
          "int_timeout": "60", 
          "session_name": "None"
        }, 
        "def": "def connect_telnet(self, system_name, session_name=None, ip_type=\"ip\", int_timeout=60):", 
        "line": 375, 
        "type": "fn", 
        "fn": "connect_telnet"
      }, 
      {
        "comment": [
          "Sends a command to a system or a subsystem", 
          "", 
          ":Arguments:", 
          "1. command(string)      = the command to be sent to the system", 
          "2. system_name (string) = This can be name of the\\", 
          "system or a subsystem. In case of subsystem only\\", 
          "single subsystem is supported. Format for subsystem\\", 
          "is \"system_name[subsystem_name]\"", 
          "3. session_name(string) = name of the session to the system", 
          "4. start_prompt(string) = starting prompt for the command", 
          "5. end_prompt(string) = ending prompt for the command", 
          "6. int_timeout (integer) = timeout for the command", 
          "", 
          ":Returns:", 
          "1. command_status(bool)"
        ], 
        "wdesc": "Send cli command to the provided system", 
        "args": [
          "self", 
          "command", 
          "system_name", 
          "session_name=None", 
          "start_prompt='.*'", 
          "end_prompt='.*'", 
          "int_timeout=60"
        ], 
        "argsmap": {
          "system_name": "", 
          "start_prompt": "'.*'", 
          "int_timeout": "60", 
          "self": "", 
          "command": "", 
          "end_prompt": "'.*'", 
          "session_name": "None"
        }, 
        "def": "def send_command(self, command, system_name, session_name=None,start_prompt='.*', end_prompt='.*', int_timeout=60):", 
        "line": 520, 
        "type": "fn", 
        "fn": "send_command"
      }, 
      {
        "comment": [
          "Sends all commands from all rows that are marked execute=yes from the testdata", 
          "", 
          "This keyword expects the usage of warrior framework's", 
          "recommended testdata xml files, sample testdata file is", 
          "available in Warriorspace/Config_files/sample/testdata_sample.xml", 
          "", 
          ":Datafile usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or subsystem", 
          "If both tag and attribute is provided the attribute will be used.", 
          "", 
          "1. testdata = absolute/relative path of the testdata file.", 
          "2. variable_config = absolute/relative path of the variable\\", 
          "config file.", 
          "", 
          "By default the \"testdata\" and \"variable_config\" tag/attribute", 
          "will be used to get the details of testdata and variable config file.", 
          "If a different tag/attribute name is used, provide the tagnames", 
          "as the value to the arguments td_tag and vc_tag.", 
          "", 
          "", 
          ":Arguments:", 
          "1. system_name (string) = This can be name of the\\", 
          "system or a subsystem. In case of subsystem only\\", 
          "single subsystem is supported. Format for subsystem\\", 
          "is \"system_name[subsystem_name]\"", 
          "2. session_name(string) = name of the session to the string", 
          "3. var_sub(string) = the pattern [var_sub] in the testdata commands,\\", 
          "start_prompt, end_prompt, verification search\\", 
          "will substituted with this value.", 
          "4. description(string) = optional description string that overwrites the\\", 
          "default description(wdesc) of the keyword.", 
          "This string will be printed as the keyword description\\", 
          "in console logs and result files.", 
          "5. td_tag = custom tag/attribute name of testdata file.", 
          "6. vc_tag = custom tag/attribute name of variable conig file.", 
          "", 
          ":Returns:", 
          "1. status(bool)", 
          "2. response dictionary(dict): a dictionary having the responses of all\\", 
          "commands sent to the particular system or subsystem. This dictionary\\", 
          "is available in warrior frameworks global data_repository and can be\\", 
          "retrieved using the key= \"session_id + _td_response\" where\\", 
          "session_id=\"system_name+subsystem_name+session_name\""
        ], 
        "wdesc": "Send commands from rows marked execute", 
        "args": [
          "self", 
          "system_name", 
          "session_name=None", 
          "var_sub=None", 
          "description=None", 
          "td_tag=None", 
          "vc_tag=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "vc_tag": "None", 
          "description": "None", 
          "self": "", 
          "td_tag": "None", 
          "session_name": "None", 
          "var_sub": "None"
        }, 
        "def": "def send_all_testdata_commands(self, system_name, session_name=None, var_sub=None,description=None, td_tag=None, vc_tag=None):", 
        "line": 556, 
        "type": "fn", 
        "fn": "send_all_testdata_commands"
      }, 
      {
        "comment": [
          "Sends all the commands from testdata that has row equal to the", 
          "provided row_num", 
          "", 
          "This keyword expects the usage of warrior framework's", 
          "recommended testdata xml files, sample testdata file is", 
          "available in Warriorspace/Config_files/sample/testdata_sample.xml", 
          "", 
          ":Datafile usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or subsystem", 
          "If both tag and attribute is provided the attribute will be used.", 
          "", 
          "1. testdata = absolute/relative path of the testdata file.", 
          "2. variable_config = absolute/relative path of the variable\\", 
          "config file.", 
          "", 
          "By default the \"testdata\" and \"variable_config\" tag/attribute", 
          "will be used to get the details of testdata and variable config file.", 
          "If a different tag/attribute name is used, provide the tagnames", 
          "as the value to the arguments td_tag and vc_tag.", 
          "", 
          ":Arguments:", 
          "1. row_num (string) = row number in string representation", 
          "2. system_name (string) = This can be name of the\\", 
          "system or a subsystem. In case of subsystem only\\", 
          "single subsystem is supported. Format for subsystem\\", 
          "is \"system_name[subsystem_name]\"", 
          "3. session_name(string) = name of the session to the string\\", 
          "4. var_sub(string) = the pattern [var_sub] in the testdata commands,\\", 
          "start_prompt, end_prompt, verification search\\", 
          "will substituted with this value.", 
          "5. description(string) = optional description string that overwrites the\\", 
          "default description(wdesc) of the keyword.\\", 
          "This string will be printed as the keyword description\\", 
          "in console logs and result files.", 
          "6. td_tag = custom tag/attribute name of testdata file", 
          "7. vc_tag = custom tag/attribute name of variable config file.", 
          "", 
          ":Returns:", 
          "1. status(bool)", 
          "2. response dictionary(dict): a dictionary having the responses of all\\", 
          "commands sent to the particular system or subsystem. This dictionary\\", 
          "is available in warrior frameworks global data_repository and can be\\", 
          "retrieved using the key= \"session_id + _td_response\" where\\", 
          "session_id=\"system_name+subsystem_name+session_name\""
        ], 
        "wdesc": "Send commands by row num of testdata file", 
        "args": [
          "self", 
          "row_num", 
          "system_name", 
          "session_name=None", 
          "var_sub=None", 
          "description=None", 
          "td_tag=None", 
          "vc_tag=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "row_num": "", 
          "description": "None", 
          "self": "", 
          "vc_tag": "None", 
          "td_tag": "None", 
          "session_name": "None", 
          "var_sub": "None"
        }, 
        "def": "def send_commands_by_testdata_rownum(self, row_num, system_name,session_name=None, var_sub=None, description=None,td_tag=None, vc_tag=None):", 
        "line": 611, 
        "type": "fn", 
        "fn": "send_commands_by_testdata_rownum"
      }, 
      {
        "comment": [
          "Sends all the commands from testdata that has title equal to the", 
          "provided title", 
          "", 
          "This keyword expects the usage of warrior framework's", 
          "recommended testdata xml files, sample testdata file is", 
          "available in Warriorspace/Config_files/sample/testdata_sample.xml", 
          "", 
          ":Datafile usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or subsystem", 
          "If both tag and attribute is provided the attribute will be used.", 
          "", 
          "1. testdata = absolute/relative path of the testdata file.", 
          "2. variable_config = absolute/relative path of the variable\\", 
          "config file.", 
          "", 
          "By default the \"testdata\" and \"variable_config\" tag/attribute", 
          "will be used to get the details of testdata and variable config file.", 
          "If a different tag/attribute name is used, provide the tagname", 
          "as the value to the arguments td_tag and vc_tag.", 
          "", 
          ":Arguments:", 
          "1. title (string) = title in string representation", 
          "2. system_name (string) = This can be name of the\\", 
          "system or a subsystem. In case of subsystem only\\", 
          "single subsystem is supported. Format for subsystem\\", 
          "is \"system_name[subsystem_name]\"", 
          "3. session_name(string) = name of the session to the string\\", 
          "4. var_sub(string) = the pattern [var_sub] in the testdata commands,\\", 
          "start_prompt, end_prompt, verification search\\", 
          "will substituted with this value.", 
          "5. description(string) = optional description string that overwrites the\\", 
          "default description(wdesc) of the keyword.\\", 
          "This string will be printed as the keyword description\\", 
          "in console logs and result files.", 
          "6. td_tag = custom tag/attribute name of testdata file.", 
          "7. vc_tag = custom tag/attribute name of variable config file.", 
          "", 
          ":Returns:", 
          "1. status(bool)", 
          "2. response dictionary(dict): a dictionary having the responses of all\\", 
          "commands sent to the particular system or subsystem. This dictionary\\", 
          "is available in warrior frameworks global data_repository and can be\\", 
          "retrieved using the key= \"session_id + _td_response\" where\\", 
          "session_id=\"system_name+subsystem_name+session_name\""
        ], 
        "wdesc": "Send commands by title of testdata file", 
        "args": [
          "self", 
          "title", 
          "system_name", 
          "session_name=None", 
          "var_sub=None", 
          "description=None", 
          "td_tag=None", 
          "vc_tag=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "vc_tag": "None", 
          "description": "None", 
          "title": "", 
          "self": "", 
          "td_tag": "None", 
          "session_name": "None", 
          "var_sub": "None"
        }, 
        "def": "def send_commands_by_testdata_title(self, title, system_name, session_name=None,var_sub=None, description=None,td_tag=None, vc_tag=None):", 
        "line": 667, 
        "type": "fn", 
        "fn": "send_commands_by_testdata_title"
      }, 
      {
        "comment": [
          "Sends all the commands from testdata that has title/row equal to the", 
          "provided title/row_num", 
          "", 
          "This keyword expects the usage of warrior framework's", 
          "recommended testdata xml files, sample testdata file is", 
          "available in Warriorspace/Config_files/sample/testdata_sample.xml", 
          "", 
          ":Datafile usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or subsystem", 
          "If both tag and attribute is provided the attribute will be used.", 
          "", 
          "1. testdata = absolute/relative path of the testdata file.", 
          "2. variable_config = absolute/relative path of the variable\\", 
          "config file.", 
          "", 
          "By default the \"testdata\" and \"variable_config\" tag/attribute", 
          "will be used to get the details of testdata and variable config file.", 
          "If a different tag/attribute name is used, provide the tagnames", 
          "as the value to the arguments td_tag and vc_tag.", 
          "", 
          ":Arguments:", 
          "1. title = Title of the testdata block", 
          "2. row = Row number of the testdata block", 
          "3. system_name (string) = This can be name of the\\", 
          "system or a subsystem. In case of subsystem only\\", 
          "single subsystem is supported. Format for subsystem\\", 
          "is \"system_name[subsystem_name]\"", 
          "4. session_name(string) = name of the session to the string", 
          "5. var_sub(string) = the pattern [var_sub] in the testdata commands,\\", 
          "start_prompt, end_prompt, verification search\\", 
          "will substituted with this value.", 
          "6. description(string) = optional description string that overwrites the\\", 
          "default description(wdesc) of the keyword.\\", 
          "This string will be printed as the keyword description\\", 
          "in console logs and result files.", 
          "7. td_tag = custom tag/attribute name of testdata file.", 
          "8. vc_tag = custom tag/attribute name of variable config file.", 
          "", 
          ":Returns:", 
          "1. status(bool)", 
          "2. response dictionary(dict): a dictionary having the responses of all\\", 
          "commands sent to the particular system or subsystem. This dictionary\\", 
          "is available in warrior frameworks global data_repository and can be\\", 
          "retrieved using the key= \"session_id + _td_response\" where\\", 
          "session_id=\"system_name+subsystem_name+session_name\""
        ], 
        "wdesc": "Send commands by title, row & execute", 
        "args": [
          "self", 
          "title", 
          "row_num", 
          "system_name", 
          "session_name=None", 
          "var_sub=None", 
          "description=None", 
          "td_tag=None", 
          "vc_tag=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "row_num": "", 
          "description": "None", 
          "title": "", 
          "self": "", 
          "vc_tag": "None", 
          "td_tag": "None", 
          "session_name": "None", 
          "var_sub": "None"
        }, 
        "def": "def send_commands_by_testdata_title_rownum(self, title, row_num, system_name,session_name=None, var_sub=None,description=None, td_tag=None, vc_tag=None):", 
        "line": 722, 
        "type": "fn", 
        "fn": "send_commands_by_testdata_title_rownum"
      }, 
      {
        "comment": [
          "Sets the timeout period for the ssh/telnet session", 
          "", 
          ":Arguments:", 
          "1. system_name(string-mandatory)      = name of the system from the input datafile", 
          "2. session_name(string)               = name of the session to the system", 
          "3. int_timeout(integer)               = timeout value in minutes", 
          "", 
          ":Returns:", 
          "1. status(bool)"
        ], 
        "wdesc": "Sets the timeout period for the ssh/telnet session", 
        "args": [
          "self", 
          "system_name", 
          "session_name=None", 
          "int_timeout=30"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "int_timeout": "30", 
          "session_name": "None"
        }, 
        "def": "def set_session_timeout(self, system_name, session_name=None, int_timeout=30):", 
        "line": 830, 
        "type": "fn", 
        "fn": "set_session_timeout"
      }, 
      {
        "comment": [
          "Checks whether the ssh/telnet session is alive or not", 
          "", 
          ":Arguments:", 
          "1. system_name(string-mandatory)      = name of the system from the input datafile", 
          "2. session_name(string)               = name of the session to the system", 
          "", 
          ":Returns:", 
          "1. status(bool) : True if alive, False if not alive"
        ], 
        "wdesc": "Checks whether the ssh/telnet session is alive or not", 
        "args": [
          "self", 
          "system_name", 
          "session_name=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "session_name": "None"
        }, 
        "def": "def verify_session_status(self, system_name, session_name=None):", 
        "line": 860, 
        "type": "fn", 
        "fn": "verify_session_status"
      }, 
      {
        "comment": [
          "This is a connect all operation that can connect to  all ssh/telnet based", 
          "on the conn_type provided by the user in the input datafile.", 
          "", 
          ":Datafile usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or subsystem", 
          "If both tag and attribute is provided the attribute will be used.", 
          "", 
          "1. ip = IP address of the system.\\", 
          "", 
          "Default value for ip type is ip, it can take any type of ip's", 
          "to connect to (like ipv4, ipv6, dns etc)", 
          "", 
          "Users can provide tag/attribute for any ip_type under the system", 
          "in the input datafile and specify the tag/attribute name", 
          "as the value for ip_type argument, then the connection will be", 
          "established using that value.", 
          "", 
          "2. username = username for the  session.", 
          "3. password = password for the  session.", 
          "4. timeout = use if you want to set timeout while connecting,\\", 
          "used for both ssh and telnet", 
          "5. prompt = for ssh connections, this is the prompt expected when\\", 
          "the connection is successful, not required for telnet.", 
          "6. conn_type = the type of connection to be created (ssh/telnet).", 
          "7. ssh_port = use this tag to provide ssh port to connect to, if\\", 
          "not provided default ssh port of 22 will be used.", 
          "8. telnet_port = use this tag to provide a telnet port to connect to\\", 
          "if not provided default telnet port 23 will be used.", 
          "", 
          "", 
          ":Arguments:", 
          "None. Keyword will read the input datafile and get the data from tag <system> and <subsystem>.", 
          "", 
          ":Returns:", 
          "1. status(bool)= True / False.", 
          "2. session_id (dict element)= an id is generated for each connection\\", 
          "and each connection is stored in the framework's data_repository.\\", 
          "session_id=system_name+subsystem_name+session_name.", 
          "3. response dictionary(dict): an empty dictionary to store the responses of all\\", 
          "commands sent to the particular system or subsystem.\\", 
          "This dictionary is available in warrior frameworks global data_repository\\", 
          "and can be retrieved using the key= \"session_id + _td_response\"."
        ], 
        "wdesc": "Connect to all systems and subsystems in the datafile.", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def connect_all(self):", 
        "line": 888, 
        "type": "fn", 
        "fn": "connect_all"
      }, 
      {
        "comment": [
          "This is a disconnect all operation that can disconnect all ssh/telnet sessions", 
          "based on the details provided by the user in the input datafile.", 
          "", 
          ":Arguments:", 
          "None. Keyword will read the input datafile and get the data from tag <system> and <subsystem>.", 
          "", 
          ":Returns:", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "Disconnect all systems and subsystems in the datafile.", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def disconnect_all(self):", 
        "line": 961, 
        "type": "fn", 
        "fn": "disconnect_all"
      }
    ]
  ], 
  "selenium_driver": [
    [
      {
        "comment": [
          " Selenium keywords for Element Locator Actions "
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "elementlocator_actions.py", 
        "line": 1, 
        "type": "package", 
        "fn": "elementlocator_actions"
      }, 
      {
        "comment": [
          "This is a class that deals with all 'element' (HTML element) related", 
          "functionality like locating an element via its tag name, class name, name,", 
          "id, css selector, partial and complete links."
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "elementlocator_actions(object):", 
        "line": 26, 
        "type": "class", 
        "fn": "elementlocator_actions"
      }, 
      {
        "comment": [
          "This is a constructor for the elementlocator_actions class", 
          "self.datafile = Utils.config_Utils.datafile", 
          "self.elem_loc_object = ElementLocator()"
        ], 
        "wdesc": "__init__", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def __init__(self):", 
        "line": 31, 
        "type": "fn", 
        "fn": "__init__"
      }, 
      {
        "comment": [
          "def get_element(self, system_name, locator_type=None, locator=None,", 
          "element_config_file=None, element_tag=None,", 
          "browser_name=\"all\"):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"Finding an element by its given locator and locator type.\"", 
          "output_dict = {}", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "element = None", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if current_browser:", 
          "element = self.elem_loc_object.\\", 
          "get_element(current_browser,", 
          "browser_details[\"locator_type\"] + \"=\" +", 
          "browser_details[\"locator\"])", 
          "output_dict[system_name + \"_\" +", 
          "browser_details[\"browser_name\"] + \"_\" +", 
          "browser_details[\"locator_type\"] + \"=\" +", 
          "browser_details[\"locator\"]] = element", 
          "else:", 
          "pNote(\"Browser {0} not found in the data \"", 
          "\"repository\".format(system_name +", 
          "\"_\" +", 
          "browser_details[\"browser_name\"]),", 
          "\"Error\")", 
          "status = False", 
          "browser_details = {}", 
          "if element is None or element is False:", 
          "status = False", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status, output_dict"
        ], 
        "wdesc": "Finding an element by its given locator and locator type.", 
        "args": [
          "self", 
          "system_name", 
          "locator_type=None", 
          "locator=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "locator_type": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "locator": "None", 
          "element_config_file": "None", 
          "element_tag": "None"
        }, 
        "def": "def get_element(self, system_name, locator_type=None, locator=None,element_config_file=None, element_tag=None,browser_name=\"all\"):", 
        "line": 36, 
        "type": "fn", 
        "fn": "get_element"
      }, 
      {
        "comment": [
          "def get_element_by_xpath(self, system_name, xpath=None,", 
          "element_config_file=None, element_tag=None,", 
          "browser_name=\"all\"):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"Finding an element by its xpath.\"", 
          "output_dict = {}", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "element = None", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "if not browser_details[\"xpath\"].startswith(\"xpath\"):", 
          "browser_details[\"xpath\"] = \\", 
          "\"xpath=\" + browser_details[\"xpath\"]", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if current_browser:", 
          "element = self.elem_loc_object.\\", 
          "get_element(current_browser, browser_details[\"xpath\"])", 
          "output_dict[system_name + \"_\" +", 
          "browser_details[\"browser_name\"] + \"_\" +", 
          "browser_details[\"xpath\"]] = element", 
          "else:", 
          "pNote(\"Browser {0} not found in the data \"", 
          "\"repository\".format(system_name + \"_\" +", 
          "browser_details[\"browser_name\"]),", 
          "\"Error\")", 
          "status = False", 
          "browser_details = {}", 
          "if element is None or element is False:", 
          "status = False", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status, output_dict"
        ], 
        "wdesc": "Finding an element by its xpath.", 
        "args": [
          "self", 
          "system_name", 
          "xpath=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "xpath": "None", 
          "element_config_file": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "element_tag": "None"
        }, 
        "def": "def get_element_by_xpath(self, system_name, xpath=None,element_config_file=None, element_tag=None,browser_name=\"all\"):", 
        "line": 197, 
        "type": "fn", 
        "fn": "get_element_by_xpath"
      }, 
      {
        "comment": [
          "def get_element_by_id(self, system_name, id=None,", 
          "element_config_file=None, element_tag=None,", 
          "browser_name=\"all\"):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"Finding an element by its ID.\"", 
          "output_dict = {}", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "element = None", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "pNote(browser_details)", 
          "if browser_details is not None:", 
          "if not browser_details[\"id\"].startswith(\"id\"):", 
          "browser_details[\"id\"] = \"id=\" + browser_details[\"id\"]", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if current_browser:", 
          "element = self.elem_loc_object.\\", 
          "get_element(current_browser, browser_details[\"id\"])", 
          "output_dict[system_name + \"_\" +", 
          "browser_details[\"browser_name\"] + \"_\" +", 
          "browser_details[\"id\"]] = element", 
          "else:", 
          "pNote(\"Browser {0} not found in the data \"", 
          "\"repository\".format(system_name + \"_\" +", 
          "browser_details[\"browser_name\"]),", 
          "\"Error\")", 
          "status = False", 
          "browser_details = {}", 
          "if element is None or element is False:", 
          "status = False", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status, output_dict"
        ], 
        "wdesc": "Finding an element by its ID.", 
        "args": [
          "self", 
          "system_name", 
          "id=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "element_config_file": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "id": "None", 
          "element_tag": "None"
        }, 
        "def": "def get_element_by_id(self, system_name, id=None,element_config_file=None, element_tag=None,browser_name=\"all\"):", 
        "line": 340, 
        "type": "fn", 
        "fn": "get_element_by_id"
      }, 
      {
        "comment": [
          "def get_element_by_selector(self, system_name, css_selector=None,", 
          "element_config_file=None, element_tag=None,", 
          "browser_name=\"all\"):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"Finding an element by its CSS selector.\"", 
          "output_dict ={}", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "element = None", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "if not browser_details[\"css_selector\"].startswith(\"css\"):", 
          "browser_details[\"css_selector\"] = \\", 
          "\"css=\" + browser_details[\"css_selector\"]", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if current_browser:", 
          "element = self.elem_loc_object.\\", 
          "get_element(current_browser,", 
          "browser_details[\"css_selector\"])", 
          "output_dict[system_name + \"_\" +", 
          "browser_details[\"browser_name\"] + \"_\" +", 
          "browser_details[\"css_selector\"]] = element", 
          "else:", 
          "pNote(\"Browser {0} not found in the data \"", 
          "\"repository\".format(system_name + \"_\" +", 
          "browser_details[\"browser_name\"]),", 
          "\"Error\")", 
          "status = False", 
          "browser_details = {}", 
          "if element is None or element is False:", 
          "status = False", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status, output_dict"
        ], 
        "wdesc": "Finding an element by its CSS selector.", 
        "args": [
          "self", 
          "system_name", 
          "css_selector=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "css_selector": "None", 
          "element_config_file": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "element_tag": "None"
        }, 
        "def": "def get_element_by_selector(self, system_name, css_selector=None,element_config_file=None, element_tag=None,browser_name=\"all\"):", 
        "line": 481, 
        "type": "fn", 
        "fn": "get_element_by_selector"
      }, 
      {
        "comment": [
          "def get_element_by_link_text(self, system_name, link_text=None,", 
          "element_config_file=None, element_tag=None,", 
          "browser_name=\"all\"):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"Finding an element by its link text.\"", 
          "output_dict = {}", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "element = None", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "if not browser_details[\"link_text\"].startswith(\"link\"):", 
          "browser_details[\"link_text\"] = \"link=\" + \\", 
          "browser_details[\"link_text\"]", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if current_browser:", 
          "element = self.elem_loc_object.\\", 
          "get_element(current_browser,", 
          "browser_details[\"link_text\"])", 
          "output_dict[system_name + \"_\" +", 
          "browser_details[\"browser_name\"] + \"_\" +", 
          "browser_details[\"link_text\"]] = element", 
          "else:", 
          "pNote(\"Browser {0} not found in the data \"", 
          "\"repository\".format(system_name +", 
          "\"_\" +", 
          "browser_details[\"browser_name\"]),", 
          "\"Error\")", 
          "status = False", 
          "browser_details = {}", 
          "if element is None or element is False:", 
          "status = False", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status, output_dict"
        ], 
        "wdesc": "Finding an element by its link text.", 
        "args": [
          "self", 
          "system_name", 
          "link_text=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "element_config_file": "None", 
          "self": "", 
          "link_text": "None", 
          "browser_name": "\"all\"", 
          "element_tag": "None"
        }, 
        "def": "def get_element_by_link_text(self, system_name, link_text=None,element_config_file=None, element_tag=None,browser_name=\"all\"):", 
        "line": 625, 
        "type": "fn", 
        "fn": "get_element_by_link_text"
      }, 
      {
        "comment": [
          "def get_element_by_partial_link_text(self, system_name,", 
          "partial_link_text=None,", 
          "element_config_file=None,", 
          "element_tag=None, browser_name=\"all\"):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"Finding an element by its partial link text.\"", 
          "output_dict = {}", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "element = None", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "if not browser_details[\"partial_link_text\"].startswith(\"partial\"):", 
          "browser_details[\"partial_link_text\"] = \"partial_link=\" + browser_details[\"partial_link_text\"]", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if current_browser:", 
          "element = self.elem_loc_object.\\", 
          "get_element(current_browser,", 
          "browser_details[\"partial_link_text\"])", 
          "output_dict[system_name + \"_\" +", 
          "browser_details[\"browser_name\"] + \"_\" +", 
          "browser_details[\"partial_link_text\"]] = element", 
          "else:", 
          "pNote(\"Browser {0} not found in the data \"", 
          "\"repository\".format(system_name +", 
          "\"_\" +", 
          "browser_details[\"browser_name\"]),", 
          "\"Error\")", 
          "status = False", 
          "browser_details = {}", 
          "if element is None or element is False:", 
          "status = False", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status, output_dict"
        ], 
        "wdesc": "Finding an element by its partial link text.", 
        "args": [
          "self", 
          "system_name", 
          "partial_link_text=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "partial_link_text": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "element_config_file": "None", 
          "element_tag": "None"
        }, 
        "def": "def get_element_by_partial_link_text(self, system_name,partial_link_text=None,element_config_file=None,element_tag=None, browser_name=\"all\"):", 
        "line": 770, 
        "type": "fn", 
        "fn": "get_element_by_partial_link_text"
      }, 
      {
        "comment": [
          "def get_element_by_tagname(self, system_name, tag_name=None,", 
          "element_config_file=None, element_tag=None,", 
          "browser_name=\"all\"):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"Finding an element by its TAG name.\"", 
          "output_dict = {}", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "element = None", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "if not browser_details[\"tag_name\"].startswith(\"tag\"):", 
          "browser_details[\"tag_name\"] = \"tag=\" + \\", 
          "browser_details[\"tag_name\"]", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if current_browser:", 
          "element = self.elem_loc_object.\\", 
          "get_element(current_browser,", 
          "browser_details[\"tag_name\"])", 
          "output_dict[system_name + \"_\" +", 
          "browser_details[\"browser_name\"] + \"_\" +", 
          "browser_details[\"tag_name\"]] = element", 
          "else:", 
          "pNote(\"Browser {0} not found in the data \"", 
          "\"repository\".format(system_name +", 
          "\"_\" +", 
          "browser_details[\"browser_name\"]),", 
          "\"Error\")", 
          "status = False", 
          "browser_details = {}", 
          "if element is None or element is False:", 
          "status = False", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status, output_dict"
        ], 
        "wdesc": "Finding an element by its TAG name.", 
        "args": [
          "self", 
          "system_name", 
          "tag_name=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "element_config_file": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "tag_name": "None", 
          "element_tag": "None"
        }, 
        "def": "def get_element_by_tagname(self, system_name, tag_name=None,element_config_file=None, element_tag=None,browser_name=\"all\"):", 
        "line": 915, 
        "type": "fn", 
        "fn": "get_element_by_tagname"
      }, 
      {
        "comment": [
          "def get_element_by_classname(self, system_name, class_name=None,", 
          "element_config_file=None, element_tag=None,", 
          "browser_name=\"all\"):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"Finding an element by its CLASS name.\"", 
          "output_dict = {}", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "element = None", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "if not browser_details[\"class_name\"].startswith(\"class\"):", 
          "browser_details[\"class_name\"] = \\", 
          "\"class=\" + browser_details[\"class_name\"]", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if current_browser:", 
          "element = self.elem_loc_object.\\", 
          "get_element(current_browser,", 
          "browser_details[\"class_name\"])", 
          "output_dict[system_name + \"_\" +", 
          "browser_details[\"browser_name\"] + \"_\" +", 
          "browser_details[\"class_name\"]] = element", 
          "else:", 
          "pNote(\"Browser {0} not found in the data \"", 
          "\"repository\".format(system_name + \"_\" +", 
          "browser_details[\"browser_name\"]),", 
          "\"Error\")", 
          "status = False", 
          "browser_details = {}", 
          "if element is None or element is False:", 
          "status = False", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status, output_dict"
        ], 
        "wdesc": "Finding an element by its CLASS name.", 
        "args": [
          "self", 
          "system_name", 
          "class_name=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "class_name": "None", 
          "element_config_file": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "element_tag": "None"
        }, 
        "def": "def get_element_by_classname(self, system_name, class_name=None,element_config_file=None, element_tag=None,browser_name=\"all\"):", 
        "line": 1060, 
        "type": "fn", 
        "fn": "get_element_by_classname"
      }, 
      {
        "comment": [
          "def get_element_by_name(self, system_name, name_of_element=None,", 
          "element_config_file=None, element_tag=None,", 
          "browser_name=\"all\"):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"Finding an element by its name.\"", 
          "output_dict = {}", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "element = None", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "if not browser_details[\"name_of_element\"].startswith(\"name\"):", 
          "browser_details[\"name_of_element\"] = \\", 
          "\"name=\" + browser_details[\"name_of_element\"]", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if current_browser:", 
          "element = self.elem_loc_object.\\", 
          "get_element(current_browser,", 
          "browser_details[\"name_of_element\"])", 
          "output_dict[system_name + \"_\" +", 
          "browser_details[\"browser_name\"] + \"_\" +", 
          "browser_details[\"name_of_element\"]] \\", 
          "= element", 
          "else:", 
          "pNote(\"Browser {0} not found in the data\"", 
          "\"repository\".format(system_name + \"_\" +", 
          "browser_details[\"browser_name\"]),", 
          "\"Error\")", 
          "status = False", 
          "browser_details = {}", 
          "if element is None or element is False:", 
          "status = False", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status, output_dict"
        ], 
        "wdesc": "Finding an element by its name.", 
        "args": [
          "self", 
          "system_name", 
          "name_of_element=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "element_config_file": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "name_of_element": "None", 
          "element_tag": "None"
        }, 
        "def": "def get_element_by_name(self, system_name, name_of_element=None,element_config_file=None, element_tag=None,browser_name=\"all\"):", 
        "line": 1204, 
        "type": "fn", 
        "fn": "get_element_by_name"
      }
    ], 
    [
      {
        "comment": [
          " Selenium keywords for Element Operation Actions "
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "elementoperation_actions.py", 
        "line": 1, 
        "type": "package", 
        "fn": "elementoperation_actions"
      }, 
      {
        "comment": [
          "This is a class that deals with all 'element' (HTML element) related", 
          "operations like clicking on an element, drag and drop of an element,", 
          "hovering on an element"
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "elementoperation_actions(object):", 
        "line": 28, 
        "type": "class", 
        "fn": "elementoperation_actions"
      }, 
      {
        "comment": [
          "This is a constructor for the elementoperation_actions class", 
          "self.datafile = Utils.config_Utils.datafile", 
          "self.jsonobj = JsonUtils()", 
          "self.elem_oper_obj = ElementOperations()"
        ], 
        "wdesc": "__init__", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def __init__(self):", 
        "line": 33, 
        "type": "fn", 
        "fn": "__init__"
      }, 
      {
        "comment": [
          "def clear_text(self, system_name, locator_type=None, locator=None,", 
          "element_config_file=None, element_tag=None,", 
          "browser_name=\"all\"):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = False", 
          "wdesc = \"Clear the text\"", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "Utils.testcase_Utils.pSubStep(wdesc)", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "comp_locator = browser_details[\"locator_type\"] + \"=\" + \\", 
          "browser_details[\"locator\"]", 
          "element_name = system_name + \"_\" + \\", 
          "browser_details[\"browser_name\"] + \"_\" + \\", 
          "comp_locator", 
          "br_name = system_name + \"_\" + browser_details[\"browser_name\"]", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(br_name)", 
          "current_element = Utils.data_Utils.get_object_from_datarepository(element_name)", 
          "if not current_element:", 
          "pNote(\"No element instance {0} found in the data \"", 
          "\"repository!\".format(element_name), \"info\")", 
          "if not current_browser:", 
          "pNote(\"No browser instance {0} found in the data \"", 
          "\"repository!\".format(br_name),", 
          "\"error\")", 
          "else:", 
          "status = self.elem_oper_obj.\\", 
          "perform_element_action(current_browser,", 
          "comp_locator, \"clear_text\",", 
          "browser=current_browser)", 
          "else:", 
          "status = self.elem_oper_obj.\\", 
          "perform_element_action(current_element, comp_locator,", 
          "\"clear_text\",", 
          "browser=current_browser)", 
          "browser_details = {}", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status"
        ], 
        "wdesc": "Clear the text", 
        "args": [
          "self", 
          "system_name", 
          "locator_type=None", 
          "locator=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "locator_type": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "locator": "None", 
          "element_config_file": "None", 
          "element_tag": "None"
        }, 
        "def": "def clear_text(self, system_name, locator_type=None, locator=None,element_config_file=None, element_tag=None,browser_name=\"all\"):", 
        "line": 39, 
        "type": "fn", 
        "fn": "clear_text"
      }, 
      {
        "comment": [
          "def verify_text(self, system_name, locator_type=None, locator=None,", 
          "element_config_file=None, element_tag=None, var=None,", 
          "expected=None, browser_name=\"all\"):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = False", 
          "wdesc = \"verify the text from the element/input box\"", 
          "\" is matching expected\"", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "Utils.testcase_Utils.pSubStep(wdesc)", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments,", 
          "'self.datafile',", 
          "browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "comp_locator = browser_details[\"locator_type\"] + \"=\" + \\", 
          "browser_details[\"locator\"]", 
          "element_name = system_name + \"_\" + \\", 
          "browser_details[\"browser_name\"] + \"_\" + comp_locator", 
          "br_name = system_name + \"_\" + browser_details[\"browser_name\"]", 
          "current_element = Utils.data_Utils.\\", 
          "get_object_from_datarepository(element_name)", 
          "if not var:", 
          "var = element_name + \"_text\"", 
          "if not current_element:", 
          "pNote(\"No element instance {0} found in the data \"", 
          "\"repository!\".format(element_name), \"info\")", 
          "current_browser = Utils.data_Utils.\\", 
          "get_object_from_datarepository(br_name)", 
          "if not current_browser:", 
          "pNote(\"No browser instance {0} found in the data \"", 
          "\"repository!\".format(br_name),", 
          "\"error\")", 
          "else:", 
          "work on the browser instance on which to perform the", 
          "action since enclosed element not provided", 
          "", 
          "enclosing element of the locator is itself provided", 
          "use that to perform the action"
        ], 
        "wdesc": "verify the text from the element/input box", 
        "args": [
          "self", 
          "system_name", 
          "locator_type=None", 
          "locator=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "var=None", 
          "expected=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "locator_type": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "locator": "None", 
          "element_config_file": "None", 
          "var": "None", 
          "element_tag": "None", 
          "expected": "None"
        }, 
        "def": "def verify_text(self, system_name, locator_type=None, locator=None,element_config_file=None, element_tag=None, var=None,expected=None, browser_name=\"all\"):", 
        "line": 206, 
        "type": "fn", 
        "fn": "verify_text"
      }, 
      {
        "comment": [
          "This will simulate a click on the given element", 
          "", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "", 
          "<system name=\"name_of_thy_system\"/>", 
          "", 
          "2. browser_name = This <browser_name> tag is a child og the", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          "", 
          "3. locator_type = This contains information about the type of", 
          "locator that you want to use. Can be 'xpath',", 
          "'id', 'css', 'link', 'tag','class', 'name'", 
          "", 
          "4. locator = This contains the value of the locator. Something like", 
          "\"form\", \"nav-tags\", \"//[dh./dhh[yby]\"", 
          "", 
          "5. element_config_file = This contains the location of the json", 
          "file that contains information about all", 
          "the elements that you require for the", 
          "testcase execution", 
          "6. element_tag = This contains the name of the element in that", 
          "element_config_file which you want to use", 
          "", 
          "USING LOCATOR_TYPE, LOCATOR, ELEMENT_CONFIG_FILE, AND ELEMENT_TAG", 
          "=================================================================", 
          "", 
          "None of these arguments are mandatory BUT to search an element or to", 
          "retrieve it from the data repository, you need to provide Warrior", 
          "with some way to do it.", 
          "", 
          "a. You can either directly give values for the locator_type and", 
          "locator. So if locator_type = name and locator = navigation-bar,", 
          "then Warrior can search for an element with name \"navigation-bar\"", 
          "", 
          "b. You can give location of the element_config_file and a tag inside", 
          "it so that Warrior can search for that tag and get the required", 
          "information from there.", 
          "", 
          "- Now, if the locator type is given, Warrior", 
          "will search for that locator_type in the children of that element in", 
          "the element_config_file", 
          "", 
          "- You can also set defaults in the element_config_file, and now,", 
          "even if the locator_type is not given, Warrior will know which", 
          "element to find. If locator_type is given, the default will be", 
          "overridden", 
          "", 
          "- If locator_type is not f=given, and the defaults are not", 
          "specified, then the first element in the child list of the element", 
          "tag would be picked.", 
          "", 
          "NOTES:", 
          "For these four arguments to be given correctly, ONE of the", 
          "following conditions must be satisfied.", 
          "", 
          "1. locator_type and locator must be given", 
          "2. locator_type, element_config_file, and element_tag must be given", 
          "3. element_config_file, and element_tag must be given", 
          "", 
          "The datafile has the first priority, then the json file, and", 
          "then finally the testcase.", 
          "", 
          "If all arguments are passed from the same place, then, if", 
          "locator and locator_type are given, then they would have", 
          "priority. Otherwise, the element_config_file would be searched", 
          "", 
          "The locator_type locator, element_tag can be given the datafile", 
          "as children of the <browser> tag, but these values would remain", 
          "constant for that browser. It is recommended that these values", 
          "be passed from the testcase step.", 
          "", 
          "The element_config_file typically would not change from step to", 
          "step, so it can be passed from the data file", 
          "", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. locator_type(str) = type of the locator - xpath, id, etc.", 
          "3. locator(str) = locator by which the elemnt should be located.", 
          "4. browser_name(str) = Unique name for this particular browser", 
          "5. element_config_file(str) = location of the element config file", 
          "6. element_tag(str) = json id of the locator that you want to use", 
          "from the element config file", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "Simulate a click", 
        "args": [
          "self", 
          "system_name", 
          "locator_type=None", 
          "locator=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "locator_type": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "locator": "None", 
          "element_config_file": "None", 
          "element_tag": "None"
        }, 
        "def": "def click_an_element(self, system_name, locator_type=None, locator=None,element_config_file=None, element_tag=None,browser_name=\"all\"):", 
        "line": 405, 
        "type": "fn", 
        "fn": "click_an_element"
      }, 
      {
        "comment": [
          "This will clear any text, checks on the given element", 
          "", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "", 
          "<system name=\"name_of_thy_system\"/>", 
          "", 
          "2. browser_name = This <browser_name> tag is a child og the", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          "", 
          "3. locator_type = This contains information about the type of", 
          "locator that you want to use. Can be 'xpath',", 
          "'id', 'css', 'link', 'tag','class', 'name'", 
          "", 
          "4. locator = This contains the value of the locator. Something like", 
          "\"form\", \"nav-tags\", \"//[dh./dhh[yby]\"", 
          "", 
          "5. element_config_file = This contains the location of the json", 
          "file that contains information about all", 
          "the elements that you require for the", 
          "testcase execution", 
          "6. element_tag = This contains the name of the element in that", 
          "element_config_file which you want to use", 
          "", 
          "USING LOCATOR_TYPE, LOCATOR, ELEMENT_CONFIG_FILE, AND ELEMENT_TAG", 
          "=================================================================", 
          "", 
          "None of these arguments are mandatory BUT to search an element or to", 
          "retrieve it from the data repository, you need to provide Warrior", 
          "with some way to do it.", 
          "", 
          "a. You can either directly give values for the locator_type and", 
          "locator. So if locator_type = name and locator = navigation-bar,", 
          "then Warrior can search for an element with name \"navigation-bar\"", 
          "", 
          "b. You can give location of the element_config_file and a tag inside", 
          "it so that Warrior can search for that tag and get the required", 
          "information from there.", 
          "", 
          "- Now, if the locator type is given, Warrior", 
          "will search for that locator_type in the children of that element in", 
          "the element_config_file", 
          "", 
          "- You can also set defaults in the element_config_file, and now,", 
          "even if the locator_type is not given, Warrior will know which", 
          "element to find. If locator_type is given, the default will be", 
          "overridden", 
          "", 
          "- If locator_type is not f=given, and the defaults are not", 
          "specified, then the first element in the child list of the element", 
          "tag would be picked.", 
          "", 
          "NOTES:", 
          "For these four arguments to be given correctly, ONE of the", 
          "following conditions must be satisfied.", 
          "", 
          "1. locator_type and locator must be given", 
          "2. locator_type, element_config_file, and element_tag must be given", 
          "3. element_config_file, and element_tag must be given", 
          "", 
          "The datafile has the first priority, then the json file, and", 
          "then finally the testcase.", 
          "", 
          "If all arguments are passed from the same place, then, if", 
          "locator and locator_type are given, then they would have", 
          "priority. Otherwise, the element_config_file would be searched", 
          "", 
          "The locator_type locator, element_tag can be given the datafile", 
          "as children of the <browser> tag, but these values would remain", 
          "constant for that browser. It is recommended that these values", 
          "be passed from the testcase step.", 
          "", 
          "The element_config_file typically would not change from step to", 
          "step, so it can be passed from the data file", 
          "", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. locator_type(str) = type of the locator - xpath, id, etc.", 
          "3. locator(str) = locator by which the elemnt should be located.", 
          "4. browser_name(str) = Unique name for this particular browser", 
          "5. element_config_file(str) = location of the element config file", 
          "6. element_tag(str) = json id of the locator that you want to use", 
          "from the element config file", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "Clear all actions performed on an element", 
        "args": [
          "self", 
          "system_name", 
          "locator_type=None", 
          "locator=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "locator_type": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "locator": "None", 
          "element_config_file": "None", 
          "element_tag": "None"
        }, 
        "def": "def clear(self, system_name, locator_type=None, locator=None,element_config_file=None, element_tag=None, browser_name=\"all\"):", 
        "line": 569, 
        "type": "fn", 
        "fn": "clear"
      }, 
      {
        "comment": [
          "This will type text into a given element", 
          "", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "", 
          "<system name=\"name_of_thy_system\"/>", 
          "", 
          "2. browser_name = This <browser_name> tag is a child og the", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          "", 
          "3. text = This would contain text that you want to type into any", 
          "element. This can be given as a child of the <browser> tag", 
          "but that restricts you to only that text per browser", 
          "instance. It is therefore recommended that you include", 
          "this as an argument to the testcase step or include it as", 
          "a child of a particular element_tag in the", 
          "element_config_file", 
          "", 
          "4. locator_type = This contains information about the type of", 
          "locator that you want to use. Can be 'xpath',", 
          "'id', 'css', 'link', 'tag','class', 'name'", 
          "", 
          "5. locator = This contains the value of the locator. Something like", 
          "\"form\", \"nav-tags\", \"//[dh./dhh[yby]\"", 
          "", 
          "6. element_config_file = This contains the location of the json", 
          "file that contains information about all", 
          "the elements that you require for the", 
          "testcase execution", 
          "7. element_tag = This contains the name of the element in that", 
          "element_config_file which you want to use", 
          "", 
          "USING LOCATOR_TYPE, LOCATOR, ELEMENT_CONFIG_FILE, AND ELEMENT_TAG", 
          "=================================================================", 
          "", 
          "None of these arguments are mandatory BUT to search an element or to", 
          "retrieve it from the data repository, you need to provide Warrior", 
          "with some way to do it.", 
          "", 
          "a. You can either directly give values for the locator_type and", 
          "locator. So if locator_type = name and locator = navigation-bar,", 
          "then Warrior can search for an element with name \"navigation-bar\"", 
          "", 
          "b. You can give location of the element_config_file and a tag inside", 
          "it so that Warrior can search for that tag and get the required", 
          "information from there.", 
          "", 
          "- Now, if the locator type is given, Warrior", 
          "will search for that locator_type in the children of that element in", 
          "the element_config_file", 
          "", 
          "- You can also set defaults in the element_config_file, and now,", 
          "even if the locator_type is not given, Warrior will know which", 
          "element to find. If locator_type is given, the default will be", 
          "overridden", 
          "", 
          "- If locator_type is not f=given, and the defaults are not", 
          "specified, then the first element in the child list of the element", 
          "tag would be picked.", 
          "", 
          "NOTES:", 
          "For these four arguments to be given correctly, ONE of the", 
          "following conditions must be satisfied.", 
          "", 
          "1. locator_type and locator must be given", 
          "2. locator_type, element_config_file, and element_tag must be given", 
          "3. element_config_file, and element_tag must be given", 
          "", 
          "The datafile has the first priority, then the json file, and", 
          "then finally the testcase.", 
          "", 
          "If all arguments are passed from the same place, then, if", 
          "locator and locator_type are given, then they would have", 
          "priority. Otherwise, the element_config_file would be searched", 
          "", 
          "The locator_type locator, element_tag can be given the datafile", 
          "as children of the <browser> tag, but these values would remain", 
          "constant for that browser. It is recommended that these values", 
          "be passed from the testcase step.", 
          "", 
          "The element_config_file typically would not change from step to", 
          "step, so it can be passed from the data file", 
          "", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. locator_type(str) = type of the locator - xpath, id, etc.", 
          "3. locator(str) = locator by which the elemnt should be located.", 
          "4. browser_name(str) = Unique name for this particular browser", 
          "5. element_config_file(str) = location of the element config file", 
          "6. element_tag(str) = json id of the locator that you want to use", 
          "from the element config file", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "This would type text into an input element", 
        "args": [
          "self", 
          "system_name", 
          "locator_type=None", 
          "locator=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "text=\"\"", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "locator_type": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "locator": "None", 
          "text": "\"\"", 
          "element_config_file": "None", 
          "element_tag": "None"
        }, 
        "def": "def type_text(self, system_name, locator_type=None, locator=None,element_config_file=None, element_tag=None, text=\"\",browser_name=\"all\"):", 
        "line": 732, 
        "type": "fn", 
        "fn": "type_text"
      }, 
      {
        "comment": [
          "This will fill an element", 
          "", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "", 
          "<system name=\"name_of_thy_system\"/>", 
          "", 
          "2. browser_name = This <browser_name> tag is a child og the", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          "", 
          "3. text = This would contain text that you want to type into any", 
          "element. This can be given as a child of the <browser> tag", 
          "but that restricts you to only that text per browser", 
          "instance. It is therefore recommended that you include", 
          "this as an argument to the testcase step or include it as", 
          "a child of a particular element_tag in the", 
          "element_config_file", 
          "", 
          "4. locator_type = This contains information about the type of", 
          "locator that you want to use. Can be 'xpath',", 
          "'id', 'css', 'link', 'tag','class', 'name'", 
          "", 
          "5. locator = This contains the value of the locator. Something like", 
          "\"form\", \"nav-tags\", \"//[dh./dhh[yby]\"", 
          "", 
          "6. element_config_file = This contains the location of the json", 
          "file that contains information about all", 
          "the elements that you require for the", 
          "testcase execution", 
          "7. element_tag = This contains the name of the element in that", 
          "element_config_file which you want to use", 
          "", 
          "USING LOCATOR_TYPE, LOCATOR, ELEMENT_CONFIG_FILE, AND ELEMENT_TAG", 
          "=================================================================", 
          "", 
          "None of these arguments are mandatory BUT to search an element or to", 
          "retrieve it from the data repository, you need to provide Warrior", 
          "with some way to do it.", 
          "", 
          "a. You can either directly give values for the locator_type and", 
          "locator. So if locator_type = name and locator = navigation-bar,", 
          "then Warrior can search for an element with name \"navigation-bar\"", 
          "", 
          "b. You can give location of the element_config_file and a tag inside", 
          "it so that Warrior can search for that tag and get the required", 
          "information from there.", 
          "", 
          "- Now, if the locator type is given, Warrior", 
          "will search for that locator_type in the children of that element in", 
          "the element_config_file", 
          "", 
          "- You can also set defaults in the element_config_file, and now,", 
          "even if the locator_type is not given, Warrior will know which", 
          "element to find. If locator_type is given, the default will be", 
          "overridden", 
          "", 
          "- If locator_type is not f=given, and the defaults are not", 
          "specified, then the first element in the child list of the element", 
          "tag would be picked.", 
          "", 
          "NOTES:", 
          "For these four arguments to be given correctly, ONE of the", 
          "following conditions must be satisfied.", 
          "", 
          "1. locator_type and locator must be given", 
          "2. locator_type, element_config_file, and element_tag must be given", 
          "3. element_config_file, and element_tag must be given", 
          "", 
          "The datafile has the first priority, then the json file, and", 
          "then finally the testcase.", 
          "", 
          "If all arguments are passed from the same place, then, if", 
          "locator and locator_type are given, then they would have", 
          "priority. Otherwise, the element_config_file would be searched", 
          "", 
          "The locator_type locator, element_tag can be given the datafile", 
          "as children of the <browser> tag, but these values would remain", 
          "constant for that browser. It is recommended that these values", 
          "be passed from the testcase step.", 
          "", 
          "The element_config_file typically would not change from step to", 
          "step, so it can be passed from the data file", 
          "", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. locator_type(str) = type of the locator - xpath, id, etc.", 
          "3. locator(str) = locator by which the elemnt should be located.", 
          "4. browser_name(str) = Unique name for this particular browser", 
          "5. element_config_file(str) = location of the element config file", 
          "6. element_tag(str) = json id of the locator that you want to use", 
          "from the element config file", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "Fills an element", 
        "args": [
          "self", 
          "system_name", 
          "locator_type=None", 
          "locator=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "text=\"\"", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "locator_type": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "locator": "None", 
          "text": "\"\"", 
          "element_config_file": "None", 
          "element_tag": "None"
        }, 
        "def": "def fill_an_element(self, system_name, locator_type=None, locator=None,element_config_file=None, element_tag=None, text=\"\",browser_name=\"all\"):", 
        "line": 906, 
        "type": "fn", 
        "fn": "fill_an_element"
      }, 
      {
        "comment": [
          "This will send keys like ENTER, COMMAND, F1 to the element", 
          "", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "", 
          "<system name=\"name_of_thy_system\"/>", 
          "", 
          "2. browser_name = This <browser_name> tag is a child og the", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          "", 
          "3. text = This would contain key like ENTER, CONTROL, ESCAPE - that", 
          "you want to type. This can be given as a child of the", 
          "<browser> tag but that restricts you to only that text per", 
          "browser instance. It is therefore recommended that you", 
          "include this as an argument to the testcase step or", 
          "include it as a child of a particular element_tag in the", 
          "element_config_file", 
          "", 
          "4. locator_type = This contains information about the type of", 
          "locator that you want to use. Can be 'xpath',", 
          "'id', 'css', 'link', 'tag','class', 'name'", 
          "", 
          "5. locator = This contains the value of the locator. Something like", 
          "\"form\", \"nav-tags\", \"//[dh./dhh[yby]\"", 
          "", 
          "6. element_config_file = This contains the location of the json", 
          "file that contains information about all", 
          "the elements that you require for the", 
          "testcase execution", 
          "7. element_tag = This contains the name of the element in that", 
          "element_config_file which you want to use", 
          "", 
          "USING LOCATOR_TYPE, LOCATOR, ELEMENT_CONFIG_FILE, AND ELEMENT_TAG", 
          "=================================================================", 
          "", 
          "None of these arguments are mandatory BUT to search an element or to", 
          "retrieve it from the data repository, you need to provide Warrior", 
          "with some way to do it.", 
          "", 
          "a. You can either directly give values for the locator_type and", 
          "locator. So if locator_type = name and locator = navigation-bar,", 
          "then Warrior can search for an element with name \"navigation-bar\"", 
          "", 
          "b. You can give location of the element_config_file and a tag inside", 
          "it so that Warrior can search for that tag and get the required", 
          "information from there.", 
          "", 
          "- Now, if the locator type is given, Warrior", 
          "will search for that locator_type in the children of that element in", 
          "the element_config_file", 
          "", 
          "- You can also set defaults in the element_config_file, and now,", 
          "even if the locator_type is not given, Warrior will know which", 
          "element to find. If locator_type is given, the default will be", 
          "overridden", 
          "", 
          "- If locator_type is not f=given, and the defaults are not", 
          "specified, then the first element in the child list of the element", 
          "tag would be picked.", 
          "", 
          "NOTES:", 
          "For these four arguments to be given correctly, ONE of the", 
          "following conditions must be satisfied.", 
          "", 
          "1. locator_type and locator must be given", 
          "2. locator_type, element_config_file, and element_tag must be given", 
          "3. element_config_file, and element_tag must be given", 
          "", 
          "The datafile has the first priority, then the json file, and", 
          "then finally the testcase.", 
          "", 
          "If all arguments are passed from the same place, then, if", 
          "locator and locator_type are given, then they would have", 
          "priority. Otherwise, the element_config_file would be searched", 
          "", 
          "The locator_type locator, element_tag can be given the datafile", 
          "as children of the <browser> tag, but these values would remain", 
          "constant for that browser. It is recommended that these values", 
          "be passed from the testcase step.", 
          "", 
          "The element_config_file typically would not change from step to", 
          "step, so it can be passed from the data file", 
          "", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. locator_type(str) = type of the locator - xpath, id, etc.", 
          "3. locator(str) = locator by which the elemnt should be located.", 
          "4. browser_name(str) = Unique name for this particular browser", 
          "5. element_config_file(str) = location of the element config file", 
          "6. element_tag(str) = json id of the locator that you want to use", 
          "from the element config file", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "This will send Keyboard Keys to an element", 
        "args": [
          "self", 
          "system_name", 
          "locator_type=None", 
          "locator=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "text=\"\"", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "locator_type": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "locator": "None", 
          "text": "\"\"", 
          "element_config_file": "None", 
          "element_tag": "None"
        }, 
        "def": "def send_keys_to_an_element(self, system_name, locator_type=None, locator=None,element_config_file=None, element_tag=None,text=\"\", browser_name=\"all\"):", 
        "line": 1082, 
        "type": "fn", 
        "fn": "send_keys_to_an_element"
      }, 
      {
        "comment": [
          "This will simulate a double-click on the given element", 
          "", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "", 
          "<system name=\"name_of_thy_system\"/>", 
          "", 
          "2. browser_name = This <browser_name> tag is a child og the", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          "", 
          "3. locator_type = This contains information about the type of", 
          "locator that you want to use. Can be 'xpath',", 
          "'id', 'css', 'link', 'tag','class', 'name'", 
          "", 
          "4. locator = This contains the value of the locator. Something like", 
          "\"form\", \"nav-tags\", \"//[dh./dhh[yby]\"", 
          "", 
          "5. element_config_file = This contains the location of the json", 
          "file that contains information about all", 
          "the elements that you require for the", 
          "testcase execution", 
          "6. element_tag = This contains the name of the element in that", 
          "element_config_file which you want to use", 
          "", 
          "USING LOCATOR_TYPE, LOCATOR, ELEMENT_CONFIG_FILE, AND ELEMENT_TAG", 
          "=================================================================", 
          "", 
          "None of these arguments are mandatory BUT to search an element or to", 
          "retrieve it from the data repository, you need to provide Warrior", 
          "with some way to do it.", 
          "", 
          "a. You can either directly give values for the locator_type and", 
          "locator. So if locator_type = name and locator = navigation-bar,", 
          "then Warrior can search for an element with name \"navigation-bar\"", 
          "", 
          "b. You can give location of the element_config_file and a tag inside", 
          "it so that Warrior can search for that tag and get the required", 
          "information from there.", 
          "", 
          "- Now, if the locator type is given, Warrior", 
          "will search for that locator_type in the children of that element in", 
          "the element_config_file", 
          "", 
          "- You can also set defaults in the element_config_file, and now,", 
          "even if the locator_type is not given, Warrior will know which", 
          "element to find. If locator_type is given, the default will be", 
          "overridden", 
          "", 
          "- If locator_type is not f=given, and the defaults are not", 
          "specified, then the first element in the child list of the element", 
          "tag would be picked.", 
          "", 
          "NOTES:", 
          "For these four arguments to be given correctly, ONE of the", 
          "following conditions must be satisfied.", 
          "", 
          "1. locator_type and locator must be given", 
          "2. locator_type, element_config_file, and element_tag must be given", 
          "3. element_config_file, and element_tag must be given", 
          "", 
          "The datafile has the first priority, then the json file, and", 
          "then finally the testcase.", 
          "", 
          "If all arguments are passed from the same place, then, if", 
          "locator and locator_type are given, then they would have", 
          "priority. Otherwise, the element_config_file would be searched", 
          "", 
          "The locator_type locator, element_tag can be given the datafile", 
          "as children of the <browser> tag, but these values would remain", 
          "constant for that browser. It is recommended that these values", 
          "be passed from the testcase step.", 
          "", 
          "The element_config_file typically would not change from step to", 
          "step, so it can be passed from the data file", 
          "", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. locator_type(str) = type of the locator - xpath, id, etc.", 
          "3. locator(str) = locator by which the elemnt should be located.", 
          "4. browser_name(str) = Unique name for this particular browser", 
          "5. element_config_file(str) = location of the element config file", 
          "6. element_tag(str) = json id of the locator that you want to use", 
          "from the element config file", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "Simulate a double-click", 
        "args": [
          "self", 
          "system_name", 
          "locator_type=None", 
          "locator=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "locator_type": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "locator": "None", 
          "element_config_file": "None", 
          "element_tag": "None"
        }, 
        "def": "def double_click_an_element(self, system_name, locator_type=None,locator=None, element_config_file=None,element_tag=None, browser_name=\"all\"):", 
        "line": 1259, 
        "type": "fn", 
        "fn": "double_click_an_element"
      }, 
      {
        "comment": [
          "This will simulate a drag and drop on the given element", 
          "", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "", 
          "<system name=\"name_of_thy_system\"/>", 
          "", 
          "", 
          "2. browser_name = This <browser_name> tag is a child og the", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          "", 
          "3. source_locator_type = This contains information about the type", 
          "of locator that you want to use to locate", 
          "the source element that needs to dragged.", 
          "Can be 'xpath', 'id', 'css', 'link', 'tag',", 
          "'class', 'name'", 
          "", 
          "4. source_locator = This contains the value of the locator of the", 
          "source element that needs to be dragged.", 
          "Something like \"form\", \"nav-tags\",", 
          "\"//[dh./dhh[yby]\"", 
          "", 
          "5. target_locator_type = This contains information about the type", 
          "of locator that you want to use to locate", 
          "the target element where the source element", 
          "needs to be dropped. Can be 'xpath', 'id',", 
          "'css', 'link', 'tag', 'class', 'name'", 
          "", 
          "6. target_locator = This contains the value of the locator that you", 
          "want to use to locate the target element where", 
          "the source element needs to be dropped.", 
          "Something like \"form\", \"nav-tags\",", 
          "\"//[dh./dhh[yby]\"", 
          "", 
          "7. element_config_file = This contains the location of the default", 
          "json file that contains information about", 
          "all the elements that you require for the", 
          "testcase execution", 
          "", 
          "8. element_tag = This contains the name of the default element in", 
          "either of the element_config_files which you want", 
          "to use", 
          "", 
          "9. second_element_config_file = This contains the location of the", 
          "second json file that you may want to use", 
          "", 
          "10. second_element_tag = This contains the name of the element in", 
          "either of the element_config_files which you want", 
          "to use", 
          "", 
          "USING SOURCE_LOCATOR_TYPE, LOCATOR, TARGET_LOCATOR_TYPE,", 
          "TARGET_LOCATOR, ELEMENT_CONFIG_FILE, ELEMENT_TAG,", 
          "SECOND_ELEMENT_CONFIG_FILE, AND SECOND_ELEMENT_TAG", 
          "=================================================================", 
          "", 
          "None of these arguments are mandatory BUT to search an element or to", 
          "retrieve it from the data repository, you need to provide Warrior", 
          "with some way to do it.", 
          "", 
          "a. You can either directly give values for the", 
          "source/target_locator_type and source/target_locator. So if", 
          "source/target_locator_type = name and", 
          "source/target_locator = navigation-bar, then Warrior can search for", 
          "an element with name \"navigation-bar\"", 
          "", 
          "b. You can give location of the element_config_files and a tag inside", 
          "it so that Warrior can search for that tag and get the required", 
          "information from there.", 
          "", 
          "- Now, if the source/target_locator type is given, Warrior", 
          "will search for that source/target_locator_type in the children of", 
          "that element in the element_config_file", 
          "", 
          "- You can also set defaults in the element_config_files, and now,", 
          "even if the source/target_locator_type is not given, Warrior will", 
          "know which element to find. If source/target_locator_type is given,", 
          "the default will be overridden", 
          "", 
          "- If source/target_locator_type is not given, and the defaults are", 
          "not specified, then the first element in the child list of the", 
          "element tag would be picked.", 
          "", 
          "NOTES:", 
          "For these four arguments to be given correctly, ONE of the", 
          "following conditions must be satisfied.", 
          "", 
          "1. source/target_locator_type and source/target_locator must be", 
          "given", 
          "2. source/target_locator_type, element_config_file, and", 
          "element_tag must be given", 
          "3. element_config_file, and element_tag must be given", 
          "", 
          "The datafile has the first priority, then the json file, and", 
          "then finally the testcase.", 
          "", 
          "If all arguments are passed from the same place, then, if", 
          "source/target_locator and source/target_locator_type are given,", 
          "then they would have priority. Otherwise, the", 
          "element_config_file would be searched", 
          "", 
          "The source/target_locator_type locator, element_tag can be given", 
          "the datafile as children of the <browser> tag, but these values", 
          "would remain constant for that browser. It is recommended that", 
          "these values be passed from the testcase step.", 
          "", 
          "The element_config_file typically would not change from step to", 
          "step, so it can be passed from the data file", 
          "", 
          "The element_config_files and element_tags can be linked to one another", 
          "as the example given below:", 
          "", 
          "Eg:", 
          "", 
          "<step TS= '25' Driver='selenium_driver' Keyword='drag_and_drop_an_element' >", 
          "<Arguments>", 
          "<argument name=\"system_name\" value=\"system_1\"/>", 
          "<argument name=\"source_locator_type\" value=\"element_tag=xpath\"/>", 
          "<argument name=\"target_locator_type\" value=\"second_element_tag=xpath\"/>", 
          "<argument name=\"element_config_file\" value=\"../Config_files/demo_selenium_tc_Config_1.json\"/>", 
          "<argument name=\"second_element_config_file\" value=\"../Config_files/demo_selenium_tc_Config_2.json\"/>", 
          "<argument name=\"element_tag\" value=\"element_config_file=source\"/>", 
          "<argument name=\"second_element_tag\" value=\"second_element_config_file=target\"/>", 
          "</Arguments>", 
          "</step>", 
          "", 
          "Here, the source_locator_type will be searched for in the element_tag", 
          "in the element_config_file, while the the target_locator_type will be", 
          "searched for in the second_element_tag in the second_element_config_file", 
          "", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. source_locator_type(str) = type of the locator - xpath, id, etc", 
          "for the source element", 
          "3. source_locator(str) = locator by which the elemnt should be", 
          "located for the source element", 
          "2. target_locator_type(str) = type of the locator - xpath, id, etc", 
          "for the target element", 
          "3. target_locator(str) = locator by which the elemnt should be", 
          "located for the target element", 
          "4. browser_name(str) = Unique name for this particular browser", 
          "5. element_config_file(str) = location of the element config file", 
          "6. element_tag(str) = json id of the locator that you want to use", 
          "from the element config file", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "Simulate a drag and drop", 
        "args": [
          "self", 
          "system_name", 
          "source_locator_type=None", 
          "source_locator=None", 
          "target_locator_type=None", 
          "target_locator=None", 
          "element_config_file=None", 
          "second_element_config_file=None", 
          "element_tag=None", 
          "second_element_tag=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "second_element_config_file": "None", 
          "target_locator": "None", 
          "element_config_file": "None", 
          "self": "", 
          "target_locator_type": "None", 
          "browser_name": "\"all\"", 
          "source_locator_type": "None", 
          "source_locator": "None", 
          "element_tag": "None", 
          "second_element_tag": "None"
        }, 
        "def": "def drag_and_drop_an_element(self, system_name, source_locator_type=None,source_locator=None, target_locator_type=None,target_locator=None, element_config_file=None,second_element_config_file=None,element_tag=None, second_element_tag=None,browser_name=\"all\"):", 
        "line": 1425, 
        "type": "fn", 
        "fn": "drag_and_drop_an_element"
      }, 
      {
        "comment": [
          "This will perform the mouse over operation in the given element", 
          "", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "<system name=\"name_of_thy_system\"/>", 
          "", 
          "2. browser_name = This <browser_name> tag is a child og the", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          "", 
          "3. locator_type = This contains information about the type of", 
          "locator that you want to use. Can be 'xpath',", 
          "'id', 'css', 'link', 'tag','class', 'name'", 
          "", 
          "4. locator = This contains the value of the locator. Something like", 
          "\"form\", \"nav-tags\", \"//[dh./dhh[yby]\"", 
          "", 
          "5. element_config_file = This contains the location of the json", 
          "file that contains information about all", 
          "the elements that you require for the", 
          "testcase execution", 
          "6. element_tag = This contains the name of the element in that", 
          "element_config_file which you want to use", 
          "", 
          "USING LOCATOR_TYPE, LOCATOR, ELEMENT_CONFIG_FILE, AND ELEMENT_TAG", 
          "=================================================================", 
          "", 
          "None of these arguments are mandatory BUT to search an element or to", 
          "retrieve it from the data repository, you need to provide Warrior", 
          "with some way to do it.", 
          "", 
          "a. You can either directly give values for the locator_type and", 
          "locator. So if locator_type = name and locator = navigation-bar,", 
          "then Warrior can search for an element with name \"navigation-bar\"", 
          "", 
          "b. You can give location of the element_config_file and a tag inside", 
          "it so that Warrior can search for that tag and get the required", 
          "information from there.", 
          "", 
          "- Now, if the locator type is given, Warrior", 
          "will search for that locator_type in the children of that element in", 
          "the element_config_file", 
          "", 
          "- You can also set defaults in the element_config_file, and now,", 
          "even if the locator_type is not given, Warrior will know which", 
          "element to find. If locator_type is given, the default will be", 
          "overridden", 
          "", 
          "- If locator_type is not f=given, and the defaults are not", 
          "specified, then the first element in the child list of the element", 
          "tag would be picked.", 
          "", 
          "NOTES:", 
          "For these four arguments to be given correctly, ONE of the", 
          "following conditions must be satisfied.", 
          "", 
          "1. locator_type and locator must be given", 
          "2. locator_type, element_config_file, and element_tag must be given", 
          "3. element_config_file, and element_tag must be given", 
          "", 
          "The datafile has the first priority, then the json file, and", 
          "then finally the testcase.", 
          "", 
          "If all arguments are passed from the same place, then, if", 
          "locator and locator_type are given, then they would have", 
          "priority. Otherwise, the element_config_file would be searched", 
          "", 
          "The locator_type locator, element_tag can be given the datafile", 
          "as children of the <browser> tag, but these values would remain", 
          "constant for that browser. It is recommended that these values", 
          "be passed from the testcase step.", 
          "", 
          "The element_config_file typically would not change from step to", 
          "step, so it can be passed from the data file", 
          "", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. locator_type(str) = type of the locator - xpath, id, etc.", 
          "3. locator(str) = locator by which the elemnt should be located.", 
          "4. browser_name(str) = Unique name for this particular browser", 
          "5. element_config_file(str) = location of the element config file", 
          "6. element_tag(str) = json id of the locator that you want to use", 
          "from the element config file", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "simulate a mouse over operation", 
        "args": [
          "self", 
          "system_name", 
          "locator_type=None", 
          "locator=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "locator_type": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "locator": "None", 
          "element_config_file": "None", 
          "element_tag": "None"
        }, 
        "def": "def mouse_over(self, system_name, locator_type=None, locator=None,element_config_file=None, element_tag=None,browser_name=\"all\"):", 
        "line": 1638, 
        "type": "fn", 
        "fn": "mouse_over"
      }, 
      {
        "comment": [
          "This will execute the user provided script", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "", 
          "<system name=\"name_of_thy_system\"/>", 
          "2. user_script = string containing javascript as argument", 
          "", 
          "3. browser_name = This <browser_name> tag is a child of the", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. user_script(str) = string containing javascript", 
          "3. browser_name(str) = Unique name for this particular browser", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "To execute a user provided script", 
        "args": [
          "self", 
          "system_name", 
          "user_script=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "browser_name": "\"all\"", 
          "user_script": "None"
        }, 
        "def": "def execute_script(self, system_name, user_script=None, browser_name=\"all\"):", 
        "line": 1804, 
        "type": "fn", 
        "fn": "execute_script"
      }, 
      {
        "comment": [
          "This will drag and drop the given element to the user provided x and y offset position", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "", 
          "<system name=\"name_of_thy_system\"/>", 
          "", 
          "2. browser_name = This <browser_name> tag is a child of the", 
          "", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          "", 
          "3. source_locator_type = This contains information about the type", 
          "of locator that you want to use to locate", 
          "the source element that needs to dragged.", 
          "Can be 'xpath', 'id', 'css', 'link', 'tag',", 
          "'class', 'name'", 
          "", 
          "4. source_locator = This contains the value of the locator of the", 
          "source element that needs to be dragged.", 
          "Something like \"form\", \"nav-tags\",", 
          "\"//[dh./dhh[yby]\"", 
          "", 
          "5. element_config_file = This contains the location of the default", 
          "json file that contains information about", 
          "all the elements that you require for the", 
          "testcase execution", 
          "", 
          "6. element_tag = This contains the name of the default element in", 
          "either of the element_config_files which you want", 
          "to use", 
          "", 
          "", 
          "USING SOURCE_LOCATOR_TYPE, LOCATOR, ELEMENT_CONFIG_FILE, ELEMENT_TAG", 
          "=================================================================", 
          "", 
          "None of these arguments are mandatory BUT to search an element or to", 
          "retrieve it from the data repository, you need to provide Warrior", 
          "with some way to do it.", 
          "", 
          "a. You can either directly give values for the", 
          "source_locator_type and source_locator. So if", 
          "source_locator_type = name and", 
          "source_locator = navigation-bar, then Warrior can search for", 
          "an element with name \"navigation-bar\"", 
          "", 
          "b. You can give location of the element_config_files and a tag inside", 
          "it so that Warrior can search for that tag and get the required", 
          "information from there.", 
          "", 
          "- Now, if the source_locator type is given, Warrior", 
          "will search for that source_locator_type in the children of", 
          "that element in the element_config_file", 
          "", 
          "- You can also set defaults in the element_config_files, and now,", 
          "even if the source_locator_type is not given, Warrior will", 
          "know which element to find. If source_locator_type is given,", 
          "the default will be overridden", 
          "", 
          "- If source_locator_type is not given, and the defaults are", 
          "not specified, then the first element in the child list of the", 
          "element tag would be picked.", 
          "NOTES:", 
          "For these four arguments to be given correctly, ONE of the", 
          "following conditions must be satisfied.", 
          "", 
          "1. source_locator_type and source_locator must be", 
          "given", 
          "2. source_locator_type, element_config_file, and", 
          "element_tag must be given", 
          "3. element_config_file, and element_tag must be given", 
          "", 
          "The datafile has the first priority, then the json file, and", 
          "then finally the testcase.", 
          "", 
          "If all arguments are passed from the same place, then, if", 
          "source_locator and source_locator_type are given,", 
          "then they would have priority. Otherwise, the", 
          "element_config_file would be searched", 
          "", 
          "The source_locator_type locator, element_tag can be given", 
          "the datafile as children of the <browser> tag, but these values", 
          "would remain constant for that browser. It is recommended that", 
          "these values be passed from the testcase step.", 
          "", 
          "The element_config_file typically would not change from step to", 
          "step, so it can be passed from the data file", 
          "", 
          "The element_config_files and element_tags can be linked to one another", 
          "as the example given below:", 
          "", 
          "Eg:", 
          "", 
          "<step TS= '25' Driver='selenium_driver' Keyword='drag_and_drop_an_element' >", 
          "<Arguments>", 
          "<argument name=\"system_name\" value=\"system_1\"/>", 
          "<argument name=\"source_locator_type\" value=\"element_tag=xpath\"/>", 
          "<argument name=\"element_config_file\" value=\"../Config_files/demo_selenium_tc_Config_1.json\"/>", 
          "<argument name=\"element_tag\" value=\"element_config_file=source\"/>", 
          "<argument name=\"xoffset\" value=\"100\"/>", 
          "<argument name=\"yoffset\" value=\"0\"/>", 
          "</Arguments>", 
          "</step>", 
          "Here, the source_locator_type will be searched for in the element_tag", 
          "in the element_config_file", 
          "", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. source_locator_type(str) = type of the locator - xpath, id, etc", 
          "for the source element", 
          "3. source_locator(str) = locator by which the elemnt should be", 
          "located for the source element", 
          "4. element_config_file(str) = location of the element config file", 
          "5. element_tag(str) = json id of the locator that you want to use", 
          "from the element config file", 
          "6. xoffset = X offset to move to", 
          "7. yoffset = Y offset to move to", 
          "8. browser_name(str) = Unique name for this particular browser", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "Simulate a drag and drop with offset", 
        "args": [
          "self", 
          "system_name", 
          "source_locator_type=None", 
          "source_locator=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "xoffset=None", 
          "yoffset=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "element_config_file": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "yoffset": "None", 
          "source_locator_type": "None", 
          "source_locator": "None", 
          "element_tag": "None", 
          "xoffset": "None"
        }, 
        "def": "def drag_and_drop_by_offset(self, system_name, source_locator_type=None,source_locator=None, element_config_file=None,element_tag=None, xoffset=None, yoffset=None,browser_name=\"all\"):", 
        "line": 1881, 
        "type": "fn", 
        "fn": "drag_and_drop_by_offset"
      }, 
      {
        "comment": [
          "This will get property or attribute of the given element", 
          "", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "", 
          "<system name=\"name_of_thy_system\"/>", 
          "", 
          "2. browser_name = This <browser_name> tag is a child og the", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          "", 
          "3. attribute_name = This contains information about the attribute", 
          "name of the element who's property you want to", 
          "get.", 
          "", 
          "4. locator_type = This contains information about the type of", 
          "locator that you want to use. Can be 'xpath',", 
          "'id', 'css', 'link', 'tag','class', 'name'", 
          "", 
          "5. locator = This contains the value of the locator. Something like", 
          "\"form\", \"nav-tags\", \"//[dh./dhh[yby]\"", 
          "", 
          "6. element_config_file = This contains the location of the json", 
          "file that contains information about all", 
          "the elements that you require for the", 
          "testcase execution", 
          "7. element_tag = This contains the name of the element in that", 
          "element_config_file which you want to use", 
          "", 
          "USING LOCATOR_TYPE, LOCATOR, ELEMENT_CONFIG_FILE, AND ELEMENT_TAG", 
          "=================================================================", 
          "", 
          "None of these arguments are mandatory BUT to search an element or to", 
          "retrieve it from the data repository, you need to provide Warrior", 
          "with some way to do it.", 
          "", 
          "a. You can either directly give values for the locator_type and", 
          "locator. So if locator_type = name and locator = navigation-bar,", 
          "then Warrior can search for an element with name \"navigation-bar\"", 
          "", 
          "b. You can give location of the element_config_file and a tag inside", 
          "it so that Warrior can search for that tag and get the required", 
          "information from there.", 
          "", 
          "- Now, if the locator type is given, Warrior", 
          "will search for that locator_type in the children of that element in", 
          "the element_config_file", 
          "", 
          "- You can also set defaults in the element_config_file, and now,", 
          "even if the locator_type is not given, Warrior will know which", 
          "element to find. If locator_type is given, the default will be", 
          "overridden", 
          "", 
          "- If locator_type is not f=given, and the defaults are not", 
          "specified, then the first element in the child list of the element", 
          "tag would be picked.", 
          "", 
          "NOTES:", 
          "For these four arguments to be given correctly, ONE of the", 
          "following conditions must be satisfied.", 
          "", 
          "1. locator_type and locator must be given", 
          "2. locator_type, element_config_file, and element_tag must be given", 
          "3. element_config_file, and element_tag must be given", 
          "", 
          "The datafile has the first priority, then the json file, and", 
          "then finally the testcase.", 
          "", 
          "If all arguments are passed from the same place, then, if", 
          "locator and locator_type are given, then they would have", 
          "priority. Otherwise, the element_config_file would be searched", 
          "", 
          "The locator_type locator, element_tag can be given the datafile", 
          "as children of the <browser> tag, but these values would remain", 
          "constant for that browser. It is recommended that these values", 
          "be passed from the testcase step.", 
          "", 
          "The element_config_file typically would not change from step to", 
          "step, so it can be passed from the data file", 
          "", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. locator_type(str) = type of the locator - xpath, id, etc.", 
          "3. attribute_name (str) = Name of the attribute", 
          "4. locator(str) = locator by which the elemnt should be located.", 
          "5. browser_name(str) = Unique name for this particular browser", 
          "6. element_config_file(str) = location of the element config file", 
          "7. element_tag(str) = json id of the locator that you want to use", 
          "from the element config file", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "Gets the requested attribute or property of the element.", 
        "args": [
          "self", 
          "system_name", 
          "attribute_name", 
          "locator_type=None", 
          "locator=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "attribute_name": "", 
          "locator_type": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "locator": "None", 
          "element_config_file": "None", 
          "element_tag": "None"
        }, 
        "def": "def get_property_of_element(self, system_name, attribute_name,locator_type=None, locator=None,element_config_file=None, element_tag=None,browser_name=\"all\"):", 
        "line": 2069, 
        "type": "fn", 
        "fn": "get_property_of_element"
      }, 
      {
        "comment": [
          "This will get property or attribute of the given element", 
          "", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "", 
          "<system name=\"name_of_thy_system\"/>", 
          "", 
          "2. browser_name = This <browser_name> tag is a child og the", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          "", 
          "3. attribute_name = This contains information about the attribute", 
          "name of the element who's property you want to", 
          "verify.", 
          "", 
          "4. property_name = This contains information about the property you", 
          "want to verify.", 
          "", 
          "5. locator_type = This contains information about the type of", 
          "locator that you want to use. Can be 'xpath',", 
          "'id', 'css', 'link', 'tag','class', 'name'", 
          "", 
          "6. locator = This contains the value of the locator. Something like", 
          "\"form\", \"nav-tags\", \"//[dh./dhh[yby]\"", 
          "", 
          "7. element_config_file = This contains the location of the json", 
          "file that contains information about all", 
          "the elements that you require for the", 
          "testcase execution", 
          "8. element_tag = This contains the name of the element in that", 
          "element_config_file which you want to use", 
          "", 
          "USING LOCATOR_TYPE, LOCATOR, ELEMENT_CONFIG_FILE, AND ELEMENT_TAG", 
          "=================================================================", 
          "", 
          "None of these arguments are mandatory BUT to search an element or to", 
          "retrieve it from the data repository, you need to provide Warrior", 
          "with some way to do it.", 
          "", 
          "a. You can either directly give values for the locator_type and", 
          "locator. So if locator_type = name and locator = navigation-bar,", 
          "then Warrior can search for an element with name \"navigation-bar\"", 
          "", 
          "b. You can give location of the element_config_file and a tag inside", 
          "it so that Warrior can search for that tag and get the required", 
          "information from there.", 
          "", 
          "- Now, if the locator type is given, Warrior", 
          "will search for that locator_type in the children of that element in", 
          "the element_config_file", 
          "", 
          "- You can also set defaults in the element_config_file, and now,", 
          "even if the locator_type is not given, Warrior will know which", 
          "element to find. If locator_type is given, the default will be", 
          "overridden", 
          "", 
          "- If locator_type is not f=given, and the defaults are not", 
          "specified, then the first element in the child list of the element", 
          "tag would be picked.", 
          "", 
          "NOTES:", 
          "For these four arguments to be given correctly, ONE of the", 
          "following conditions must be satisfied.", 
          "", 
          "1. locator_type and locator must be given", 
          "2. locator_type, element_config_file, and element_tag must be given", 
          "3. element_config_file, and element_tag must be given", 
          "", 
          "The datafile has the first priority, then the json file, and", 
          "then finally the testcase.", 
          "", 
          "If all arguments are passed from the same place, then, if", 
          "locator and locator_type are given, then they would have", 
          "priority. Otherwise, the element_config_file would be searched", 
          "", 
          "The locator_type locator, element_tag can be given the datafile", 
          "as children of the <browser> tag, but these values would remain", 
          "constant for that browser. It is recommended that these values", 
          "be passed from the testcase step.", 
          "", 
          "The element_config_file typically would not change from step to", 
          "step, so it can be passed from the data file", 
          "", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. locator_type(str) = type of the locator - xpath, id, etc.", 
          "3. attribute_name (str) = Name of the attribute", 
          "4. property_name (str) = Name of the property", 
          "5. locator(str) = locator by which the elemnt should be located.", 
          "6. browser_name(str) = Unique name for this particular browser", 
          "7. element_config_file(str) = location of the element config file", 
          "8. element_tag(str) = json id of the locator that you want to use", 
          "from the element config file", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "Checks the given attribute or property of the element.", 
        "args": [
          "self", 
          "system_name", 
          "attribute_name", 
          "property_name", 
          "locator_type=None", 
          "locator=None", 
          "element_config_file=None", 
          "element_tag=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "attribute_name": "", 
          "locator_type": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "locator": "None", 
          "element_config_file": "None", 
          "element_tag": "None", 
          "property_name": ""
        }, 
        "def": "def check_property_of_element(self, system_name, attribute_name,property_name, locator_type=None,locator=None, element_config_file=None,element_tag=None, browser_name=\"all\"):", 
        "line": 2242, 
        "type": "fn", 
        "fn": "check_property_of_element"
      }, 
      {
        "comment": [
          "This will simulate key presses for the given keys", 
          "", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "", 
          "<system name=\"name_of_thy_system\"/>", 
          "", 
          "2. browser_name = This <browser_name> tag is a child og the", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          "", 
          "3. keys = This argument takes in the keys whose keypresses need to", 
          "be simulated. It an be just one key - or if multiple", 
          "keys are needed, then a comma separated list of keys", 
          "", 
          "Eg: f5", 
          "control, alt, delete", 
          "", 
          "4. simultaneous = When set to 'yes', all the key-presses for the", 
          "given keys would be performed simultaneously. When", 
          "set to 'no', the key-presses for the keys would be", 
          "simulated one after the other.", 
          "", 
          "", 
          "7. element_config_file = This contains the location of the json", 
          "file that contains information about all", 
          "the elements that you require for the", 
          "testcase execution", 
          "", 
          "8. element_tag = This contains the name of the element in that", 
          "element_config_file which you want to use", 
          "", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. keys (str) = The keys whose key-presses have to be simulated", 
          "3. simultaneous (str) = Whether the keys given above should be", 
          "pressed simultaneously or not", 
          "4. browser_name(str) = Unique name for this particular browser", 
          "5. element_config_file(str) = location of the element config file", 
          "6. element_tag(str) = json id of the locator that you want to use", 
          "from the element config file", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "Simulates key presses for the given keys", 
        "args": [
          "self", 
          "system_name", 
          "keys", 
          "simultaneous=\"yes\"", 
          "element_config_file=None", 
          "element_tag=None", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "keys": "", 
          "element_config_file": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "simultaneous": "\"yes\"", 
          "element_tag": "None"
        }, 
        "def": "def perform_keypress(self, system_name, keys, simultaneous=\"yes\",element_config_file=None,element_tag=None, browser_name=\"all\"):", 
        "line": 2421, 
        "type": "fn", 
        "fn": "perform_keypress"
      }
    ], 
    [
      {
        "comment": [
          " Selenium keywords for Generic Browser Actions "
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "browser_actions.py", 
        "line": 1, 
        "type": "package", 
        "fn": "browser_actions"
      }, 
      {
        "comment": [
          "This is a class that deals with all 'browser' related functionality like", 
          "opening and closing a browser, maximizing a browser window, navigating to", 
          "a URL, resizing a browser window."
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "browser_actions(object):", 
        "line": 30, 
        "type": "class", 
        "fn": "browser_actions"
      }, 
      {
        "comment": [
          "This is a constructor for the browser_actions class", 
          "self.resultfile = Utils.config_Utils.resultfile", 
          "self.datafile = Utils.config_Utils.datafile", 
          "self.logsdir = Utils.config_Utils.logsdir", 
          "self.filename = Utils.config_Utils.filename", 
          "self.logfile = Utils.config_Utils.logfile", 
          "self.jsonobj = JsonUtils()", 
          "self.browser_object = BrowserManagement()"
        ], 
        "wdesc": "__init__", 
        "args": [
          "self", 
          "*args", 
          "**kwargs"
        ], 
        "argsmap": {
          "*args": "", 
          "self": "", 
          "**kwargs": ""
        }, 
        "def": "def __init__(self, *args, **kwargs):", 
        "line": 35, 
        "type": "fn", 
        "fn": "__init__"
      }, 
      {
        "comment": [
          "def browser_launch(self, system_name, browser_name=\"all\", type=\"firefox\",", 
          "url=None, ip=None, remote=None, element_config_file=None,", 
          "element_tag=None):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "output_dict = {}", 
          "wdesc = \"Opens browser instances\"", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "browser_details = {}", 
          "", 
          "if ip is None:", 
          "ip = data_Utils.getSystemData(self.datafile, system_name, \"ip\")", 
          "if remote is None:", 
          "remote = data_Utils.getSystemData(self.datafile, system_name,", 
          "\"remote\")", 
          "", 
          "webdriver_remote_url = ip if str(remote).strip().lower() == \"yes\"\\", 
          "else False", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils.\\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "browser_inst = self.browser_object.open_browser(", 
          "browser_details[\"type\"], webdriver_remote_url)", 
          "if browser_inst:", 
          "browser_fullname = \"{0}_{1}\".format(system_name, browser_details[\"browser_name\"])", 
          "output_dict[browser_fullname] = browser_inst", 
          "if \"url\" in browser_details and browser_details[\"url\"]\\", 
          "is not None:", 
          "result, url = self.browser_object.check_url(browser_details[\"url\"])", 
          "if result == True:", 
          "result = self.browser_object.go_to(url,", 
          "browser_inst)", 
          "else:", 
          "result = True", 
          "else:", 
          "pNote(\"could not open browser on system={0}, \"", 
          "\"name={1}\".format(system_name,", 
          "browser_details[\"browser_name\"]),", 
          "\"error\")", 
          "result = False", 
          "status = status and result", 
          "browser_details = {}", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "return status, output_dict"
        ], 
        "wdesc": "Opens browser instances", 
        "args": [
          "self", 
          "system_name", 
          "browser_name=\"all\"", 
          "type=\"firefox\"", 
          "url=None", 
          "ip=None", 
          "remote=None", 
          "element_config_file=None", 
          "element_tag=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "remote": "None", 
          "url": "None", 
          "ip": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "element_config_file": "None", 
          "type": "\"firefox\"", 
          "element_tag": "None"
        }, 
        "def": "def browser_launch(self, system_name, browser_name=\"all\", type=\"firefox\",url=None, ip=None, remote=None, element_config_file=None,element_tag=None):", 
        "line": 45, 
        "type": "fn", 
        "fn": "browser_launch"
      }, 
      {
        "comment": [
          "def browser_maximize(self, system_name, type=\"firefox\", browser_name=\"all\"):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"The browser will get maximized\"", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if current_browser:", 
          "self.browser_object.maximize_browser_window(current_browser)", 
          "else:", 
          "pNote(\"Browser of system {0} and name {1} not found in the\"", 
          "\"datarepository\"", 
          ".format(system_name, browser_details[\"browser_name\"]),", 
          "\"Exception\")", 
          "status = False", 
          "browser_details = {}", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status"
        ], 
        "wdesc": "The browser will get maximized", 
        "args": [
          "self", 
          "system_name", 
          "type=\"firefox\"", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "type": "\"firefox\"", 
          "browser_name": "\"all\""
        }, 
        "def": "def browser_maximize(self, system_name, type=\"firefox\", browser_name=\"all\"):", 
        "line": 205, 
        "type": "fn", 
        "fn": "browser_maximize"
      }, 
      {
        "comment": [
          "def navigate_to_url(self, system_name, type=\"firefox\", browser_name=\"all\",", 
          "url=None, element_config_file=None, element_tag=None):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"The webpage would be directed to the given URL\"", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if current_browser:", 
          "self.browser_object.go_to(browser_details[\"url\"],", 
          "current_browser)", 
          "else:", 
          "pNote(\"Browser of system {0} and name {1} not found in \"", 
          "\"the datarepository\"", 
          ".format(system_name, browser_details[\"browser_name\"]),", 
          "\"Exception\")", 
          "status = False", 
          "browser_details = {}", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status"
        ], 
        "wdesc": "The webpage would be directed to the given URL", 
        "args": [
          "self", 
          "system_name", 
          "type=\"firefox\"", 
          "browser_name=\"all\"", 
          "url=None", 
          "element_config_file=None", 
          "element_tag=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "url": "None", 
          "element_config_file": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "type": "\"firefox\"", 
          "element_tag": "None"
        }, 
        "def": "def navigate_to_url(self, system_name, type=\"firefox\", browser_name=\"all\",url=None, element_config_file=None, element_tag=None):", 
        "line": 290, 
        "type": "fn", 
        "fn": "navigate_to_url"
      }, 
      {
        "comment": [
          "def navigate_forward(self, system_name, type=\"firefox\", browser_name=\"all\"):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"The browser will navigate forward\"", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if current_browser:", 
          "self.browser_object.go_forward(current_browser)", 
          "else:", 
          "pNote(\"Browser of system {0} and name {1} not found in \"", 
          "\"the datarepository\"", 
          ".format(system_name, browser_details[\"browser_name\"]),", 
          "\"Exception\")", 
          "status = False", 
          "browser_details = {}", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status"
        ], 
        "wdesc": "The browser will navigate forward", 
        "args": [
          "self", 
          "system_name", 
          "type=\"firefox\"", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "type": "\"firefox\"", 
          "browser_name": "\"all\""
        }, 
        "def": "def navigate_forward(self, system_name, type=\"firefox\", browser_name=\"all\"):", 
        "line": 415, 
        "type": "fn", 
        "fn": "navigate_forward"
      }, 
      {
        "comment": [
          "def navigate_backward(self, system_name, type=\"firefox\", browser_name=\"all\"):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"The browser will navigate backward\"", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if current_browser:", 
          "self.browser_object.go_back(current_browser)", 
          "else:", 
          "pNote(\"Browser of system {0} and name {1} not found in \"", 
          "\"the datarepository\"", 
          ".format(system_name, browser_details[\"browser_name\"]),", 
          "\"Exception\")", 
          "status = False", 
          "browser_details = {}", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status"
        ], 
        "wdesc": "The browser will navigate backward", 
        "args": [
          "self", 
          "system_name", 
          "type=\"firefox\"", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "type": "\"firefox\"", 
          "browser_name": "\"all\""
        }, 
        "def": "def navigate_backward(self, system_name, type=\"firefox\", browser_name=\"all\"):", 
        "line": 500, 
        "type": "fn", 
        "fn": "navigate_backward"
      }, 
      {
        "comment": [
          "def browser_refresh(self, system_name, type=\"firefox\", browser_name=\"all\"):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"The browser will be refreshed\"", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if current_browser:", 
          "self.browser_object.reload_page(current_browser)", 
          "else:", 
          "pNote(\"Browser of system {0} and name {1} not found in \"", 
          "\"the datarepository\"", 
          ".format(system_name, browser_details[\"browser_name\"]),", 
          "\"Exception\")", 
          "status = False", 
          "browser_details = {}", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status"
        ], 
        "wdesc": "The browser will be refreshed", 
        "args": [
          "self", 
          "system_name", 
          "type=\"firefox\"", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "type": "\"firefox\"", 
          "browser_name": "\"all\""
        }, 
        "def": "def browser_refresh(self, system_name, type=\"firefox\", browser_name=\"all\"):", 
        "line": 585, 
        "type": "fn", 
        "fn": "browser_refresh"
      }, 
      {
        "comment": [
          "def browser_reload(self, system_name, type=\"firefox\", browser_name=\"all\"):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"The browser will be reloaded\"", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if current_browser:", 
          "self.browser_object.hard_reload_page(current_browser)", 
          "else:", 
          "pNote(\"Browser of system {0} and name {1} not found in \"", 
          "\"the datarepository\"", 
          ".format(system_name, browser_details[\"browser_name\"]),", 
          "\"Exception\")", 
          "status = False", 
          "browser_details = {}", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status"
        ], 
        "wdesc": "The browser will be reloaded", 
        "args": [
          "self", 
          "system_name", 
          "type=\"firefox\"", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "type": "\"firefox\"", 
          "browser_name": "\"all\""
        }, 
        "def": "def browser_reload(self, system_name, type=\"firefox\", browser_name=\"all\"):", 
        "line": 670, 
        "type": "fn", 
        "fn": "browser_reload"
      }, 
      {
        "comment": [
          "def browser_close(self, system_name, type=\"firefox\", browser_name=\"all\"):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"The browser will be closed\"", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if current_browser:", 
          "self.browser_object.close_browser(current_browser)", 
          "else:", 
          "pNote(\"Browser of system {0} and name {1} not found in the \"", 
          "\"datarepository\"", 
          ".format(system_name, browser_details[\"browser_name\"]),", 
          "\"Exception\")", 
          "status = False", 
          "browser_details = {}", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status"
        ], 
        "wdesc": "The browser will be closed", 
        "args": [
          "self", 
          "system_name", 
          "type=\"firefox\"", 
          "browser_name=\"all\""
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "type": "\"firefox\"", 
          "browser_name": "\"all\""
        }, 
        "def": "def browser_close(self, system_name, type=\"firefox\", browser_name=\"all\"):", 
        "line": 755, 
        "type": "fn", 
        "fn": "browser_close"
      }, 
      {
        "comment": [
          "def set_window_size(self, system_name, xsize=None, ysize=None,", 
          "type=\"firefox\", browser_name=\"all\",", 
          "element_config_file=None, element_tag=None):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"The browser will be resized\"", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if current_browser:", 
          "self.browser_object.set_window_size(int(browser_details[\"xsize\"]), int(browser_details[\"ysize\"]),", 
          "current_browser)", 
          "else:", 
          "pNote(\"Browser of system {0} and name {1} not found in the \"", 
          "\"datarepository\"", 
          ".format(system_name, browser_details[\"browser_name\"]),", 
          "\"Exception\")", 
          "status = False", 
          "browser_details = {}", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status"
        ], 
        "wdesc": "The browser will be resized", 
        "args": [
          "self", 
          "system_name", 
          "xsize=None", 
          "ysize=None", 
          "type=\"firefox\"", 
          "browser_name=\"all\"", 
          "element_config_file=None", 
          "element_tag=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "element_config_file": "None", 
          "self": "", 
          "ysize": "None", 
          "browser_name": "\"all\"", 
          "xsize": "None", 
          "type": "\"firefox\"", 
          "element_tag": "None"
        }, 
        "def": "def set_window_size(self, system_name, xsize=None, ysize=None,type=\"firefox\", browser_name=\"all\",element_config_file=None, element_tag=None):", 
        "line": 840, 
        "type": "fn", 
        "fn": "set_window_size"
      }, 
      {
        "comment": [
          "def set_window_position(self, system_name, xpos=None, ypos=None,", 
          "type=\"firefox\", browser_name=\"all\",", 
          "element_config_file=None, element_tag=None):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"The browser will be set to a new position\"", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if current_browser:", 
          "self.browser_object.set_window_position(int(browser_details[\"xpos\"]),", 
          "int(browser_details[\"ypos\"]),", 
          "current_browser)", 
          "else:", 
          "pNote(\"Browser of system {0} and name {1} not found in the \"", 
          "\"datarepository\"", 
          ".format(system_name, browser_details[\"browser_name\"]),", 
          "\"Exception\")", 
          "status = False", 
          "browser_details = {}", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status"
        ], 
        "wdesc": "The browser will be set to a new position", 
        "args": [
          "self", 
          "system_name", 
          "xpos=None", 
          "ypos=None", 
          "type=\"firefox\"", 
          "browser_name=\"all\"", 
          "element_config_file=None", 
          "element_tag=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "xpos": "None", 
          "element_config_file": "None", 
          "self": "", 
          "ypos": "None", 
          "browser_name": "\"all\"", 
          "type": "\"firefox\"", 
          "element_tag": "None"
        }, 
        "def": "def set_window_position(self, system_name, xpos=None, ypos=None,type=\"firefox\", browser_name=\"all\",element_config_file=None, element_tag=None):", 
        "line": 978, 
        "type": "fn", 
        "fn": "set_window_position"
      }, 
      {
        "comment": [
          "def open_a_new_tab(self, system_name, type=\"firefox\", browser_name=\"all\",", 
          "element_config_file=None, element_tag=None, url=None):", 
          "This will open a new tab.", 
          "", 
          "DISCLAIMER - A new window will be opened for firefox as Selenium does not", 
          "support tabs in Firefox.", 
          "", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "", 
          "<system name=\"name_of_thy_system\"/>", 
          "", 
          "2. type = This <type> tag is a child og the <browser> tag in the", 
          "data file. The type of browser that should be opened can", 
          "be added in here.", 
          "", 
          "Eg: <type>firefox</type>", 
          "", 
          "3. browser_name = This <browser_name> tag is a child og the", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          "", 
          "4. url = The URL that you want to open your browser to can be added", 
          "in the <url> tag under the <browser> tag.", 
          "", 
          "Eg: <url>https://www.google.com</url>", 
          "", 
          "5. element_config_file = This <element_config_file> tag is a child", 
          "of the <browser> tag in the data file. This", 
          "stores the location of the element", 
          "configuration file that contains all", 
          "element locators.", 
          "", 
          "Eg: <element_config_file>", 
          "../Config_files/slenium_config.json", 
          "</element_config_file>", 
          "", 
          "6. element_tag = This element_tag refers to a particular element in", 
          "the json fie which contains relevant information to", 
          "that element. If you want to use this one element", 
          "through out the testcase for a particular browser,", 
          "you can include it in the data file. If this not", 
          "the case, then you should create an argument tag", 
          "in the relevant testcase step and add the value", 
          "directly in the testcase step.", 
          "", 
          "FOR DATA FILE", 
          "Eg: <element_tag>json_name_1</element_tag>", 
          "", 
          "FOR TEST CASE", 
          "Eg: <argument name=\"element_tag\" value=\"json_name_1\">", 
          "", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. type(str) = Type of browser: firefox, chrome, ie.", 
          "3. browser_name(str) = Unique name for this particular browser", 
          "4. url(str) = URL to which the browser should be directed", 
          "5. element_config_file (str) = location of the element configuration", 
          "file that contains all element", 
          "locators", 
          "6. element_tag (str) = particular element in the json fie which", 
          "contains relevant information to that element", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "The browser will open a new tab", 
        "args": [
          "self", 
          "system_name", 
          "type=\"firefox\"", 
          "browser_name=\"all\"", 
          "element_config_file=None", 
          "element_tag=None", 
          "url=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "url": "None", 
          "element_config_file": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "type": "\"firefox\"", 
          "element_tag": "None"
        }, 
        "def": "def open_a_new_tab(self, system_name, type=\"firefox\", browser_name=\"all\",element_config_file=None, element_tag=None, url=None):", 
        "line": 1117, 
        "type": "fn", 
        "fn": "open_a_new_tab"
      }, 
      {
        "comment": [
          "This keyword will let you switch between all open tabs.", 
          "", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "", 
          "<system name=\"name_of_thy_system\"/>", 
          "", 
          "2. type = This <type> tag is a child og the <browser> tag in the", 
          "data file. The type of browser that should be opened can", 
          "be added in here.", 
          "", 
          "Eg: <type>firefox</type>", 
          "", 
          "3. browser_name = This <browser_name> tag is a child og the", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          "", 
          "4. url = The URL that you want to open your browser to can be added", 
          "in the <url> tag under the <browser> tag.", 
          "", 
          "Eg: <url>https://www.google.com</url>", 
          "", 
          "5. tab_number = This <tab_number> tag is a child og the <browser>", 
          "tag in the data file. This tag would contain the", 
          "information about the tab number that you want to", 
          "switch to from the current tab", 
          "", 
          "Eg: <tab_number>3</tab_number>", 
          "", 
          "7. element_config_file = This <element_config_file> tag is a child", 
          "of the <browser> tag in the data file. This", 
          "stores the location of the element", 
          "configuration file that contains all", 
          "element locators.", 
          "", 
          "Eg: <element_config_file>", 
          "../Config_files/slenium_config.json", 
          "</element_config_file>", 
          "", 
          "8. element_tag = This element_tag refers to a particular element in", 
          "the json fie which contains relevant information to", 
          "that element. If you want to use this one element", 
          "through out the testcase for a particular browser,", 
          "you can include it in the data file. If this not", 
          "the case, then you should create an argument tag", 
          "in the relevant testcase step and add the value", 
          "directly in the testcase step.", 
          "", 
          "FOR DATA FILE", 
          "Eg: <element_tag>json_name_1</element_tag>", 
          "", 
          "FOR TEST CASE", 
          "Eg: <argument name=\"element_tag\" value=\"json_name_1\">", 
          "", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. tab_number (int/str) = The tab number that you want to switch to.", 
          "3. type(str) = Type of browser: firefox, chrome, ie.", 
          "4. browser_name(str) = Unique name for this particular browser", 
          "5. url(str) = URL to which the browser should be directed", 
          "6. element_config_file (str) = location of the element configuration", 
          "file that contains all element", 
          "locators", 
          "7. element_tag (str) = particular element in the json fie which", 
          "contains relevant information to that element", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "The browser will switch between tabs", 
        "args": [
          "self", 
          "system_name", 
          "type=\"firefox\"", 
          "browser_name=\"all\"", 
          "tab_number=None", 
          "element_config_file=None", 
          "element_tag=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "tab_number": "None", 
          "element_config_file": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "type": "\"firefox\"", 
          "element_tag": "None"
        }, 
        "def": "def switch_between_tabs(self, system_name, type=\"firefox\",browser_name=\"all\", tab_number=None,element_config_file=None, element_tag=None):", 
        "line": 1243, 
        "type": "fn", 
        "fn": "switch_between_tabs"
      }, 
      {
        "comment": [
          "This keyword will let you close an open tab.", 
          "", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "", 
          "<system name=\"name_of_thy_system\"/>", 
          "", 
          "2. type = This <type> tag is a child og the <browser> tag in the", 
          "data file. The type of browser that should be opened can", 
          "be added in here.", 
          "", 
          "Eg: <type>firefox</type>", 
          "", 
          "3. browser_name = This <browser_name> tag is a child og the", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          "", 
          "4. url = The URL that you want to open your browser to can be added", 
          "in the <url> tag under the <browser> tag.", 
          "", 
          "Eg: <url>https://www.google.com</url>", 
          "", 
          "5. tab_number = This <tab_number> tag is a child og the <browser>", 
          "tag in the data file. This tag would contain the", 
          "information about the tab number that you want to", 
          "close", 
          "", 
          "Eg: <tab_number>3</tab_number>", 
          "", 
          "7. element_config_file = This <element_config_file> tag is a child", 
          "of the <browser> tag in the data file. This", 
          "stores the location of the element", 
          "configuration file that contains all", 
          "element locators.", 
          "", 
          "Eg: <element_config_file>", 
          "../Config_files/slenium_config.json", 
          "</element_config_file>", 
          "", 
          "8. element_tag = This element_tag refers to a particular element in", 
          "the json fie which contains relevant information to", 
          "that element. If you want to use this one element", 
          "through out the testcase for a particular browser,", 
          "you can include it in the data file. If this not", 
          "the case, then you should create an argument tag", 
          "in the relevant testcase step and add the value", 
          "directly in the testcase step.", 
          "", 
          "FOR DATA FILE", 
          "Eg: <element_tag>json_name_1</element_tag>", 
          "", 
          "FOR TEST CASE", 
          "Eg: <argument name=\"element_tag\" value=\"json_name_1\">", 
          "", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. tab_number (int/str) = The tab number that you want to close.", 
          "3. type(str) = Type of browser: firefox, chrome, ie.", 
          "4. browser_name(str) = Unique name for this particular browser", 
          "5. url(str) = URL to which the browser should be directed", 
          "6. element_config_file (str) = location of the element configuration", 
          "file that contains all element", 
          "locators", 
          "7. element_tag (str) = particular element in the json fie which", 
          "contains relevant information to that element", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "The browser will switch between tabs", 
        "args": [
          "self", 
          "system_name", 
          "type=\"firefox\"", 
          "browser_name=\"all\"", 
          "tab_number=None", 
          "element_config_file=None", 
          "element_tag=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "tab_number": "None", 
          "element_config_file": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "type": "\"firefox\"", 
          "element_tag": "None"
        }, 
        "def": "def close_a_tab(self, system_name, type=\"firefox\", browser_name=\"all\",tab_number=None, element_config_file=None,element_tag=None):", 
        "line": 1377, 
        "type": "fn", 
        "fn": "close_a_tab"
      }, 
      {
        "comment": [
          "This keyword will return window size.", 
          "", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "", 
          "<system name=\"name_of_thy_system\"/>", 
          "", 
          "2. type = This <type> tag is a child og the <browser> tag in the", 
          "data file. The type of browser that should be opened can", 
          "be added in here.", 
          "", 
          "Eg: <type>firefox</type>", 
          "", 
          "3. browser_name = This <browser_name> tag is a child og the", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          "", 
          "4. url = The URL that you want to open your browser to can be added", 
          "in the <url> tag under the <browser> tag.", 
          "", 
          "Eg: <url>https://www.google.com</url>", 
          "", 
          "5. element_config_file = This <element_config_file> tag is a child", 
          "of the <browser> tag in the data file. This", 
          "stores the location of the element", 
          "configuration file that contains all", 
          "element locators.", 
          "", 
          "Eg: <element_config_file>", 
          "../Config_files/slenium_config.json", 
          "</element_config_file>", 
          "", 
          "6. element_tag = This element_tag refers to a particular element in", 
          "the json fie which contains relevant information to", 
          "that element. If you want to use this one element", 
          "through out the testcase for a particular browser,", 
          "you can include it in the data file. If this not", 
          "the case, then you should create an argument tag", 
          "in the relevant testcase step and add the value", 
          "directly in the testcase step.", 
          "", 
          "FOR DATA FILE", 
          "Eg: <element_tag>json_name_1</element_tag>", 
          "", 
          "FOR TEST CASE", 
          "Eg: <argument name=\"element_tag\" value=\"json_name_1\">", 
          "", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. type(str) = Type of browser: firefox, chrome, ie.", 
          "3. browser_name(str) = Unique name for this particular browser", 
          "4. url(str) = URL to which the browser should be directed", 
          "5. element_config_file (str) = location of the element configuration", 
          "file that contains all element", 
          "locators", 
          "6. element_tag (str) = particular element in the json fie which", 
          "contains relevant information to that element", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "The browser will return current window size", 
        "args": [
          "self", 
          "system_name", 
          "type=\"firefox\"", 
          "browser_name=\"all\"", 
          "element_config_file=None", 
          "element_tag=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "element_config_file": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "type": "\"firefox\"", 
          "element_tag": "None"
        }, 
        "def": "def get_window_size(self, system_name, type=\"firefox\", browser_name=\"all\",element_config_file=None, element_tag=None):", 
        "line": 1511, 
        "type": "fn", 
        "fn": "get_window_size"
      }, 
      {
        "comment": [
          "This keyword will return the window position.", 
          "", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "", 
          "<system name=\"name_of_thy_system\"/>", 
          "", 
          "2. type = This <type> tag is a child og the <browser> tag in the", 
          "data file. The type of browser that should be opened can", 
          "be added in here.", 
          "", 
          "Eg: <type>firefox</type>", 
          "", 
          "3. browser_name = This <browser_name> tag is a child og the", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          "", 
          "4. url = The URL that you want to open your browser to can be added", 
          "in the <url> tag under the <browser> tag.", 
          "", 
          "Eg: <url>https://www.google.com</url>", 
          "", 
          "5. element_config_file = This <element_config_file> tag is a child", 
          "of the <browser> tag in the data file. This", 
          "stores the location of the element", 
          "configuration file that contains all", 
          "element locators.", 
          "", 
          "Eg: <element_config_file>", 
          "../Config_files/slenium_config.json", 
          "</element_config_file>", 
          "", 
          "6. element_tag = This element_tag refers to a particular element in", 
          "the json fie which contains relevant information to", 
          "that element. If you want to use this one element", 
          "through out the testcase for a particular browser,", 
          "you can include it in the data file. If this not", 
          "the case, then you should create an argument tag", 
          "in the relevant testcase step and add the value", 
          "directly in the testcase step.", 
          "", 
          "FOR DATA FILE", 
          "Eg: <element_tag>json_name_1</element_tag>", 
          "", 
          "FOR TEST CASE", 
          "Eg: <argument name=\"element_tag\" value=\"json_name_1\">", 
          "", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. type(str) = Type of browser: firefox, chrome, ie.", 
          "3. browser_name(str) = Unique name for this particular browser", 
          "4. url(str) = URL to which the browser should be directed", 
          "5. element_config_file (str) = location of the element configuration", 
          "file that contains all element", 
          "locators", 
          "6. element_tag (str) = particular element in the json fie which", 
          "contains relevant information to that element", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "The browser will return current window position", 
        "args": [
          "self", 
          "system_name", 
          "type=\"firefox\"", 
          "browser_name=\"all\"", 
          "element_config_file=None", 
          "element_tag=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "element_config_file": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "type": "\"firefox\"", 
          "element_tag": "None"
        }, 
        "def": "def get_window_position(self, system_name, type=\"firefox\",browser_name=\"all\", element_config_file=None,element_tag=None):", 
        "line": 1635, 
        "type": "fn", 
        "fn": "get_window_position"
      }, 
      {
        "comment": [
          "This keyword will save a screenshot of the current browser window.", 
          "", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "", 
          "<system name=\"name_of_thy_system\"/>", 
          "", 
          "2. type = This <type> tag is a child og the <browser> tag in the", 
          "data file. The type of browser that should be opened can", 
          "be added in here.", 
          "", 
          "Eg: <type>firefox</type>", 
          "", 
          "3. browser_name = This <browser_name> tag is a child og the", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          "", 
          "4. url = The URL that you want to open your browser to can be added", 
          "in the <url> tag under the <browser> tag.", 
          "", 
          "Eg: <url>https://www.google.com</url>", 
          "", 
          "5. directory = This <directory> tag is a child og the <browser> tag", 
          "in the data file. This tag would contain the", 
          "information about the directory in which you want to", 
          "store the screenshot. If left empty, the screenshots", 
          "would be saved in the Logs directory", 
          "", 
          "Eg: <directory>/home/user/screenshots</directory>", 
          "", 
          "5. filename = This <filename> tag is a child of the <browser> tag in", 
          "the data file. This tag would contain the information", 
          "about the name of file that you want the screenshot to", 
          "have. If left empty, the screenshot file would be", 
          "saved with the name screenshot_*timestamp*", 
          "", 
          "Eg: <filename>new_screenshot</filename>", 
          "", 
          "7. element_config_file = This <element_config_file> tag is a child", 
          "of the <browser> tag in the data file. This", 
          "stores the location of the element", 
          "configuration file that contains all", 
          "element locators.", 
          "", 
          "Eg: <element_config_file>", 
          "../Config_files/selenium_config.json", 
          "</element_config_file>", 
          "", 
          "8. element_tag = This element_tag refers to a particular element in", 
          "the json fie which contains relevant information to", 
          "that element. If you want to use this one element", 
          "through out the testcase for a particular browser,", 
          "you can include it in the data file. If this not", 
          "the case, then you should create an argument tag", 
          "in the relevant testcase step and add the value", 
          "directly in the testcase step.", 
          "", 
          "FOR DATA FILE", 
          "Eg: <element_tag>json_name_1</element_tag>", 
          "", 
          "FOR TEST CASE", 
          "Eg: <argument name=\"element_tag\" value=\"json_name_1\">", 
          "", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. directory (str) = The directory that would store the", 
          "screenshots.", 
          "3. filename (str) = Name of the screenshot file", 
          "4. type(str) = Type of browser: firefox, chrome, ie.", 
          "5. browser_name(str) = Unique name for this particular browser", 
          "6. url(str) = URL to which the browser should be directed", 
          "7. element_config_file (str) = location of the element configuration", 
          "file that contains all element", 
          "locators", 
          "8. element_tag (str) = particular element in the json fie which", 
          "contains relevant information to that element", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "A screenshot of the current browser window would be saved", 
        "args": [
          "self", 
          "system_name", 
          "type=\"firefox\"", 
          "directory=None", 
          "filename =None", 
          "browser_name=\"all\"", 
          "element_config_file=None", 
          "element_tag=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "filename ": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "element_config_file": "None", 
          "directory": "None", 
          "type": "\"firefox\"", 
          "element_tag": "None"
        }, 
        "def": "def save_screenshot(self, system_name, type=\"firefox\", directory=None,filename =None, browser_name=\"all\",element_config_file=None, element_tag=None):", 
        "line": 1761, 
        "type": "fn", 
        "fn": "save_screenshot"
      }, 
      {
        "comment": [
          "This keyword will delete all cookies of a browser instance.", 
          "", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "", 
          "<system name=\"name_of_thy_system\"/>", 
          "", 
          "2. type = This <type> tag is a child og the <browser> tag in the", 
          "data file. The type of browser that should be opened can", 
          "be added in here.", 
          "", 
          "Eg: <type>firefox</type>", 
          "", 
          "3. browser_name = This <browser_name> tag is a child og the", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          "", 
          "4. url = The URL that you want to open your browser to can be added", 
          "in the <url> tag under the <browser> tag.", 
          "", 
          "Eg: <url>https://www.google.com</url>", 
          "", 
          "5. element_config_file = This <element_config_file> tag is a child", 
          "of the <browser> tag in the data file. This", 
          "stores the location of the element", 
          "configuration file that contains all", 
          "element locators.", 
          "", 
          "Eg: <element_config_file>", 
          "../Config_files/slenium_config.json", 
          "</element_config_file>", 
          "", 
          "6. element_tag = This element_tag refers to a particular element in", 
          "the json fie which contains relevant information to", 
          "that element. If you want to use this one element", 
          "through out the testcase for a particular browser,", 
          "you can include it in the data file. If this not", 
          "the case, then you should create an argument tag", 
          "in the relevant testcase step and add the value", 
          "directly in the testcase step.", 
          "", 
          "FOR DATA FILE", 
          "Eg: <element_tag>json_name_1</element_tag>", 
          "", 
          "FOR TEST CASE", 
          "Eg: <argument name=\"element_tag\" value=\"json_name_1\">", 
          "", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. type(str) = Type of browser: firefox, chrome, ie.", 
          "3. browser_name(str) = Unique name for this particular browser", 
          "4. url(str) = URL to which the browser should be directed", 
          "5. element_config_file (str) = location of the element configuration", 
          "file that contains all element", 
          "locators", 
          "6. element_tag (str) = particular element in the json fie which", 
          "contains relevant information to that element", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "All cookies of  this browser instance would be deleted", 
        "args": [
          "self", 
          "system_name", 
          "type=\"firefox\"", 
          "browser_name=\"all\"", 
          "element_config_file=None", 
          "element_tag=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "element_config_file": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "type": "\"firefox\"", 
          "element_tag": "None"
        }, 
        "def": "def delete_cookies(self, system_name, type=\"firefox\", browser_name=\"all\",element_config_file=None, element_tag=None):", 
        "line": 1912, 
        "type": "fn", 
        "fn": "delete_cookies"
      }, 
      {
        "comment": [
          "This keyword will delete a particular cookie of a browser instance.", 
          "", 
          ":Datafile Usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem. If both tag and attribute is provided the attribute will", 
          "be used.", 
          "", 
          "1. system_name = This attribute can be specified in the datafile as", 
          "a <system> tag directly under the <credentials>", 
          "tag. An attribute \"name\" has to be added to this", 
          "tag and the value of that attribute would be taken", 
          "in as value to this keyword attribute.", 
          "", 
          "<system name=\"name_of_thy_system\"/>", 
          "", 
          "2. type = This <type> tag is a child og the <browser> tag in the", 
          "data file. The type of browser that should be opened can", 
          "be added in here.", 
          "", 
          "Eg: <type>firefox</type>", 
          "", 
          "3. cookie_name = This <cookie_name> tag is a child og the <browser>", 
          "tag in the data file. The name of the ccokie that", 
          "you want to delete can be added here.", 
          "", 
          "Eg: <cookie_name>gmail_cookie</cookie_name>", 
          "", 
          "4. browser_name = This <browser_name> tag is a child og the", 
          "<browser> tag in the data file. Each browser", 
          "instance should have a unique name. This name can", 
          "be added here", 
          "", 
          "Eg: <browser_name>Unique_name_1</browser_name>", 
          "", 
          "5. url = The URL that you want to open your browser to can be added", 
          "in the <url> tag under the <browser> tag.", 
          "", 
          "Eg: <url>https://www.google.com</url>", 
          "", 
          "6. element_config_file = This <element_config_file> tag is a child", 
          "of the <browser> tag in the data file. This", 
          "stores the location of the element", 
          "configuration file that contains all", 
          "element locators.", 
          "", 
          "Eg: <element_config_file>", 
          "../Config_files/slenium_config.json", 
          "</element_config_file>", 
          "", 
          "7. element_tag = This element_tag refers to a particular element in", 
          "the json fie which contains relevant information to", 
          "that element. If you want to use this one element", 
          "through out the testcase for a particular browser,", 
          "you can include it in the data file. If this not", 
          "the case, then you should create an argument tag", 
          "in the relevant testcase step and add the value", 
          "directly in the testcase step.", 
          "", 
          "FOR DATA FILE", 
          "Eg: <element_tag>json_name_1</element_tag>", 
          "", 
          "FOR TEST CASE", 
          "Eg: <argument name=\"element_tag\" value=\"json_name_1\">", 
          "", 
          ":Arguments:", 
          "", 
          "1. system_name(str) = the system name.", 
          "2. type(str) = Type of browser: firefox, chrome, ie.", 
          "3. cookie_name (str) = Name of the cookie that you want to delete", 
          "4. browser_name(str) = Unique name for this particular browser", 
          "5. url(str) = URL to which the browser should be directed", 
          "6. element_config_file (str) = location of the element configuration", 
          "file that contains all element", 
          "locators", 
          "7. element_tag (str) = particular element in the json fie which", 
          "contains relevant information to that element", 
          "", 
          ":Returns:", 
          "", 
          "1. status(bool)= True / False."
        ], 
        "wdesc": "A particular cookie of the browser instance would be deleted", 
        "args": [
          "self", 
          "system_name", 
          "cookie_name", 
          "type=\"firefox\"", 
          "browser_name=\"all\"", 
          "element_config_file=None", 
          "element_tag=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "element_config_file": "None", 
          "self": "", 
          "cookie_name": "", 
          "browser_name": "\"all\"", 
          "type": "\"firefox\"", 
          "element_tag": "None"
        }, 
        "def": "def delete_a_cookie(self, system_name, cookie_name, type=\"firefox\",browser_name=\"all\", element_config_file=None,element_tag=None):", 
        "line": 2034, 
        "type": "fn", 
        "fn": "delete_a_cookie"
      }
    ], 
    [
      {
        "comment": [
          " Selenium keywords for Verify Actions "
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "verify_actions.py", 
        "line": 1, 
        "type": "package", 
        "fn": "verify_actions"
      }, 
      {
        "comment": [
          "This class deals with functionality related to verifications that can be", 
          "performed in a browser window - like verifying a page by its property (like", 
          "url, title, page source, and name), verifying if an alert is present on the", 
          "webpage"
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "verify_actions(object):", 
        "line": 35, 
        "type": "class", 
        "fn": "verify_actions"
      }, 
      {
        "comment": [
          "This is a constructor for the verify_actions class", 
          "self.resultfile = Utils.config_Utils.resultfile", 
          "self.datafile = Utils.config_Utils.datafile", 
          "self.logsdir = Utils.config_Utils.logsdir", 
          "self.filename = Utils.config_Utils.filename", 
          "self.logfile = Utils.config_Utils.logfile", 
          "self.jsonobj = JsonUtils()", 
          "self.verify_oper_object = VerifyOperations()", 
          "self.element_locator_obj = ElementLocator()"
        ], 
        "wdesc": "__init__", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def __init__(self):", 
        "line": 41, 
        "type": "fn", 
        "fn": "__init__"
      }, 
      {
        "comment": [
          "def verify_page_by_property(self, system_name, expected_value, value_type,", 
          "browser_name=\"all\", element_config_file=None,", 
          "element_tag=None):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"The browser will verify page by {0}\".format(value_type)", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if current_browser:", 
          "obtained_value = self.verify_oper_object.get_page_property(current_browser, browser_details[\"value_type\"])", 
          "if str(obtained_value) == expected_value:", 
          "pNote(\"The obtained {0}: {1} matches the expected \"", 
          "\"value: {2}. Verification success!\".", 
          "format(value_type, obtained_value,", 
          "expected_value))", 
          "else:", 
          "pNote(\"The obtained {0}: {1} does not match the \"", 
          "\"expected value: {2}. Verification failed!\".", 
          "format(value_type, obtained_value,", 
          "expected_value), \"Error\")", 
          "status = False", 
          "else:", 
          "pNote(\"Browser of system {0} and name {1} not found in the \"", 
          "\"datarepository\"", 
          ".format(system_name, browser_details[\"browser_name\"]),", 
          "\"Exception\")", 
          "status = False", 
          "browser_details = {}", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status"
        ], 
        "wdesc": "The browser will verify page by {0}\".format(value_type)", 
        "args": [
          "self", 
          "system_name", 
          "expected_value", 
          "value_type", 
          "browser_name=\"all\"", 
          "element_config_file=None", 
          "element_tag=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "expected_value": "", 
          "element_config_file": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "value_type": "", 
          "element_tag": "None"
        }, 
        "def": "def verify_page_by_property(self, system_name, expected_value, value_type,browser_name=\"all\", element_config_file=None,element_tag=None):", 
        "line": 52, 
        "type": "fn", 
        "fn": "verify_page_by_property"
      }, 
      {
        "comment": [
          "def verify_text_in_window_pane(self, system_name,", 
          "verification_text=None,", 
          "browser_name='all',", 
          "element_config_file=None,", 
          "element_tag=None):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "browser_details = {}", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments,", 
          "self.datafile,", 
          "browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None and browser_details[\"verification_text\"] is not None:", 
          "if not browser_details[\"verification_text\"].startswith(\"verification_text\"):", 
          "browser_details[\"verification_text\"] = \\", 
          "\"verification_text=\" + browser_details[\"verification_text\"]", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" +", 
          "browser_details[\"browser_name\"])", 
          "if not current_browser:", 
          "pNote(\"Browser of system {0} and name {1} not found in the \"", 
          "\"data repository\"", 
          ".format(system_name, browser_details[\"browser_name\"]),", 
          "\"Exception\")", 
          "status = False", 
          "else:", 
          "element_located_status = current_browser.page_source", 
          "if element_located_status:", 
          "for values in browser_details[\"verification_text\"].split(\",\"):", 
          "if re.search(\"verification_text=\", values):", 
          "values = re.sub(\"verification_text=\", \"\", values)", 
          "verification_status = self.element_locator_obj.get_element(current_browser, 'xpath=//*[contains(text(),\"{}\")]'.format(values), findall='y')", 
          "if verification_status and len(verification_status) > 0:", 
          "print_info(\"Verification text found {} times in the window pane\".format(len(verification_status)))", 
          "if not verification_status:", 
          "print_error(\"The given string {} is not present in DOM\".format(values))", 
          "status = False", 
          "else:", 
          "print_error(\"Value for browser_details/verification_text is None. Provide the value\")", 
          "status = False", 
          "return status"
        ], 
        "wdesc": "verify_text_in_window_pane", 
        "args": [
          "self", 
          "system_name", 
          "verification_text=None", 
          "browser_name='all'", 
          "element_config_file=None", 
          "element_tag=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "verification_text": "None", 
          "element_config_file": "None", 
          "self": "", 
          "browser_name": "'all'", 
          "element_tag": "None"
        }, 
        "def": "def verify_text_in_window_pane(self, system_name,verification_text=None,browser_name='all',element_config_file=None,element_tag=None):", 
        "line": 200, 
        "type": "fn", 
        "fn": "verify_text_in_window_pane"
      }, 
      {
        "comment": [
          "def verify_alert_is_present(self, system_name, action=\"accept\",", 
          "browser_name=\"all\", element_config_file=None,", 
          "element_tag=None):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"The browser will accept or dismiss the alert\"", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments, self.datafile, browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if current_browser:", 
          "status = self.verify_oper_object.verify_alert_is_present(current_browser, browser_details[\"action\"])", 
          "else:", 
          "pNote(\"Browser of system {0} and name {1} not found in the \"", 
          "\"datarepository\"", 
          ".format(system_name, browser_details[\"browser_name\"]),", 
          "\"Exception\")", 
          "status = False", 
          "browser_details = {}", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status"
        ], 
        "wdesc": "The browser will accept or dismiss the alert", 
        "args": [
          "self", 
          "system_name", 
          "action=\"accept\"", 
          "browser_name=\"all\"", 
          "element_config_file=None", 
          "element_tag=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "element_config_file": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "action": "\"accept\"", 
          "element_tag": "None"
        }, 
        "def": "def verify_alert_is_present(self, system_name, action=\"accept\",browser_name=\"all\", element_config_file=None,element_tag=None):", 
        "line": 345, 
        "type": "fn", 
        "fn": "verify_alert_is_present"
      }
    ], 
    [
      {
        "comment": [
          " Selenium keywords for Wait Actions "
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "wait_actions.py", 
        "line": 1, 
        "type": "package", 
        "fn": "wait_actions"
      }, 
      {
        "comment": [
          "This class has the functionality to wait till an event has happened on", 
          "the webpage - such as the browser will wait till an element is clickable,", 
          "visible, or present on a webpage. Implicit wait can also be set for a", 
          "webpage with this class "
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "wait_actions(object):", 
        "line": 33, 
        "type": "class", 
        "fn": "wait_actions"
      }, 
      {
        "comment": [
          "This is a constructor for the wait_actions class", 
          "self.resultfile = Utils.config_Utils.resultfile", 
          "self.datafile = Utils.config_Utils.datafile", 
          "self.logsdir = Utils.config_Utils.logsdir", 
          "self.filename = Utils.config_Utils.filename", 
          "self.logfile = Utils.config_Utils.logfile", 
          "self.jsonobj = JsonUtils()", 
          "self.wait_oper_object = WaitOperations()", 
          "self.element_locator_obj = ElementLocator()"
        ], 
        "wdesc": "__init__", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def __init__(self):", 
        "line": 39, 
        "type": "fn", 
        "fn": "__init__"
      }, 
      {
        "comment": [
          "def set_implicit_wait(self, system_name, timeout, browser_name=\"all\",", 
          "element_config_file=None, element_tag=None):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"This would permanently set the implicit wait time for \" \\", 
          "\"given browser instance(s)\"", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments,", 
          "self.datafile,", 
          "browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if not current_browser:", 
          "pNote(\"Browser of system {0} and name {1} not found in the \"", 
          "\"datarepository\"", 
          ".format(system_name, browser_details[\"browser_name\"]),", 
          "\"Exception\")", 
          "status = False", 
          "else:", 
          "self.wait_oper_object.\\", 
          "implicit_wait(current_browser,", 
          "browser_details[\"timeout\"])", 
          "browser_details = {}", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status"
        ], 
        "wdesc": "This would permanently set the implicit wait time for \" \\", 
        "args": [
          "self", 
          "system_name", 
          "timeout", 
          "browser_name=\"all\"", 
          "element_config_file=None", 
          "element_tag=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "element_config_file": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "timeout": "", 
          "element_tag": "None"
        }, 
        "def": "def set_implicit_wait(self, system_name, timeout, browser_name=\"all\",element_config_file=None, element_tag=None):", 
        "line": 50, 
        "type": "fn", 
        "fn": "set_implicit_wait"
      }, 
      {
        "comment": [
          "def wait_until_element_is_clickable(self, system_name, timeout=5,", 
          "locator=None, locator_type=None,", 
          "browser_name=\"all\", element_tag=None,", 
          "element_config_file=None):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"Browser would wait until element is clickable\"", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments,", 
          "self.datafile,", 
          "browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if not current_browser:", 
          "pNote(\"Browser of system {0} and name {1} not found in the \"", 
          "\"datarepository\"", 
          ".format(system_name, browser_details[\"browser_name\"]),", 
          "\"Exception\")", 
          "status = False", 
          "else:", 
          "status = self.wait_oper_object.\\", 
          "wait_until_element_is_clickable(current_browser,", 
          "browser_details[\"locator_type\"],", 
          "browser_details[\"locator\"],", 
          "browser_details[\"timeout\"])", 
          "browser_details = {}", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status"
        ], 
        "wdesc": "Browser would wait until element is clickable", 
        "args": [
          "self", 
          "system_name", 
          "timeout=5", 
          "locator=None", 
          "locator_type=None", 
          "browser_name=\"all\"", 
          "element_tag=None", 
          "element_config_file=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "locator_type": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "locator": "None", 
          "timeout": "5", 
          "element_config_file": "None", 
          "element_tag": "None"
        }, 
        "def": "def wait_until_element_is_clickable(self, system_name, timeout=5,locator=None, locator_type=None,browser_name=\"all\", element_tag=None,element_config_file=None):", 
        "line": 172, 
        "type": "fn", 
        "fn": "wait_until_element_is_clickable"
      }, 
      {
        "comment": [
          "def wait_until_presence_of_element_located(self, system_name, timeout=5,", 
          "locator=None, locator_type=None,", 
          "browser_name=\"all\",", 
          "element_tag=None,", 
          "element_config_file=None):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"Browser would wait until presence of element is detected\"", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments,", 
          "self.datafile,", 
          "browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if not current_browser:", 
          "pNote(\"Browser of system {0} and name {1} not found in the \"", 
          "\"datarepository\"", 
          ".format(system_name, browser_details[\"browser_name\"]),", 
          "\"Exception\")", 
          "status = False", 
          "else:", 
          "status = self.wait_oper_object.\\", 
          "wait_until_presence_of_element_located(current_browser,", 
          "browser_details[\"locator_type\"],", 
          "browser_details[\"locator\"],", 
          "browser_details[\"timeout\"])", 
          "browser_details = {}", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status"
        ], 
        "wdesc": "Browser would wait until presence of element is detected", 
        "args": [
          "self", 
          "system_name", 
          "timeout=5", 
          "locator=None", 
          "locator_type=None", 
          "browser_name=\"all\"", 
          "element_tag=None", 
          "element_config_file=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "locator_type": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "locator": "None", 
          "timeout": "5", 
          "element_config_file": "None", 
          "element_tag": "None"
        }, 
        "def": "def wait_until_presence_of_element_located(self, system_name, timeout=5,locator=None, locator_type=None,browser_name=\"all\",element_tag=None,element_config_file=None):", 
        "line": 336, 
        "type": "fn", 
        "fn": "wait_until_presence_of_element_located"
      }, 
      {
        "comment": [
          "def wait_until_presence_of_all_elements_located(self, system_name,", 
          "timeout=5, locator=None,", 
          "locator_type=None,", 
          "browser_name=\"all\",", 
          "element_tag=None,", 
          "element_config_file=None):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"Browser would wait until presence of elements is detected\"", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments,", 
          "self.datafile,", 
          "browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if not current_browser:", 
          "pNote(\"Browser of system {0} and name {1} not found in the \"", 
          "\"datarepository\"", 
          ".format(system_name, browser_details[\"browser_name\"]),", 
          "\"Exception\")", 
          "status = False", 
          "else:", 
          "status = self.wait_oper_object.\\", 
          "wait_until_presence_of_all_elements_located(current_browser,", 
          "browser_details[\"locator_type\"],", 
          "browser_details[\"locator\"],", 
          "browser_details[\"timeout\"])", 
          "browser_details = {}", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status"
        ], 
        "wdesc": "Browser would wait until presence of elements is detected", 
        "args": [
          "self", 
          "system_name", 
          "timeout=5", 
          "locator=None", 
          "locator_type=None", 
          "browser_name=\"all\"", 
          "element_tag=None", 
          "element_config_file=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "locator_type": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "locator": "None", 
          "timeout": "5", 
          "element_config_file": "None", 
          "element_tag": "None"
        }, 
        "def": "def wait_until_presence_of_all_elements_located(self, system_name,timeout=5, locator=None,locator_type=None,browser_name=\"all\",element_tag=None,element_config_file=None):", 
        "line": 500, 
        "type": "fn", 
        "fn": "wait_until_presence_of_all_elements_located"
      }, 
      {
        "comment": [
          "def wait_until_visibility_is_determined(self, system_name, timeout=\"5\",", 
          "locator=None, locator_type=None,", 
          "browser_name=\"all\",", 
          "element_tag=None,", 
          "element_config_file=None):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"Browser would wait until visibility of an element known to \" \\", 
          "\"be present in the DOM is determined\"", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments,", 
          "self.datafile,", 
          "browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if not current_browser:", 
          "pNote(\"Browser of system {0} and name {1} not found in the \"", 
          "\"datarepository\"", 
          ".format(system_name, browser_details[\"browser_name\"]),", 
          "\"Exception\")", 
          "status = False", 
          "else:", 
          "element = Utils.data_Utils.\\", 
          "get_object_from_datarepository(system_name + \"_\" +", 
          "browser_details[\"browser_name\"] + \"_\" +", 
          "browser_details[\"locator_type\"] + \"=\" +", 
          "browser_details[\"locator\"])", 
          "if element:", 
          "status = self.wait_oper_object.\\", 
          "wait_until_visibilty_is_confirmed(current_browser,", 
          "element,", 
          "browser_details[\"timeout\"])", 
          "else:", 
          "element = self.element_locator_obj.\\", 
          "get_element(current_browser,", 
          "browser_details[\"locator_type\"] + \"=\" +", 
          "browser_details[\"locator\"])", 
          "status = self.wait_oper_object.\\", 
          "wait_until_visibilty_is_confirmed(current_browser,", 
          "element,", 
          "browser_details[\"timeout\"])", 
          "browser_details = {}", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status"
        ], 
        "wdesc": "Browser would wait until visibility of an element known to \" \\", 
        "args": [
          "self", 
          "system_name", 
          "timeout=\"5\"", 
          "locator=None", 
          "locator_type=None", 
          "browser_name=\"all\"", 
          "element_tag=None", 
          "element_config_file=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "locator_type": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "locator": "None", 
          "timeout": "\"5\"", 
          "element_config_file": "None", 
          "element_tag": "None"
        }, 
        "def": "def wait_until_visibility_is_determined(self, system_name, timeout=\"5\",locator=None, locator_type=None,browser_name=\"all\",element_tag=None,element_config_file=None):", 
        "line": 665, 
        "type": "fn", 
        "fn": "wait_until_visibility_is_determined"
      }, 
      {
        "comment": [
          "def wait_until_visibility_of_element_located(self, system_name, timeout=\"5\",", 
          "locator=None,", 
          "locator_type=None,", 
          "browser_name=\"all\",", 
          "element_tag=None,", 
          "element_config_file=None):", 
          "", 
          "", 
          "arguments = locals()", 
          "arguments.pop('self')", 
          "status = True", 
          "wdesc = \"Browser would wait until visibility of an element known to \" \\", 
          "\"be is determined\"", 
          "pNote(wdesc)", 
          "pSubStep(wdesc)", 
          "browser_details = {}", 
          "", 
          "system = xml_Utils.getElementWithTagAttribValueMatch(self.datafile,", 
          "\"system\",", 
          "\"name\",", 
          "system_name)", 
          "browser_list = system.findall(\"browser\")", 
          "try:", 
          "browser_list.extend(system.find(\"browsers\").findall(\"browser\"))", 
          "except AttributeError:", 
          "pass", 
          "", 
          "if not browser_list:", 
          "browser_list.append(1)", 
          "browser_details = arguments", 
          "", 
          "for browser in browser_list:", 
          "arguments = Utils.data_Utils.get_default_ecf_and_et(arguments,", 
          "self.datafile,", 
          "browser)", 
          "if browser_details == {}:", 
          "browser_details = selenium_Utils. \\", 
          "get_browser_details(browser, datafile=self.datafile, **arguments)", 
          "if browser_details is not None:", 
          "current_browser = Utils.data_Utils.get_object_from_datarepository(system_name + \"_\" + browser_details[\"browser_name\"])", 
          "if not current_browser:", 
          "pNote(\"Browser of system {0} and name {1} not found in the \"", 
          "\"datarepository\"", 
          ".format(system_name, browser_details[\"browser_name\"]),", 
          "\"Exception\")", 
          "status = False", 
          "else:", 
          "status = self.wait_oper_object.\\", 
          "wait_until_visibility_of_element_located(current_browser,", 
          "browser_details[\"locator_type\"],", 
          "browser_details[\"locator\"],", 
          "browser_details[\"timeout\"])", 
          "browser_details = {}", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "if current_browser:", 
          "selenium_Utils.save_screenshot_onerror(status, current_browser)", 
          "return status"
        ], 
        "wdesc": "Browser would wait until visibility of an element known to \" \\", 
        "args": [
          "self", 
          "system_name", 
          "timeout=\"5\"", 
          "locator=None", 
          "locator_type=None", 
          "browser_name=\"all\"", 
          "element_tag=None", 
          "element_config_file=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "locator_type": "None", 
          "self": "", 
          "browser_name": "\"all\"", 
          "locator": "None", 
          "timeout": "\"5\"", 
          "element_config_file": "None", 
          "element_tag": "None"
        }, 
        "def": "def wait_until_visibility_of_element_located(self, system_name, timeout=\"5\",locator=None,locator_type=None,browser_name=\"all\",element_tag=None,element_config_file=None):", 
        "line": 845, 
        "type": "fn", 
        "fn": "wait_until_visibility_of_element_located"
      }
    ]
  ], 
  "common_driver": [
    [
      {
        "comment": [
          "common_actions module where keywords common to all products are developed"
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "common_actions.py", 
        "line": 1, 
        "type": "package", 
        "fn": "common_actions"
      }, 
      {
        "comment": [
          "class CommonActions having methods (keywords) that are common for all the products"
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "CommonActions(object):", 
        "line": 25, 
        "type": "class", 
        "fn": "CommonActions"
      }, 
      {
        "comment": [
          "def __init__(self):", 
          "self.resultfile = Utils.config_Utils.resultfile", 
          "self.datafile = Utils.config_Utils.datafile", 
          "self.logsdir = Utils.config_Utils.logsdir", 
          "self.filename = Utils.config_Utils.filename", 
          "self.logfile = Utils.config_Utils.logfile"
        ], 
        "wdesc": "__init__", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def __init__(self):", 
        "line": 28, 
        "type": "fn", 
        "fn": "__init__"
      }, 
      {
        "comment": [
          "def wait_for_timeout(self, timeout):", 
          "waits (sleeps) for the time provided", 
          "", 
          ":Arguments:", 
          "1. resultfile(string) = full path to the result file", 
          "2. step_num(string) = step_num in string", 
          "3. timeout= time to wait in seconds", 
          "", 
          ":Returns:", 
          "1. status (bool)"
        ], 
        "wdesc": "Waits for the timeout provided", 
        "args": [
          "self", 
          "timeout"
        ], 
        "argsmap": {
          "self": "", 
          "timeout": ""
        }, 
        "def": "def wait_for_timeout(self, timeout):", 
        "line": 35, 
        "type": "fn", 
        "fn": "wait_for_timeout"
      }, 
      {
        "comment": [
          "Finds the system name in the datafile and returns the system type", 
          ":Arguments:", 
          "1. system_name = system name in the datafile", 
          ":Returns:", 
          "1. status (boolean)", 
          "2. system_type (dict element): name=system_type, value=type of the system_name (string)."
        ], 
        "wdesc": "Find the system type from datafile", 
        "args": [
          "self", 
          "system_name"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": ""
        }, 
        "def": "def get_system_type(self, system_name):", 
        "line": 59, 
        "type": "fn", 
        "fn": "get_system_type"
      }, 
      {
        "comment": [
          "Verify 'resp_pat' exist in the data repository", 
          ":Argument:", 
          "resp_ref = response reference tag in testdatafile", 
          "resp_pat = response pattern to be check in testdatafile", 
          "object_key = the object key name in the data repository", 
          "Ex: cli send by title, object_key=<title name>", 
          "cli send by tiele_rownum, object key=<tilte_name><row_name>", 
          ":Returns:", 
          "status (boolean)"
        ], 
        "wdesc": "verify_resp_data", 
        "args": [
          "self", 
          "resp_ref", 
          "resp_pat", 
          "object_key"
        ], 
        "argsmap": {
          "resp_ref": "", 
          "resp_pat": "", 
          "self": "", 
          "object_key": ""
        }, 
        "def": "def verify_resp_data(self, resp_ref, resp_pat, object_key):", 
        "line": 87, 
        "type": "fn", 
        "fn": "verify_resp_data"
      }, 
      {
        "comment": [
          "For storing datavalue in datavar datarepository", 
          ":Argument:", 
          "datavar = var in data repository in which to store", 
          "this could be dot separated to store in nested fashion", 
          "i.e., if var is k1.k2.k3 then the data value would be", 
          "stored as a value in datarepository[k1][k2][k3]", 
          "datavalue = the value to be stored", 
          "type = type of datavalue (string/int/float)"
        ], 
        "wdesc": "store_in_repo", 
        "args": [
          "self", 
          "datavar", 
          "datavalue", 
          "type='str'"
        ], 
        "argsmap": {
          "type": "'str'", 
          "self": "", 
          "datavar": "", 
          "datavalue": ""
        }, 
        "def": "def store_in_repo(self, datavar, datavalue, type='str'):", 
        "line": 114, 
        "type": "fn", 
        "fn": "store_in_repo"
      }, 
      {
        "comment": [], 
        "wdesc": "get_dict_to_update", 
        "args": [
          "var", 
          "val"
        ], 
        "argsmap": {
          "var": "", 
          "val": ""
        }, 
        "def": "def get_dict_to_update(var, val):", 
        "line": 124, 
        "type": "fn", 
        "fn": "get_dict_to_update"
      }, 
      {
        "comment": [
          "Verify value in 'object_key' in the data repository matches", 
          "with expected", 
          ":Argument:", 
          "expected = the value to be compared with", 
          "object_key = the object in the data repository to be compared", 
          "type = the type of this expected (str/int/float)", 
          "comparison = actual comparison (eq/ne/gt/ge/lt/le)", 
          "eq - check if both are same(equal)", 
          "ne - check if both are not same(not equal)", 
          "gt - check if object_key is greater than expected", 
          "ge - check if object_key is greater than or equal to expected", 
          "lt - check if object_key is lesser than expected", 
          "le - check if object_key is lesser than or equal to expected", 
          ":Returns:", 
          "status (boolean)"
        ], 
        "wdesc": "verify_data", 
        "args": [
          "self", 
          "expected", 
          "object_key", 
          "type='str'", 
          "comparison='eq'"
        ], 
        "argsmap": {
          "expected": "", 
          "comparison": "'eq'", 
          "self": "", 
          "type": "'str'", 
          "object_key": ""
        }, 
        "def": "def verify_data(self, expected, object_key, type='str', comparison='eq'):", 
        "line": 142, 
        "type": "fn", 
        "fn": "verify_data"
      }, 
      {
        "comment": [
          "create a temp environment variable", 
          "the value will only stay for this run", 
          ":Argument:", 
          "var_key = key of the environment variable", 
          "var_value = value of the environment variable", 
          "filepath = Json file where Environmental variables are defined", 
          "jsonkey = The key where all the ENV variable & values are defined", 
          "With jsonkey arg, Users can call same file to set various ENV Variable", 
          "", 
          "Variable File :", 
          "Sample environmental_variable file is available under", 
          "Warriorspace/Config_file/Samples/Set_ENV_Variable_Sample.json"
        ], 
        "wdesc": "set_env_var", 
        "args": [
          "self", 
          "var_key=None", 
          "var_value=None", 
          "filepath=None", 
          "jsonkey=\"environmental_variables\""
        ], 
        "argsmap": {
          "var_value": "None", 
          "jsonkey": "\"environmental_variables\"", 
          "self": "", 
          "var_key": "None", 
          "filepath": "None"
        }, 
        "def": "def set_env_var(self, var_key=None, var_value=None, filepath=None,jsonkey=\"environmental_variables\"):", 
        "line": 173, 
        "type": "fn", 
        "fn": "set_env_var"
      }
    ]
  ], 
  "server_driver": [
    [
      {
        "comment": [
          "import Framework.Utils as Utils", 
          "from Framework.ClassUtils.rest_server_class import RestServer", 
          "# Written by Sourav", 
          "# from Framework.Utils import rest_server", 
          "# from Framework.Utils.rest_server import b_start_server, b_stop_server, \\", 
          "#     b_create_route, b_get_request, b_get_response"
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "server_actions.py", 
        "line": 1, 
        "type": "package", 
        "fn": "server_actions"
      }, 
      {
        "comment": [
          "class ServerActions(object):"
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "ServerActions(object):", 
        "line": 24, 
        "type": "class", 
        "fn": "ServerActions"
      }, 
      {
        "comment": [
          "def __init__(self):", 
          "self.resultfile = Utils.config_Utils.resultfile", 
          "self.datafile = Utils.config_Utils.datafile", 
          "self.logsdir = Utils.config_Utils.logsdir", 
          "self.filename = Utils.config_Utils.filename", 
          "self.logfile = Utils.config_Utils.logfile", 
          "# self.users = [{\"user\": \"admin\", \"password\": \"admin\", \"auth_header\":", 
          "# 'Basic ' + base64.b64encode('admin:admin')}]", 
          "# self.jsonobj = JsonUtils()"
        ], 
        "wdesc": "__init__", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def __init__(self):", 
        "line": 28, 
        "type": "fn", 
        "fn": "__init__"
      }, 
      {
        "comment": [
          "def start_server(self, system_name):", 
          "", 
          "", 
          "wdesc = \"Starting Bottle web socket server.\"", 
          "Utils.testcase_Utils.pSubStep(wdesc)", 
          "rest_server = RestServer()", 
          "status, server_dict = rest_server.build_server(self.datafile, system_name)", 
          "if status:", 
          "output_dict = {\"{}_server_controller\".format(system_name): server_dict[\"server\"],", 
          "\"{}_server_thread\".format(system_name): server_dict[\"server_thread\"],", 
          "\"{}_server_object\".format(system_name): rest_server}", 
          "return status, output_dict", 
          "return status"
        ], 
        "wdesc": "Starting Bottle web socket server.", 
        "args": [
          "self", 
          "system_name"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": ""
        }, 
        "def": "def start_server(self, system_name):", 
        "line": 38, 
        "type": "fn", 
        "fn": "start_server"
      }, 
      {
        "comment": [
          "def stop_server(self, system_name):", 
          "", 
          "", 
          "wdesc = \"Closing Bottle web socket server.\"", 
          "Utils.testcase_Utils.pSubStep(wdesc)", 
          "server_controller = Utils.data_Utils.get_object_from_datarepository(\"{}_server_controller\".format(system_name))", 
          "server_controller.stop()", 
          "server_thread = Utils.data_Utils.get_object_from_datarepository(\"{}_server_thread\".format(system_name))", 
          "", 
          "if server_thread.is_alive():", 
          "print \"Server doesn't shutdown correctly\"", 
          "return False", 
          "else:", 
          "return True", 
          "", 
          "", 
          "", 
          "", 
          "# def initilize_route(self, system_name, route_param):", 
          "#     "
        ], 
        "wdesc": "Closing Bottle web socket server.", 
        "args": [
          "self", 
          "system_name"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": ""
        }, 
        "def": "def stop_server(self, system_name):", 
        "line": 55, 
        "type": "fn", 
        "fn": "stop_server"
      }
    ]
  ], 
  "network_driver": [
    [
      {
        "comment": [
          " Keywords related to Network Diagnostics operations "
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "diagnostics_actions.py", 
        "line": 1, 
        "type": "package", 
        "fn": "diagnostics_actions"
      }, 
      {
        "comment": [
          "Diagnostics keyword class "
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "DiagActions(object):", 
        "line": 17, 
        "type": "class", 
        "fn": "DiagActions"
      }, 
      {
        "comment": [
          "def __init__(self):", 
          " Constructor "
        ], 
        "wdesc": "__init__", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def __init__(self):", 
        "line": 20, 
        "type": "fn", 
        "fn": "__init__"
      }, 
      {
        "comment": [
          "This keyword will use connection session available in source system", 
          "(provided in system name) and will ping from source system", 
          "to destination system", 
          "", 
          ":Datafile usuage:", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem.If both tag and attribute is provided the attribute", 
          "will be used.", 
          "1. prompt   = prompt of the source system", 
          "2. ip       = ipv4 address or defaulted to lcn ip", 
          "3. ipv6     = ipv6 address or defaulted to lcn ipv6", 
          "4. dns      = dns name", 
          "5. lmp_ip   = ipv4 address of lmp port of dut", 
          "6. lmp_ipv6 = ipv6 address of lmp port of dut", 
          "note: one of <ip>,<ipv6>,<dns>,<lmp_ip>,<lmp_ipv6> tags specified in", 
          "ip_type argument is sufficient to be present in inputdatafile", 
          "", 
          ":Arguments:", 
          "1. system_name(string)  = name of the Linux machine on which to \\", 
          "execute", 
          "2. session_name(string) = name of the session", 
          "3. dest_system(string) = names of the destination system", 
          "4. ip_type(string) = iptype of the dest system through \\", 
          "which it needs to be connected.", 
          "needs to be one of \\", 
          "(ip/ipv4/dns/lmp_ip/lmp_ipv6).It has to be \\", 
          "present in the input data file.", 
          "5. count(string) = count argument to be supplied to the ping", 
          "", 
          ":Returns:", 
          "1. bool (True/False)"
        ], 
        "wdesc": "ping  to destination system", 
        "args": [
          "self", 
          "system_name", 
          "session_name=None", 
          "dest_system=None", 
          "ip_type=\"ip\"", 
          "count=\"5\""
        ], 
        "argsmap": {
          "system_name": "", 
          "count": "\"5\"", 
          "self": "", 
          "ip_type": "\"ip\"", 
          "session_name": "None", 
          "dest_system": "None"
        }, 
        "def": "def ping_from_remotehost(self, system_name, session_name=None,dest_system=None, ip_type=\"ip\", count=\"5\"):", 
        "line": 29, 
        "type": "fn", 
        "fn": "ping_from_remotehost"
      }, 
      {
        "comment": [
          "This keyword will use connection session available in source system", 
          "(provided in system name) and  will execute traceroute", 
          "from source system to destination system", 
          "", 
          ":Datafile usuage:", 
          "Tags or attributes to be used in input datafile for the system or", 
          "subsystem.If both tag and attribute is provided the attribute will", 
          "be used.", 
          "1. prompt   = prompt of the source system", 
          "2. ip       = ipv4 address or defaulted to lcn ip", 
          "3. ipv6     = ipv6 address or defaulted to lcn ipv6", 
          "4. dns      = dns name", 
          "5. lmp_ip   = ipv4 address of lmp port of dut", 
          "6. lmp_ipv6 = ipv6 address of lmp port of dut", 
          "note: one of <ip>,<ipv6>,<dns>,<lmp_ip>,<lmp_ipv6> tags specified in", 
          "ip_type argument is sufficient to be present in inputdatafile", 
          "", 
          ":Arguments:", 
          "1. system_name(string) = name of the Linux machine on which to \\", 
          "execute", 
          "2. session_name(string) = name of the session", 
          "3. dest_system(string) = names of the destination system", 
          "4. ip_type(string) = iptype of the dest system through \\", 
          "which it needs to be connected.", 
          "needs to be one of \\", 
          "(ip/ipv4/dns/lmp_ip/lmp_ipv6).It has to be \\", 
          "present in the input data file.", 
          "", 
          ":Returns:", 
          "1. bool (True/False)"
        ], 
        "wdesc": "traceroute to dest system", 
        "args": [
          "self", 
          "system_name", 
          "session_name=None", 
          "dest_system=None", 
          "ip_type=\"ip\""
        ], 
        "argsmap": {
          "system_name": "", 
          "ip_type": "\"ip\"", 
          "self": "", 
          "dest_system": "None", 
          "session_name": "None"
        }, 
        "def": "def traceroute_from_remotehost(self, system_name, session_name=None,dest_system=None, ip_type=\"ip\"):", 
        "line": 91, 
        "type": "fn", 
        "fn": "traceroute_from_remotehost"
      }
    ], 
    [
      {
        "comment": [
          " Keywords related to File operations "
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "file_ops_actions.py", 
        "line": 1, 
        "type": "package", 
        "fn": "file_ops_actions"
      }, 
      {
        "comment": [
          "File operations keyword class "
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "FileOpsActions(object):", 
        "line": 17, 
        "type": "class", 
        "fn": "FileOpsActions"
      }, 
      {
        "comment": [
          "def __init__(self):", 
          " Constructor "
        ], 
        "wdesc": "__init__", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def __init__(self):", 
        "line": 20, 
        "type": "fn", 
        "fn": "__init__"
      }, 
      {
        "comment": [
          "ftp(test both put and get).This keyword can be used to transfer", 
          "file from source _system to destination system or vice versa.", 
          "It checks the size after transfer in both get and put.", 
          "", 
          ":Datafile usage:", 
          "Tags or attributes to be used in input datafile for the system", 
          "or subsystem.If both tag and attribute is provided the attribute", 
          "will be used.", 
          "", 
          "1. prompt = prompt of the source system", 
          "2. filepath = file with filepath in source system(used for put)", 
          "3. ip = ipv4 address or defaulted to lcn ip", 
          "4. ipv6 = ipv6 address or defaulted to lcn ipv6", 
          "5. dns = dns name", 
          "6. lmp_ip = ipv4 address of lmp port of dut", 
          "7. lmp_ipv6 = ipv6 address of lmp port of dut", 
          "8. username = username of the dest system", 
          "9. password = password of the dest system", 
          "10. filepath = file with filepath in destination system \\", 
          "(used for get)", 
          "note: one of <ip>,<ipv6>,<dns>,<lmp_ip>,<lmp_ipv6> tags specified in", 
          "ip_type argument is sufficient to be present in inputdatafile", 
          "", 
          ":Arguments:", 
          "1. system_name(string)  = name of the Linux machine on which\\", 
          "to execute", 
          "2. session_name(string) = name of the session", 
          "3. dest_system(string) = names of the destination system", 
          "4. ftp_operation(string) = get/put/both", 
          "6. ip_type(string) = iptype of the dest system through \\", 
          "which it needs to be connected.", 
          "needs to be one of \\", 
          "(ip/ipv4/dns/lmp_ip/lmp_ipv6).It has to be \\", 
          "present in the input data file.", 
          "", 
          ":Returns:", 
          "1. bool (True/False)"
        ], 
        "wdesc": "ftp file from and to dest_system", 
        "args": [
          "self", 
          "system_name", 
          "session_name=None", 
          "dest_system=None", 
          "ftp_operation=\"both\"", 
          "ip_type=\"ip\""
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "ftp_operation": "\"both\"", 
          "ip_type": "\"ip\"", 
          "session_name": "None", 
          "dest_system": "None"
        }, 
        "def": "def ftp_from_remotehost(self, system_name, session_name=None,dest_system=None, ftp_operation=\"both\",ip_type=\"ip\"):", 
        "line": 29, 
        "type": "fn", 
        "fn": "ftp_from_remotehost"
      }, 
      {
        "comment": [
          "sftp(test both put and get).This keyword can be used to transfer", 
          "file from source _system to destination system or vice versa.", 
          "It checks the size after transfer in both get and put.", 
          "", 
          ":Datafile usage:", 
          "Tags or attributes to be used in input datafile for the system", 
          "or subsystem.If both tag and attribute is provided the attribute", 
          "will be used.", 
          "", 
          "1. prompt = prompt of the source system", 
          "2. filepath = file with filepath in source system(used for put)", 
          "3. ip = ipv4 address or defaulted to lcn ip", 
          "4. ipv6 = ipv6 address or defaulted to lcn ipv6", 
          "5. dns = dns name", 
          "6. lmp_ip = ipv4 address of lmp port of dut", 
          "7. lmp_ipv6 = ipv6 address of lmp port of dut", 
          "8. username = username of the dest system", 
          "9. password = password of the dest system", 
          "10. filepath = file with filepath in destination system(used for get)", 
          "note: one of <ip>,<ipv6>,<dns>,<lmp_ip>,<lmp_ipv6> tags specified in", 
          "ip_type argument is sufficient to be present in inputdatafile", 
          "", 
          ":Arguments:", 
          "1. system_name(string)  = name of the Linux machine on which\\", 
          "to execute", 
          "2. session_name(string) = name of the session", 
          "3. dest_system(string) = names of the destination system", 
          "4. ftp_operation(string) = get/put/both", 
          "5. ip_type(string) = iptype of the dest system through \\", 
          "which it needs to be connected.", 
          "needs to be one of \\", 
          "(ip/ipv4/dns/lmp_ip/lmp_ipv6).It has to be \\", 
          "present in the input data file.", 
          "", 
          ":Returns:", 
          "1. bool (True/False)"
        ], 
        "wdesc": "sftp file from and to dest_system", 
        "args": [
          "self", 
          "system_name", 
          "session_name=None", 
          "dest_system=None", 
          "sftp_operation=\"both\"", 
          "port=\"1022\"", 
          "ip_type=\"ip\""
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "sftp_operation": "\"both\"", 
          "ip_type": "\"ip\"", 
          "session_name": "None", 
          "dest_system": "None", 
          "port": "\"1022\""
        }, 
        "def": "def sftp_from_remotehost(self, system_name, session_name=None,dest_system=None, sftp_operation=\"both\",port=\"1022\", ip_type=\"ip\"):", 
        "line": 107, 
        "type": "fn", 
        "fn": "sftp_from_remotehost"
      }
    ]
  ], 
  "netconf_driver": [
    [
      {
        "comment": [
          "This is the netconf_actions module that has all netconf related keywords", 
          "ymizugaki 2016/01/15", 
          "original = netconf_Actions.py"
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "netconf_Actions.py", 
        "line": 1, 
        "type": "package", 
        "fn": "netconf_Actions"
      }, 
      {
        "comment": [
          "NetconfActions class which has methods(keywords)", 
          "related to actions performed on basic netconf interface "
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "NetconfActions(object):", 
        "line": 24, 
        "type": "class", 
        "fn": "NetconfActions"
      }, 
      {
        "comment": [], 
        "wdesc": "__init__", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def __init__(self):", 
        "line": 28, 
        "type": "fn", 
        "fn": "__init__"
      }, 
      {
        "comment": [
          " Request operations through Netconf interface.", 
          "If value for 'request' is provided, it will be used for request", 
          "operations else the XML input will be taken from the netconf_data", 
          "file based on xmlns, request_type, xmlns_tag values.", 
          ":Arguments:", 
          "1. system_name(string) = Name of the system from the input datafile", 
          "2. session_name(string) = Name of the session to the system", 
          "3. request(string) = command to be sent as xml string", 
          "4. xmlns(string) = XML namespace of the particular request", 
          "5. Request_type(string) = The operation that we want to perform", 
          "6. xmlns_tag(string) = xml tag for the particular request", 
          "for eg:", 
          "For request Type:", 
          "<init-pm xmlns=\"urn:params:xml:ns:yang:perfmon\">", 
          "usage:", 
          "xmlns_tag = xmlns(default value, no need pass this argument)", 
          "xmlns = \"urn:params:xml:ns:yang:perfmon\"", 
          "request_type= \"init-pm\"", 
          "", 
          "For Request Type :", 
          "<org-openroadm-de-operations:restart xmlns:", 
          "org-openroadm-de-operations=\"http://org/openroadm/de/operations\">", 
          "usage:", 
          "xmlns_tag = \"xmlns:org-openroadm-de-operations\"", 
          "xmlns = \"http://org/openroadm/de/operations\"", 
          "request_type = \"org-openroadm-de-operations:restart\"", 
          ":Returns:", 
          "1. status = True/False/error", 
          "2. RPC replies in a list & it will be updated in the data", 
          "repository in key - [system_name]_request_rpc_reply."
        ], 
        "wdesc": "Request particular operation from the system", 
        "args": [
          "self", 
          "system_name", 
          "session_name=None", 
          "request=\"\"", 
          "xmlns=\"\"", 
          "request_type=\"\"", 
          "xmlns_tag=\"xmlns\""
        ], 
        "argsmap": {
          "system_name": "", 
          "xmlns": "\"\"", 
          "xmlns_tag": "\"xmlns\"", 
          "self": "", 
          "request": "\"\"", 
          "request_type": "\"\"", 
          "session_name": "None"
        }, 
        "def": "def request_rpc(self, system_name, session_name=None, request=\"\",xmlns=\"\", request_type=\"\", xmlns_tag=\"xmlns\"):", 
        "line": 36, 
        "type": "fn", 
        "fn": "request_rpc"
      }, 
      {
        "comment": [
          "Connects to the Netconf interface of the the given system or subsystems", 
          "", 
          ":Datafile usage:", 
          "", 
          "Tags or attributes to be used in input datafile for the system or subsystem", 
          "If both tag and attribute is provided the attribute will be used.", 
          "1. ip = IP address of the system/subsystem", 
          "2. username = username for the ssh session", 
          "3. password = password for the ssh session", 
          "4. timeout = use if you want to set timeout while connecting", 
          "5. ncport = use this tag to provide ssh port to connect to Netconf \\", 
          "interface, if not provided default port 830 will be used.", 
          "6. hostkey_verify = enables hostkey verification from ~/.ssh/known_hosts,\\", 
          "if not provided the default value is to look into the path ~/.ssh/known_hosts.", 
          "7. allow_agent = enables querying SSH agent, if not provided the \\", 
          "default value is to allow.", 
          "8. look_for_keys = enables looking in the usual locations for ssh keys,\\", 
          "if value is not provided the default value is to look for keys.", 
          "9. unknown_host_cb = This would be used when the server host key is not \\", 
          "recognized.", 
          "10. key_filename = where the private key can be found.", 
          "11. ssh_config = Enables parsing of OpenSSH configuration file.", 
          "12. device_params = netconf client device name, by default the name \\", 
          "\"default\" is used.", 
          "", 
          ":Arguments:", 
          "1. system_name(string) = Name of the system from the input datafile.", 
          "2. session_name(string) = Name of the session to the system", 
          "", 
          ":Returns:", 
          "1. status(bool)= True / False", 
          "2. session_id (dict element)= key, value", 
          "", 
          "", 
          "", 
          "", 
          ":DESCRIPTION:", 
          "This Keyword is used to connect to the netconf interface of the system.", 
          "The keyword upon executing saves the System_name and Session_id,\\", 
          "which can be used by all subsequet keywords in the test", 
          "to interact with the system through netconf interface."
        ], 
        "wdesc": "Connect to the netconf port of the system and creates a session", 
        "args": [
          "self", 
          "system_name", 
          "session_name=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "session_name": "None"
        }, 
        "def": "def connect_netconf(self, system_name, session_name=None):", 
        "line": 127, 
        "type": "fn", 
        "fn": "connect_netconf"
      }, 
      {
        "comment": [
          "Request graceful termination of netconf session.", 
          ":Arguments:", 
          "1. system_name(string)  = Name of the system in the input datafile", 
          "2. session_name(string) = Name of the session to the system", 
          ":Returns:", 
          "1. status(bool)= True / False", 
          "2. Close response from the system to the data repository (data:reply.data(string)}"
        ], 
        "wdesc": "Request graceful termination of Netconf session", 
        "args": [
          "self", 
          "system_name", 
          "session_name=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "session_name": "None"
        }, 
        "def": "def close_netconf(self, system_name, session_name=None):", 
        "line": 191, 
        "type": "fn", 
        "fn": "close_netconf"
      }, 
      {
        "comment": [
          " Retrieve all or part of a specified configuration through Netconf interface.", 
          ":Arguments:", 
          "1. datastore(string) = Name of the netconf datastore.", 
          "2. system_name(string)  = Name of the system from the input datafile.", 
          "3. session_name(string) = Name of the session to the system.", 
          "4. filter_string(string) = xml string, by default entire configuration is \\", 
          "retrieved.", 
          "5. filter_type(string) = Type of the Filter , default is subtree of xpath.", 
          ":Returns:", 
          "1. status(bool)= True / False", 
          "2. Get Response in the data repository {data:reply(xml)}"
        ], 
        "wdesc": "Get system configuration data from the provided system", 
        "args": [
          "self", 
          "datastore", 
          "system_name", 
          "session_name=None", 
          "filter_string=None", 
          "filter_type=\"subtree\""
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "filter_type": "\"subtree\"", 
          "datastore": "", 
          "filter_string": "None", 
          "session_name": "None"
        }, 
        "def": "def get_config(self, datastore, system_name,session_name=None,filter_string=None,filter_type=\"subtree\"):", 
        "line": 221, 
        "type": "fn", 
        "fn": "get_config"
      }, 
      {
        "comment": [
          "Create or replace an entire configuration datastore", 
          "with the contents of another complete configuation datastore", 
          ":Arguments:", 
          "1. source(string) = name of the configuration datastore to use as the source of", 
          "the copy operation or config element containing the configuration subtree to copy.", 
          "2. target(string) = name of the configuration datastore to use as the destination", 
          "of the copy operation", 
          "3. system_name(string)  = Name of the system from the input datafile", 
          "4. session_name(string) = Name of the session to the system", 
          ":Returns:", 
          "1. status(bool)= True / False", 
          "2. Copy Response in the data repository {data:reply(xml)}"
        ], 
        "wdesc": "Create or replace an entire configuration datastore with another datastore", 
        "args": [
          "self", 
          "source", 
          "target", 
          "system_name", 
          "session_name=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "source": "", 
          "self": "", 
          "target": "", 
          "session_name": "None"
        }, 
        "def": "def copy_config(self, source, target, system_name, session_name=None):", 
        "line": 258, 
        "type": "fn", 
        "fn": "copy_config"
      }, 
      {
        "comment": [
          "Delete a configuration datastore", 
          "", 
          ":Arguments:", 
          "1. datastore(string) = name of the configuration datastore to be deleted", 
          "2. system_name(string)  = Name of the system from the input datafile", 
          "3. session_name(string) = Name of the session to the system", 
          ":Returns:", 
          "1. status(bool)= True / False", 
          "2. Delete Response in the data repository {data:reply(xml)}"
        ], 
        "wdesc": "Delete system configuration data from the provided system", 
        "args": [
          "self", 
          "datastore", 
          "system_name", 
          "session_name=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "datastore": "", 
          "session_name": "None"
        }, 
        "def": "def delete_config(self, datastore, system_name, session_name=None):", 
        "line": 291, 
        "type": "fn", 
        "fn": "delete_config"
      }, 
      {
        "comment": [
          "Revert the candidate configuration to the currently running configuration.", 
          "Uncommitted changes will be discarded.", 
          "", 
          ":Arguments:", 
          "1. system_name(string)  = Name of the system from the input datafile", 
          "2. session_name(string) = Name of the session to the system", 
          ":Returns:", 
          "1. status(bool)= True / False", 
          "2. Discard Response in the data repository {data:reply(xml)}"
        ], 
        "wdesc": "Discard any uncommitted changes to the candidate configuration", 
        "args": [
          "self", 
          "system_name", 
          "session_name=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "session_name": "None"
        }, 
        "def": "def discard_changes(self, system_name, session_name=None):", 
        "line": 319, 
        "type": "fn", 
        "fn": "discard_changes"
      }, 
      {
        "comment": [
          " Loads all or part of the specified config(from file) to the datastore", 
          ":Arguments:", 
          "1. datastore(string) = Name of datastore being edited", 
          "2. config(string) = The configuration.", 
          "Must be rooted in the config element. May be a string or Element", 
          "3. system_name(string)  = Name of the system from the input datafile", 
          "4. session_name(string) = Name of the session to the system", 
          "5. default_operation(string) = [merge | replace | none (default)]", 
          "6. test_option(string) = [test_then_set | set | test-only | none (default)]", 
          "7. error_option(string) =", 
          "[stop-on-error | continue-on-error | rollback-on-error | none (default)]", 
          "rollback-on-error depends on :rollback-on-error capability", 
          ":Returns:", 
          "1. status(bool)= True / False", 
          "2. Edit Responses in the data repository {data:reply(xml)}"
        ], 
        "wdesc": "Edit system configuration data", 
        "args": [
          "self", 
          "datastore", 
          "config", 
          "system_name", 
          "session_name=None", 
          "default_operation=None", 
          "test_option=None", 
          "error_option=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "test_option": "None", 
          "error_option": "None", 
          "default_operation": "None", 
          "datastore": "", 
          "config": "", 
          "session_name": "None"
        }, 
        "def": "def edit_config(self, datastore, config, system_name,session_name=None, default_operation=None, test_option=None, error_option=None):", 
        "line": 347, 
        "type": "fn", 
        "fn": "edit_config"
      }, 
      {
        "comment": [
          "Commit the candidate datastore as the device's new current configuration", 
          ":Arguments:", 
          "1. system_name(string)  = Name of the system from the input datafile", 
          "2. confirmed(bool) = Commit is reverted if there is no followup commit", 
          "within the timeout interval.", 
          "3. timeout(int seconds) = The confirm timeout (Default=600 seconds)", 
          "4. persist(string) = persist-id", 
          "5. persist_id(string) = persist-id which specified in previous confirmed commit", 
          "6. session_name(string) = Name of the session to the system", 
          ":Returns:", 
          "1. status(bool)= True / False", 
          "2. Commit Response in the data repository {data:reply(xml)}"
        ], 
        "wdesc": "Commit the candidate datastore", 
        "args": [
          "self", 
          "system_name", 
          "confirmed=False", 
          "timeout=None", 
          "persist=None", 
          "persist_id=None", 
          "session_name=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "persist_id": "None", 
          "self": "", 
          "confirmed": "False", 
          "timeout": "None", 
          "persist": "None", 
          "session_name": "None"
        }, 
        "def": "def commit(self, system_name,confirmed=False, timeout=None, persist=None, persist_id=None, session_name=None):", 
        "line": 410, 
        "type": "fn", 
        "fn": "commit"
      }, 
      {
        "comment": [
          "Lock the configuration system", 
          "", 
          ":Arguments:", 
          "1. datastore(string) = name of the configuration datastore to be locked", 
          "2. system_name(string)  = Name of the system from the input datafile", 
          "3. session_name(string) = Name of the session to the system", 
          ":Returns:", 
          "1. status(bool)= True / False", 
          "2. Lock Response in the data repository {data:reply(xml)}"
        ], 
        "wdesc": "Lock the configuration datastore", 
        "args": [
          "self", 
          "datastore", 
          "system_name", 
          "session_name=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "datastore": "", 
          "session_name": "None"
        }, 
        "def": "def lock(self, datastore, system_name, session_name=None):", 
        "line": 443, 
        "type": "fn", 
        "fn": "lock"
      }, 
      {
        "comment": [
          "Release the configuration lock", 
          "", 
          ":Arguments:", 
          "1. datastore(string) = name of the configuration datastore to be unlocked", 
          "2. system_name(string)  = Name of the system from the input datafile", 
          "3. session_name(string) = Name of the session to the system", 
          ":Returns:", 
          "1. status(bool)= True / False", 
          "2. Unlock Response in the data repository {data:reply(xml)}"
        ], 
        "wdesc": "Unlock the configuration datastore", 
        "args": [
          "self", 
          "datastore", 
          "system_name", 
          "session_name=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "datastore": "", 
          "session_name": "None"
        }, 
        "def": "def unlock(self, datastore, system_name, session_name=None):", 
        "line": 472, 
        "type": "fn", 
        "fn": "unlock"
      }, 
      {
        "comment": [
          "Retrieve operational state information.", 
          "", 
          ":Arguments:", 
          "1. system_name(string)  = Name of the system from the input datafile", 
          "2. session_name(string) = Name of the session to the system", 
          "3. filter_string(string) = specifies the portion of the state information to retrieve", 
          "(by default entire state information is retrieved)", 
          "4. filter_type(string) = subtree or xpath", 
          ":Returns:", 
          "1. status(bool)= True / False", 
          "2. Retrieve Response in the data repository {data:reply(xml)}"
        ], 
        "wdesc": "Retrieve operational state information (get rpc).", 
        "args": [
          "self", 
          "system_name", 
          "session_name=None", 
          "filter_string=None", 
          "filter_type=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "filter_string": "None", 
          "session_name": "None", 
          "filter_type": "None"
        }, 
        "def": "def get(self, system_name, session_name=None, filter_string=None, filter_type=None):", 
        "line": 501, 
        "type": "fn", 
        "fn": "get"
      }, 
      {
        "comment": [
          "Force the termination of a NETCONF session (not the current one!)", 
          ":Arguments:", 
          "1. system_name(string)  = Name of the system from the input datafile", 
          "2. netconf_session_id(string) = session-id of netconf", 
          "3. session_name(string) = Name of the session to the system", 
          ":Returns:", 
          "1. status(bool)= True / False", 
          "2. Kill Response in the data repository {data:reply(xml)}"
        ], 
        "wdesc": "Force the termination of a NETCONF session (not the current one!)", 
        "args": [
          "self", 
          "system_name", 
          "netconf_session_id=None", 
          "session_name=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "netconf_session_id": "None", 
          "session_name": "None"
        }, 
        "def": "def kill_session(self, system_name, netconf_session_id=None, session_name=None):", 
        "line": 531, 
        "type": "fn", 
        "fn": "kill_session"
      }, 
      {
        "comment": [
          "\"Validate the contents of the specified configuration.", 
          ":Arguments:", 
          "1. datastore(string) = Name of the configuration datastore to be validated", 
          "2. system_name(string)  = Name of the system from the input datafile", 
          "3. session_name(string) = Name of the session to the system", 
          ":Returns:", 
          "1. status(bool)= True / False", 
          "2. Validation Response in the data repository {data:reply(xml)}"
        ], 
        "wdesc": "Validate the contents of the specified configuration.", 
        "args": [
          "self", 
          "datastore", 
          "system_name", 
          "session_name=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "datastore": "", 
          "session_name": "None"
        }, 
        "def": "def validate(self, datastore, system_name, session_name=None):", 
        "line": 561, 
        "type": "fn", 
        "fn": "validate"
      }, 
      {
        "comment": [
          " Loads all or part of the specified config(not file) to the datastore", 
          ":Arguments:", 
          "1. datastore(string) = Name of datastore being edited", 
          "2. config(string) = The configuration xml string.", 
          "3. system_name(string) = Name of the system from the input datafile", 
          "4. session_name(string) = Name of the session to the system", 
          "5. default_operation(string) = [merge | replace | none (default)]", 
          "6. test_option(string) = [test_then_set | set | test-only | none (default)]", 
          "7. error_option(string) = [stop-on-error | continue-on-error", 
          "| rollback-on-error | none (default)]", 
          "rollback-on-error depends on :rollback-on-error capability", 
          ":Returns:", 
          "1. status(bool)= True / False", 
          "2. Edit Response in the data repository {data:reply(xml)}"
        ], 
        "wdesc": "Edit system configuration data", 
        "args": [
          "self", 
          "datastore", 
          "config", 
          "system_name", 
          "session_name=None", 
          "default_operation=None", 
          "test_option=None", 
          "error_option=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "test_option": "None", 
          "error_option": "None", 
          "default_operation": "None", 
          "datastore": "", 
          "config": "", 
          "session_name": "None"
        }, 
        "def": "def edit_config_from_string(self, datastore, config, system_name,session_name=None, default_operation=None,test_option=None, error_option=None):", 
        "line": 591, 
        "type": "fn", 
        "fn": "edit_config_from_string"
      }, 
      {
        "comment": [
          " create-subscription to receive netconf event notification", 
          ":Arguments:", 
          "1. system_name(string)  = Name of the system from the input datafile", 
          "2. session_name(string) = Name of the session to the system", 
          "3. stream_from(string) = NETCONF/SNMP/syslog ..", 
          "4. filter_string(string) = specifies the portion of the events to receive notification", 
          "by default entire events is reported", 
          "5. filter_type(string) = xpath or subtree(default)", 
          "6. start_time(string) = start time", 
          "7. stop_time(string) = stop time", 
          ":Returns:", 
          "1. status(bool)= True / False", 
          "2. Subscription Response in the data repository {data:reply(xml)}"
        ], 
        "wdesc": "create-subscription to receive netconf event notification", 
        "args": [
          "self", 
          "system_name", 
          "session_name=None", 
          "stream_from=None", 
          "filter_string=None", 
          "filter_type=\"subtree\"", 
          "start_time=None", 
          "stop_time=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "filter_type": "\"subtree\"", 
          "stream_from": "None", 
          "stop_time": "None", 
          "session_name": "None", 
          "filter_string": "None", 
          "start_time": "None"
        }, 
        "def": "def create_subscription(self, system_name,session_name=None,stream_from=None,filter_string=None,filter_type=\"subtree\",start_time=None,stop_time=None):", 
        "line": 631, 
        "type": "fn", 
        "fn": "create_subscription"
      }, 
      {
        "comment": [
          "Wait for specified notification event", 
          ":Arguments:", 
          "1. system_name(string) = Name of the system from the input datafile", 
          "2. waitString(string) = xpath string with namespace prefix", 
          "e.g.", 
          "for checking single data", 
          "waitString = \".//ns:event[./ns:eventClass/text()='fault']\"", 
          "Note that \"ns\" = namespace prefix", 
          "", 
          "for checking multiple data", 
          "waitString = \".//ns1:event1[text()='fault1'] and", 
          ".//ns1:event2[text()='fault2']\"", 
          "3. namespaceString(list of string) = list of namespace string", 
          "separated by comma", 
          "e.g., namespaceString = \"namespace_value1,namespace_value2\"", 
          "4. namespacePrefix(list of string) = list of namespace prefix", 
          "separated by comma", 
          "e.g.,", 
          "namespaceprefix = \"ns1,ns2\"", 
          "5. timeout(integer) = timeout value in second, default=600", 
          "6. session_name(string) = Name of the session to the system", 
          ":Returns:", 
          "1. status(bool)= True / False", 
          "E.g., Assuming the following notification is the one received:", 
          "****************************", 
          "<?xml version=\"1.0\" encoding=\"UTF-8\"?>", 
          "<notification xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">", 
          "<eventTime>2015-08-10T10:36:58.427756-07:00</eventTime>", 
          "<netconf-config-change xmlns=\"urn:ietf:params:xml:ns:yang:ietf-netconf-notifications\">", 
          "<changed-by>", 
          "<username>admin</username>", 
          "<session-id>0</session-id>", 
          "<source-host>127.0.0.1</source-host>", 
          "</changed-by>", 
          "<datastore>running</datastore>", 
          "<edit>", 
          "<target xmlns:notif=\"http://tail-f.com/ns/test/notif\">/notif:test</target>", 
          "<operation>replace</operation>", 
          "</edit>", 
          "</netconf-config-change>", 
          "</notification>", 
          "****************************", 
          "for the notification received above, please find the appropriate", 
          "argument and its values for checking username, source-host and target", 
          "in this notification as follows:", 
          "waitstring = \".//ns1:username[text()='admin'] and", 
          ".//ns1:source-host[text()='127.0.0.1'] and", 
          ".//ns2:target[text()='/notif:test']\"", 
          "namespaceString = \"urn:ietf:params:xml:ns:netconf:notification:1.0,", 
          "http://tail-f.com/ns/test/notif\"", 
          "namespacePrefix = \"ns1,ns2\"", 
          "Caveat: This keyword does not validate XMLSchema for notification."
        ], 
        "wdesc": "(\"waitfor_subscription to wait specified netconf event ", 
        "args": [
          "self", 
          "system_name", 
          "wait_string", 
          "namespace_string", 
          "namespace_prefix", 
          "timeout=600", 
          "session_name=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "namespace_string": "", 
          "self": "", 
          "namespace_prefix": "", 
          "timeout": "600", 
          "session_name": "None", 
          "wait_string": ""
        }, 
        "def": "def waitfor_subscription(self, system_name, wait_string, namespace_string,namespace_prefix, timeout=600, session_name=None):", 
        "line": 675, 
        "type": "fn", 
        "fn": "waitfor_subscription"
      }, 
      {
        "comment": [
          "kill-session test keyword", 
          "create another session to same NE and kills it.", 
          ":Arguments:", 
          "1. system_name(string) = Name of the system from the input datafile", 
          "2. session_name(string) = Name of the session to the system", 
          ":Returns:", 
          "1. status(bool)= True / False"
        ], 
        "wdesc": "kill-session, create another session and kill it", 
        "args": [
          "self", 
          "system_name", 
          "session_name=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "session_name": "None"
        }, 
        "def": "def testfor_killsession(self, system_name, session_name=None):", 
        "line": 761, 
        "type": "fn", 
        "fn": "testfor_killsession"
      }
    ]
  ], 
  "rest_driver": [
    [
      {
        "comment": [
          "This is the actions file, keywords are programmed here"
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "rest_actions.py", 
        "line": 1, 
        "type": "package", 
        "fn": "rest_actions"
      }, 
      {
        "comment": [
          " Rest class"
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "RestActions(object):", 
        "line": 26, 
        "type": "class", 
        "fn": "RestActions"
      }, 
      {
        "comment": [
          "def __init__(self):", 
          " constructor "
        ], 
        "wdesc": "__init__", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def __init__(self):", 
        "line": 29, 
        "type": "fn", 
        "fn": "__init__"
      }, 
      {
        "comment": [
          "Perform a http post actions and get the response", 
          "This keyword uses the warrior recommended Input datafile format for rest", 
          "", 
          "GLOSSARY", 
          "", 
          "** string pattern **", 
          "This pattern basically accepts every alphabet,", 
          "number, and special character.", 
          "Multiple values are accepted only where specified.", 
          "Separator would be specified if multiple values are accepted.", 
          "Other restrictions would be specified wherever needed", 
          "", 
          "", 
          "** dictionary pattern **", 
          "", 
          "This pattern does not accept multiple", 
          "values for a single key.", 
          "Key-Value pairs are separated by ;", 
          "Key and the corresponding value is separated by =", 
          "", 
          "Eg. key1=value1; key2=value2; key3=value3", 
          "", 
          "", 
          "** dict-tuple pattern **", 
          "", 
          "This pattern accepts multiple values for every key.", 
          "Key-Value pairs are separated by ,", 
          "Key and the corresponding value/s is/are separated by =", 
          "Values are separated by ;", 
          "", 
          "Eg. key1=value1;value2;value3, key2=value4;value5;value6, key3=value6;value7", 
          "", 
          "", 
          "** tuple pattern **", 
          "", 
          "This pattern accepts groups of elements.", 
          "Groups are separated by commas", 
          "Elements inside the group are separated by ;", 
          "Groups are enclosed inside parenthesis", 
          "Maximum number of elements inside a group: 2", 
          "", 
          "(element_11; element_12),(element_21; element_22),(element_31; element_32)", 
          "", 
          "", 
          "** dict-in-tuple pattern **", 
          "This pattern accepts groups of elements.", 
          "Only in the 3rd position, a dictionary patten is accepted.", 
          "Maximum number of elements inside a group: 3", 
          "Maximum number of elements inside the dictionary patten: No restrictions", 
          "The first two place do not accept dictionary pattern.", 
          "Groups are separated by ,", 
          "Groups are enclosed inside parenthesis", 
          "The dictionary patten inside the group is also enclosed in a parenthesis", 
          "Elements inside a group are separated by ;", 
          "Dictionary pattern accepted in the third position follows the specified", 
          "dictionary pattern", 
          "", 
          "(element_11;element_12;(key_11=value_11; key_12:value_12)),", 
          "(element_21;element_22;(key_21=value_21)),", 
          "(element_31;element_32;(key_31=value_31; key_32:value_32; key_33=value_33; key_34:value_34))", 
          "", 
          ":Arguments:", 
          "1. system_name: Name of the system from the datafile", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "Other Restrictions: Should be valid system name from the datafile", 
          "", 
          "eg: http_system_1", 
          "", 
          "2. url: Represents URL/ip address that is supposed to be tested", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: http://httpbin.org", 
          "", 
          "3. params: Represents parameters that need to be sent along with the URL", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: postId=1; comments=5", 
          "", 
          "4. data: Represents data to be posted. HTTP GET does NOT accept this argument.", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Encoding: Unicode", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Other Restrictions: Should be a valid file path", 
          "", 
          "eg: userId=1;id=1;title=Changed Post;body=New Comment", 
          "\\u0075\\u0073\\u0065\\u0072\\u0049\\u0064\\u003d\\u0031\\u003b\\u0069\\u0064\\u003d\\u0031\\u003b\\u0074", 
          "path/to/file/containing/data", 
          "", 
          "5. json: Represents the JSON data that goes into the body of the request", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "Format: Valid JSON format", 
          "", 
          "eg: {\"postId\":\"1\", \"comments\":\"This is a new comment\"}", 
          "", 
          "6. headers: Represents the headers sent along with the request", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: Content-Type=text; Date=04/21/2016; Allow=whatever_you_want_to_allow", 
          "", 
          "7. cookies: Represents the cookies sent along with the request", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Other Restrictions: Should be a valid file path", 
          "", 
          "eg: cookie=cookie_name; details=more_details_abput_the_cookie", 
          "path/to/file/containing/cookie/details", 
          "", 
          "8. files: Lets User accomplish multipart encoding upload", 
          "", 
          "Pattern: string pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"path_to_file1, path_to_file2, path_to_file3\"/>", 
          "", 
          "Pattern: dict-tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"file_group_name=path_to_file1, path_to_file2, path_to_file4, path_to_file5\"/>", 
          "", 
          "Pattern: tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separators: As specified in Glossary", 
          "Max Numbers of Values inside a Group: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type),", 
          "(path_to_file2;content_type),", 
          "(path_to_file3;content_type)\"/>", 
          "", 
          "Pattern: dict-in-tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separators: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Max Numbers of Values inside a Group: As specified in Glossary", 
          "Max Numbers of Values inside the Dictionary Pattern: No Restrictions", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type;(custom_header_1=value1; custom_header_2:value2)),", 
          "(path_to_file2;content_type;(custom_header_1=value1)),", 
          "(path_to_file3;content_type;(custom_header_1=value1;", 
          "custom_header_2=value2;", 
          "custom_header_3=value3))\"/>", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type),", 
          "path_to_file2,", 
          "(path_to_file3;content_type;(custom_header_1=value1; custom_header_2=value2),", 
          "(path_to_file4;content_type),", 
          "(path_to_file5;content_type;(custom_header_1=value1;", 
          "custom_header_2=value2;", 
          "custom_header_3=value3)),", 
          "path_to_file6, path_to_file_7\"/>", 
          "", 
          "9. user: Represents the username that would be required for authentication.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: Sanika", 
          "", 
          "10. password: Represents the password that would be required for authentication.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: password", 
          "", 
          "11. timeout: Represents the time barrier in which the request should be completed", 
          "If 2 values are given, the first value would be treated as a constraint for", 
          "sending the request, the second would be treated as a constraint for", 
          "receiving the response. If only one value is given, it would be treated as", 
          "constraint for sending the request and receiving a response.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: 2", 
          "Characters Accepted: Numerical Characters - Int or Float", 
          "", 
          "eg: 0.5, 0.75", 
          "0.6", 
          "", 
          "12. allow_redirects: Allows or disallows redirection", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'yes'", 
          "", 
          "eg: yes", 
          "", 
          "13. proxies: Allows the User to set up proxies for ip addresses", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: http=157.126.12.196:8081; https:157.126.12.144:80", 
          "", 
          "14. verify: Allows user to enable or disable authentication", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'yes'", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Other Restrictions: Should be a valid file path to a .pem file", 
          "", 
          "eg: path/to/CA_BUNDLE", 
          "no", 
          "", 
          "15. stream: Allows user to enable or disable immediate data downloading", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'no'", 
          "", 
          "eg: yes", 
          "", 
          "16. cert: Allows user to send  his/her own certificate", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: 2", 
          "Characters Accepted: All Characters", 
          "", 
          "Other Restrictions:", 
          "Both the inputs should be valid file paths.", 
          "Input 1 should be a file path to the certificate file", 
          "If the file specified in Input 1 contains the key, Input 2 is not necessary", 
          "If the key is stored in a different file, Input 2 should contain the path to that file.", 
          "", 
          "eg: path/to/certificate/file, path/to/key/file", 
          "path/to/certificate/file/which/contains/the/key", 
          "", 
          "17. expected_response: User specified expected response.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: Numerical Characters - Integers only", 
          "Default: The entire 200 series of HTTP Responses", 
          "", 
          "eg: 200, 302, 404", 
          "200", 
          "", 
          "18. request_id:  A unique request ID for this request", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: 01", 
          "", 
          "19. variable_config: The variable config file that contains", 
          "variables that need to be substituted into the json that is", 
          "being passed to this request. This can either be a relative or", 
          "an absolute path.", 
          "", 
          "Eg: ../Config_files/var_config.xml", 
          "/home/user/warrior_main/Warrior/Warriorspace/Config_files/var_config.xml", 
          "", 
          "20. var_sub: the pattern [var_sub] in the json will get substituted", 
          "with this value.", 
          "", 
          ":Returns:", 
          "1. <system_name>_status(boolean) = status code of the http post", 
          "2. <system_name>_api_response = the entire response object of the", 
          "http request", 
          "", 
          "Note: The Request Number is applicable when variable substitution in", 
          "JSON is being used. As variables get substituted in JSON, multiple", 
          "JSONs are formed and each JSON is sent as a separate request. These", 
          "requests are differentiated by adding add \"request_number\" which is", 
          "basically the serial number of those requests.", 
          "", 
          "3. The entire response object of the http request is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_object", 
          "<system_name>_api_response_object_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_object", 
          "<system_name>_<request_id>_api_response_object_<request_number>", 
          "", 
          "4. The response text (in text format) returned by the http request", 
          "is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_text", 
          "<system_name>_api_response_text_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_text", 
          "<system_name>_<request_id>_api_response_text_<request_number>", 
          "", 
          "5. The status code returned by the http request is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_status", 
          "<system_name>_api_response_status_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_status", 
          "<system_name>_<request_id>_api_response_status_<request_number>", 
          "", 
          "6. The content_type of the response returned by the http request", 
          "is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_content_type", 
          "<system_name>_api_response_content_type_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_content_type", 
          "<system_name>_<request_id>_api_response_content_type_<request_number>", 
          "", 
          "7. The extracted response returned from the response object (stored", 
          "in the format that it is returned in - JSON, XML, Text) is stored", 
          "as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_content", 
          "<system_name>_api_response_content_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_content", 
          "<system_name>_<request_id>_api_response_content_<request_number>"
        ], 
        "wdesc": "Perform a http post", 
        "args": [
          "self", 
          "system_name", 
          "variable_config=None", 
          "request_id=None", 
          "url=None", 
          "data=None", 
          "expected_response=None", 
          "headers=None", 
          "user=None", 
          "password=None", 
          "allow_redirects=None", 
          "timeout=None", 
          "json=None", 
          "cookies=None", 
          "files=None", 
          "proxies=None", 
          "verify=None", 
          "stream=None", 
          "cert=None", 
          "var_sub=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "files": "None", 
          "cookies": "None", 
          "proxies": "None", 
          "stream": "None", 
          "url": "None", 
          "verify": "None", 
          "self": "", 
          "cert": "None", 
          "headers": "None", 
          "json": "None", 
          "expected_response": "None", 
          "user": "None", 
          "timeout": "None", 
          "request_id": "None", 
          "variable_config": "None", 
          "password": "None", 
          "data": "None", 
          "allow_redirects": "None", 
          "var_sub": "None"
        }, 
        "def": "def perform_http_post(self, system_name, variable_config=None,request_id=None, url=None, data=None,expected_response=None,headers=None, user=None, password=None,allow_redirects=None, timeout=None,json=None, cookies=None, files=None, proxies=None,verify=None, stream=None, cert=None, var_sub=None):", 
        "line": 39, 
        "type": "fn", 
        "fn": "perform_http_post"
      }, 
      {
        "comment": [
          "Perform a http post actions and get the response", 
          "This keyword uses the warrior recommended Input datafile format for rest", 
          "", 
          "Please refer to perform_http_post keyword documentation to understand all", 
          "patterns", 
          "", 
          ":Arguments:", 
          "1. system_name: Name of the system from the datafile", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "Other Restrictions: Should be valid system name from the datafile", 
          "", 
          "eg: http_system_1", 
          "", 
          "2. request_id: A unique request ID for this request", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: 01", 
          "", 
          "3. url: Represents URL/ip address that is supposed to be tested", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: http://httpbin.org", 
          "", 
          "4. params: Represents parameters that need to be sent along with the URL", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: postId=1; comments=5", 
          "", 
          "5. json: Represents the JSON data that goes into the body of the request", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "Format: Valid JSON format", 
          "", 
          "eg: {\"postId\":\"1\", \"comments\":\"This is a new comment\"}", 
          "", 
          "6. headers: Represents the headers sent along with the request", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: Content-Type=text; Date=04/21/2016; Allow=whatever_you_want_to_allow", 
          "", 
          "7. cookies: Represents the cookies sent along with the request", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Other Restrictions: Should be a valid file path", 
          "", 
          "eg: cookie=cookie_name; details=more_details_abput_the_cookie", 
          "path/to/file/containing/cookie/details", 
          "", 
          "8. files: Lets User accomplish multipart encoding upload", 
          "", 
          "Pattern: string pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"path_to_file1, path_to_file2, path_to_file3\"/>", 
          "", 
          "Pattern: dict-tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"file_group_name=path_to_file1, path_to_file2, path_to_file4, path_to_file5\"/>", 
          "", 
          "Pattern: tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separators: As specified in Glossary", 
          "Max Numbers of Values inside a Group: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type),", 
          "(path_to_file2;content_type),", 
          "(path_to_file3;content_type)\"/>", 
          "", 
          "Pattern: dict-in-tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separators: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Max Numbers of Values inside a Group: As specified in Glossary", 
          "Max Numbers of Values inside the Dictionary Pattern: No Restrictions", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type;(custom_header_1=value1; custom_header_2:value2)),", 
          "(path_to_file2;content_type;(custom_header_1=value1)),", 
          "(path_to_file3;content_type;(custom_header_1=value1;", 
          "custom_header_2=value2;", 
          "custom_header_3=value3))\"/>", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type),", 
          "path_to_file2,", 
          "(path_to_file3;content_type;(custom_header_1=value1; custom_header_2=value2),", 
          "(path_to_file4;content_type),", 
          "(path_to_file5;content_type;(custom_header_1=value1;", 
          "custom_header_2=value2;", 
          "custom_header_3=value3)),", 
          "path_to_file6, path_to_file_7\"/>", 
          "", 
          "9. user: Represents the username that would be required for authentication.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: Sanika", 
          "", 
          "10. password: Represents the password that would be required for authentication.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: password", 
          "", 
          "11. timeout: Represents the time barrier in which the request should be completed", 
          "If 2 values are given, the first value would be treated as a constraint for", 
          "sending the request, the second would be treated as a constraint for", 
          "receiving the response. If only one value is given, it would be treated as", 
          "constraint for sending the request and receiving a response.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: 2", 
          "Characters Accepted: Numerical Characters - Int or Float", 
          "", 
          "eg: 0.5, 0.75", 
          "0.6", 
          "", 
          "12. allow_redirects: Allows or disallows redirection", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'yes'", 
          "", 
          "eg: yes", 
          "", 
          "13. proxies: Allows the User to set up proxies for ip addresses", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: http=157.126.12.196:8081; https:157.126.12.144:80", 
          "", 
          "14. verify: Allows user to enable or disable authentication", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'yes'", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Other Restrictions: Should be a valid file path to a .pem file", 
          "", 
          "eg: path/to/CA_BUNDLE", 
          "no", 
          "", 
          "15. stream: Allows user to enable or disable immediate data downloading", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'no'", 
          "", 
          "eg: yes", 
          "", 
          "16. cert: Allows user to send  his/her own certificate", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: 2", 
          "Characters Accepted: All Characters", 
          "", 
          "Other Restrictions:", 
          "Both the inputs should be valid file paths.", 
          "Input 1 should be a file path to the certificate file", 
          "If the file specified in Input 1 contains the key, Input 2 is not necessary", 
          "If the key is stored in a different file, Input 2 should contain the path to that file.", 
          "", 
          "eg: path/to/certificate/file, path/to/key/file", 
          "path/to/certificate/file/which/contains/the/key", 
          "", 
          "17. expected_response: User specified expected response.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: Numerical Characters - Integers only", 
          "Default: The entire 200 series of HTTP Responses", 
          "", 
          "eg: 200, 302, 404", 
          "200", 
          "", 
          "18. variable_config: The variable config file that contains", 
          "variables that need to be substituted into the json that is", 
          "being passed to this request. This can either be a relative or", 
          "an absolute path.", 
          "", 
          "Eg: ../Config_files/var_config.xml", 
          "/home/user/warrior_main/Warrior/Warriorspace/Config_files/var_config.xml", 
          "", 
          "19. var_sub: the pattern [var_sub] in the json will get substituted", 
          "with this value.", 
          "", 
          ":Returns:", 
          "1. <system_name>_status(boolean) = status code of the http get", 
          "2. <system_name>_api_response = the entire response object of the", 
          "http request", 
          "", 
          "Note: The Request Number is applicable when variable substitution in", 
          "JSON is being used. As variables get substituted in JSON, multiple", 
          "JSONs are formed and each JSON is sent as a separate request. These", 
          "requests are differentiated by adding add \"request_number\" which is", 
          "basically the serial number of those requests.", 
          "", 
          "3. The entire response object of the http request is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_object", 
          "<system_name>_api_response_object_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_object", 
          "<system_name>_<request_id>_api_response_object_<request_number>", 
          "", 
          "4. The response text (in text format) returned by the http request", 
          "is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_text", 
          "<system_name>_api_response_text_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_text", 
          "<system_name>_<request_id>_api_response_text_<request_number>", 
          "", 
          "5. The status code returned by the http request is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_status", 
          "<system_name>_api_response_status_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_status", 
          "<system_name>_<request_id>_api_response_status_<request_number>", 
          "", 
          "6. The content_type of the response returned by the http request", 
          "is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_content_type", 
          "<system_name>_api_response_content_type_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_content_type", 
          "<system_name>_<request_id>_api_response_content_type_<request_number>", 
          "", 
          "7. The extracted response returned from the response object (stored", 
          "in the format that it is returned in - JSON, XML, Text) is stored", 
          "as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_content", 
          "<system_name>_api_response_content_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_content", 
          "<system_name>_<request_id>_api_response_content_<request_number>"
        ], 
        "wdesc": "Perform a http get to the url", 
        "args": [
          "self", 
          "system_name", 
          "variable_config=None", 
          "request_id=None", 
          "url=None", 
          "params=None", 
          "expected_response=None", 
          "headers=None", 
          "user=None", 
          "password=None", 
          "allow_redirects=None", 
          "timeout=None", 
          "json=None", 
          "cookies=None", 
          "files=None", 
          "proxies=None", 
          "verify=None", 
          "stream=None", 
          "cert=None", 
          "var_sub=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "files": "None", 
          "cookies": "None", 
          "proxies": "None", 
          "stream": "None", 
          "url": "None", 
          "verify": "None", 
          "self": "", 
          "cert": "None", 
          "headers": "None", 
          "json": "None", 
          "expected_response": "None", 
          "params": "None", 
          "user": "None", 
          "timeout": "None", 
          "request_id": "None", 
          "variable_config": "None", 
          "password": "None", 
          "allow_redirects": "None", 
          "var_sub": "None"
        }, 
        "def": "def perform_http_get(self, system_name, variable_config=None,request_id=None, url=None,params=None, expected_response=None,headers=None, user=None, password=None,allow_redirects=None, timeout=None,json=None, cookies=None, files=None, proxies=None,verify=None, stream=None, cert=None, var_sub=None):", 
        "line": 506, 
        "type": "fn", 
        "fn": "perform_http_get"
      }, 
      {
        "comment": [
          "Perform a http post actions and get the response", 
          "This keyword uses the warrior recommended Input datafile format for rest", 
          "", 
          "Please refer to perform_http_post keyword documentation to understand all", 
          "patterns", 
          "", 
          ":Arguments:", 
          "1. system_name: Name of the system from the datafile", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "Other Restrictions: Should be valid system name from the datafile", 
          "", 
          "eg: http_system_1", 
          "", 
          "2. request_id: A unique request ID for this request", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: 01", 
          "", 
          "3. url: Represents URL/ip address that is supposed to be tested", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: http://httpbin.org", 
          "", 
          "4. params: Represents parameters that need to be sent along with the URL", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: postId=1; comments=5", 
          "", 
          "5. data: Represents data to be posted. HTTP GET does NOT accept this argument.", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Encoding: Unicode", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Other Restrictions: Should be a valid file path", 
          "", 
          "eg: userId=1;id=1;title=Changed Post;body=New Comment", 
          "\\u0075\\u0073\\u0065\\u0072\\u0049\\u0064\\u003d\\u0031\\u003b\\u0069\\u0064\\u003d\\u0031\\u003b\\u0074", 
          "path/to/file/containing/data", 
          "", 
          "6. json: Represents the JSON data that goes into the body of the request", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "Format: Valid JSON format", 
          "", 
          "eg: {\"postId\":\"1\", \"comments\":\"This is a new comment\"}", 
          "", 
          "7. headers: Represents the headers sent along with the request", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: Content-Type=text; Date=04/21/2016; Allow=whatever_you_want_to_allow", 
          "", 
          "8. cookies: Represents the cookies sent along with the request", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Other Restrictions: Should be a valid file path", 
          "", 
          "eg: cookie=cookie_name; details=more_details_abput_the_cookie", 
          "path/to/file/containing/cookie/details", 
          "", 
          "9. files: Lets User accomplish multipart encoding upload", 
          "", 
          "Pattern: string pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"path_to_file1, path_to_file2, path_to_file3\"/>", 
          "", 
          "Pattern: dict-tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"file_group_name=path_to_file1, path_to_file2, path_to_file4, path_to_file5\"/>", 
          "", 
          "Pattern: tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separators: As specified in Glossary", 
          "Max Numbers of Values inside a Group: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type),", 
          "(path_to_file2;content_type),", 
          "(path_to_file3;content_type)\"/>", 
          "", 
          "Pattern: dict-in-tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separators: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Max Numbers of Values inside a Group: As specified in Glossary", 
          "Max Numbers of Values inside the Dictionary Pattern: No Restrictions", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type;(custom_header_1=value1; custom_header_2:value2)),", 
          "(path_to_file2;content_type;(custom_header_1=value1)),", 
          "(path_to_file3;content_type;(custom_header_1=value1;", 
          "custom_header_2=value2;", 
          "custom_header_3=value3))\"/>", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type),", 
          "path_to_file2,", 
          "(path_to_file3;content_type;(custom_header_1=value1; custom_header_2=value2),", 
          "(path_to_file4;content_type),", 
          "(path_to_file5;content_type;(custom_header_1=value1;", 
          "custom_header_2=value2;", 
          "custom_header_3=value3)),", 
          "path_to_file6, path_to_file_7\"/>", 
          "", 
          "10. user: Represents the username that would be required for authentication.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: Sanika", 
          "", 
          "11. password: Represents the password that would be required for authentication.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: password", 
          "", 
          "12. timeout: Represents the time barrier in which the request should be completed", 
          "If 2 values are given, the first value would be treated as a constraint for", 
          "sending the request, the second would be treated as a constraint for", 
          "receiving the response. If only one value is given, it would be treated as", 
          "constraint for sending the request and receiving a response.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: 2", 
          "Characters Accepted: Numerical Characters - Int or Float", 
          "", 
          "eg: 0.5, 0.75", 
          "0.6", 
          "", 
          "13. allow_redirects: Allows or disallows redirection", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'yes'", 
          "", 
          "eg: yes", 
          "", 
          "14. proxies: Allows the User to set up proxies for ip addresses", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: http=157.126.12.196:8081; https:157.126.12.144:80", 
          "", 
          "15. verify: Allows user to enable or disable authentication", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'yes'", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Other Restrictions: Should be a valid file path to a .pem file", 
          "", 
          "eg: path/to/CA_BUNDLE", 
          "no", 
          "", 
          "16. stream: Allows user to enable or disable immediate data downloading", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'no'", 
          "", 
          "eg: yes", 
          "", 
          "17. cert: Allows user to send  his/her own certificate", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: 2", 
          "Characters Accepted: All Characters", 
          "", 
          "Other Restrictions:", 
          "Both the inputs should be valid file paths.", 
          "Input 1 should be a file path to the certificate file", 
          "If the file specified in Input 1 contains the key, Input 2 is not necessary", 
          "If the key is stored in a different file, Input 2 should contain the path to that file.", 
          "", 
          "eg: path/to/certificate/file, path/to/key/file", 
          "path/to/certificate/file/which/contains/the/key", 
          "", 
          "18. expected_response: User specified expected response.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: Numerical Characters - Integers only", 
          "Default: The entire 200 series of HTTP Responses", 
          "", 
          "eg: 200, 302, 404", 
          "200", 
          "", 
          "19. variable_config: The variable config file that contains", 
          "variables that need to be substituted into the json that is", 
          "being passed to this request. This can either be a relative or", 
          "an absolute path.", 
          "", 
          "Eg: ../Config_files/var_config.xml", 
          "/home/user/warrior_main/Warrior/Warriorspace/Config_files/var_config.xml", 
          "", 
          "20. var_sub: the pattern [var_sub] in the json will get substituted", 
          "with this value.", 
          "", 
          ":Returns:", 
          "1. <system_name>_status(boolean) = status code of the http put", 
          "2. <system_name>_api_response = the entire response object of the", 
          "http request", 
          "", 
          "Note: The Request Number is applicable when variable substitution in", 
          "JSON is being used. As variables get substituted in JSON, multiple", 
          "JSONs are formed and each JSON is sent as a separate request. These", 
          "requests are differentiated by adding add \"request_number\" which is", 
          "basically the serial number of those requests.", 
          "", 
          "3. The entire response object of the http request is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_object", 
          "<system_name>_api_response_object_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_object", 
          "<system_name>_<request_id>_api_response_object_<request_number>", 
          "", 
          "4. The response text (in text format) returned by the http request", 
          "is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_text", 
          "<system_name>_api_response_text_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_text", 
          "<system_name>_<request_id>_api_response_text_<request_number>", 
          "", 
          "5. The status code returned by the http request is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_status", 
          "<system_name>_api_response_status_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_status", 
          "<system_name>_<request_id>_api_response_status_<request_number>", 
          "", 
          "6. The content_type of the response returned by the http request", 
          "is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_content_type", 
          "<system_name>_api_response_content_type_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_content_type", 
          "<system_name>_<request_id>_api_response_content_type_<request_number>", 
          "", 
          "7. The extracted response returned from the response object (stored", 
          "in the format that it is returned in - JSON, XML, Text) is stored", 
          "as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_content", 
          "<system_name>_api_response_content_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_content", 
          "<system_name>_<request_id>_api_response_content_<request_number>"
        ], 
        "wdesc": "Perform a http put to the url", 
        "args": [
          "self", 
          "system_name", 
          "variable_config=None", 
          "request_id=None", 
          "data=None", 
          "url=None", 
          "expected_response=None", 
          "headers=None", 
          "user=None", 
          "password=None", 
          "allow_redirects=None", 
          "timeout=None", 
          "json=None", 
          "cookies=None", 
          "files=None", 
          "proxies=None", 
          "verify=None", 
          "stream=None", 
          "cert=None", 
          "var_sub=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "files": "None", 
          "cookies": "None", 
          "proxies": "None", 
          "stream": "None", 
          "url": "None", 
          "verify": "None", 
          "self": "", 
          "cert": "None", 
          "headers": "None", 
          "json": "None", 
          "expected_response": "None", 
          "user": "None", 
          "timeout": "None", 
          "request_id": "None", 
          "variable_config": "None", 
          "password": "None", 
          "data": "None", 
          "allow_redirects": "None", 
          "var_sub": "None"
        }, 
        "def": "def perform_http_put(self, system_name, variable_config=None,request_id=None, data=None,url=None, expected_response=None,headers=None, user=None, password=None,allow_redirects=None, timeout=None,json=None, cookies=None, files=None, proxies=None,verify=None, stream=None, cert=None, var_sub=None):", 
        "line": 894, 
        "type": "fn", 
        "fn": "perform_http_put"
      }, 
      {
        "comment": [
          "Perform a http post actions and get the response", 
          "This keyword uses the warrior recommended Input datafile format for rest", 
          "", 
          "Please refer to perform_http_post keyword documentation to understand all", 
          "patterns", 
          "", 
          ":Arguments:", 
          "1. system_name: Name of the system from the datafile", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "Other Restrictions: Should be valid system name from the datafile", 
          "", 
          "eg: http_system_1", 
          "", 
          "2. request_id: A unique request ID for this request", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: 01", 
          "", 
          "3. url: Represents URL/ip address that is supposed to be tested", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: http://httpbin.org", 
          "", 
          "4. params: Represents parameters that need to be sent along with the URL", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: postId=1; comments=5", 
          "", 
          "5. data: Represents data to be posted. HTTP GET does NOT accept this argument.", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Encoding: Unicode", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Other Restrictions: Should be a valid file path", 
          "", 
          "eg: userId=1;id=1;title=Changed Post;body=New Comment", 
          "\\u0075\\u0073\\u0065\\u0072\\u0049\\u0064\\u003d\\u0031\\u003b\\u0069\\u0064\\u003d\\u0031\\u003b\\u0074", 
          "path/to/file/containing/data", 
          "", 
          "6. json: Represents the JSON data that goes into the body of the request", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "Format: Valid JSON format", 
          "", 
          "eg: {\"postId\":\"1\", \"comments\":\"This is a new comment\"}", 
          "", 
          "7. headers: Represents the headers sent along with the request", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: Content-Type=text; Date=04/21/2016; Allow=whatever_you_want_to_allow", 
          "", 
          "8. cookies: Represents the cookies sent along with the request", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Other Restrictions: Should be a valid file path", 
          "", 
          "eg: cookie=cookie_name; details=more_details_abput_the_cookie", 
          "path/to/file/containing/cookie/details", 
          "", 
          "9. files: Lets User accomplish multipart encoding upload", 
          "", 
          "Pattern: string pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"path_to_file1, path_to_file2, path_to_file3\"/>", 
          "", 
          "Pattern: dict-tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"file_group_name=path_to_file1, path_to_file2, path_to_file4, path_to_file5\"/>", 
          "", 
          "Pattern: tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separators: As specified in Glossary", 
          "Max Numbers of Values inside a Group: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type),", 
          "(path_to_file2;content_type),", 
          "(path_to_file3;content_type)\"/>", 
          "", 
          "Pattern: dict-in-tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separators: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Max Numbers of Values inside a Group: As specified in Glossary", 
          "Max Numbers of Values inside the Dictionary Pattern: No Restrictions", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type;(custom_header_1=value1; custom_header_2:value2)),", 
          "(path_to_file2;content_type;(custom_header_1=value1)),", 
          "(path_to_file3;content_type;(custom_header_1=value1;", 
          "custom_header_2=value2;", 
          "custom_header_3=value3))\"/>", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type),", 
          "path_to_file2,", 
          "(path_to_file3;content_type;(custom_header_1=value1; custom_header_2=value2),", 
          "(path_to_file4;content_type),", 
          "(path_to_file5;content_type;(custom_header_1=value1;", 
          "custom_header_2=value2;", 
          "custom_header_3=value3)),", 
          "path_to_file6, path_to_file_7\"/>", 
          "", 
          "10. user: Represents the username that would be required for authentication.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: Sanika", 
          "", 
          "11. password: Represents the password that would be required for authentication.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: password", 
          "", 
          "12. timeout: Represents the time barrier in which the request should be completed", 
          "If 2 values are given, the first value would be treated as a constraint for", 
          "sending the request, the second would be treated as a constraint for", 
          "receiving the response. If only one value is given, it would be treated as", 
          "constraint for sending the request and receiving a response.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: 2", 
          "Characters Accepted: Numerical Characters - Int or Float", 
          "", 
          "eg: 0.5, 0.75", 
          "0.6", 
          "", 
          "13. allow_redirects: Allows or disallows redirection", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'yes'", 
          "", 
          "eg: yes", 
          "", 
          "14. proxies: Allows the User to set up proxies for ip addresses", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: http=157.126.12.196:8081; https:157.126.12.144:80", 
          "", 
          "15. verify: Allows user to enable or disable authentication", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'yes'", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Other Restrictions: Should be a valid file path to a .pem file", 
          "", 
          "eg: path/to/CA_BUNDLE", 
          "no", 
          "", 
          "16. stream: Allows user to enable or disable immediate data downloading", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'no'", 
          "", 
          "eg: yes", 
          "", 
          "17. cert: Allows user to send  his/her own certificate", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: 2", 
          "Characters Accepted: All Characters", 
          "", 
          "Other Restrictions:", 
          "Both the inputs should be valid file paths.", 
          "Input 1 should be a file path to the certificate file", 
          "If the file specified in Input 1 contains the key, Input 2 is not necessary", 
          "If the key is stored in a different file, Input 2 should contain the path to that file.", 
          "", 
          "eg: path/to/certificate/file, path/to/key/file", 
          "path/to/certificate/file/which/contains/the/key", 
          "", 
          "18. expected_response: User specified expected response.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: Numerical Characters - Integers only", 
          "Default: The entire 200 series of HTTP Responses", 
          "", 
          "eg: 200, 302, 404", 
          "200", 
          "", 
          "19. variable_config: The variable config file that contains", 
          "variables that need to be substituted into the json that is", 
          "being passed to this request. This can either be a relative or", 
          "an absolute path.", 
          "", 
          "Eg: ../Config_files/var_config.xml", 
          "/home/user/warrior_main/Warrior/Warriorspace/Config_files/var_config.xml", 
          "", 
          "20. var_sub: the pattern [var_sub] in the json will get substituted", 
          "with this value.", 
          "", 
          ":Returns:", 
          "1. <system_name>_status(boolean) = status code of the http patch", 
          "2. <system_name>_api_response = the entire response object of the", 
          "http request", 
          "", 
          "Note: The Request Number is applicable when variable substitution in", 
          "JSON is being used. As variables get substituted in JSON, multiple", 
          "JSONs are formed and each JSON is sent as a separate request. These", 
          "requests are differentiated by adding add \"request_number\" which is", 
          "basically the serial number of those requests.", 
          "", 
          "3. The entire response object of the http request is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_object", 
          "<system_name>_api_response_object_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_object", 
          "<system_name>_<request_id>_api_response_object_<request_number>", 
          "", 
          "4. The response text (in text format) returned by the http request", 
          "is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_text", 
          "<system_name>_api_response_text_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_text", 
          "<system_name>_<request_id>_api_response_text_<request_number>", 
          "", 
          "5. The status code returned by the http request is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_status", 
          "<system_name>_api_response_status_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_status", 
          "<system_name>_<request_id>_api_response_status_<request_number>", 
          "", 
          "6. The content_type of the response returned by the http request", 
          "is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_content_type", 
          "<system_name>_api_response_content_type_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_content_type", 
          "<system_name>_<request_id>_api_response_content_type_<request_number>", 
          "", 
          "7. The extracted response returned from the response object (stored", 
          "in the format that it is returned in - JSON, XML, Text) is stored", 
          "as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_content", 
          "<system_name>_api_response_content_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_content", 
          "<system_name>_<request_id>_api_response_content_<request_number>"
        ], 
        "wdesc": "Perform a http patch to the url", 
        "args": [
          "self", 
          "system_name", 
          "variable_config=None", 
          "request_id=None", 
          "data=None", 
          "url=None", 
          "expected_response=None", 
          "headers=None", 
          "user=None", 
          "password=None", 
          "allow_redirects=None", 
          "timeout=None", 
          "json=None", 
          "cookies=None", 
          "files=None", 
          "proxies=None", 
          "verify=None", 
          "stream=None", 
          "cert=None", 
          "var_sub=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "files": "None", 
          "cookies": "None", 
          "proxies": "None", 
          "stream": "None", 
          "url": "None", 
          "verify": "None", 
          "self": "", 
          "cert": "None", 
          "headers": "None", 
          "json": "None", 
          "expected_response": "None", 
          "user": "None", 
          "timeout": "None", 
          "request_id": "None", 
          "variable_config": "None", 
          "password": "None", 
          "data": "None", 
          "allow_redirects": "None", 
          "var_sub": "None"
        }, 
        "def": "def perform_http_patch(self, system_name, variable_config=None,request_id=None, data=None,url=None, expected_response=None,headers=None, user=None, password=None,allow_redirects=None, timeout=None,json=None, cookies=None, files=None, proxies=None,verify=None, stream=None, cert=None, var_sub=None):", 
        "line": 1308, 
        "type": "fn", 
        "fn": "perform_http_patch"
      }, 
      {
        "comment": [
          "Perform a http post actions and get the response", 
          "This keyword uses the warrior recommended Input datafile format for rest", 
          "", 
          "Please refer to perform_http_post keyword documentation to understand all", 
          "patterns", 
          "", 
          ":Arguments:", 
          "1. system_name: Name of the system from the datafile", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "Other Restrictions: Should be valid system name from the datafile", 
          "", 
          "eg: http_system_1", 
          "", 
          "2. request_id: A unique request ID for this request", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: 01", 
          "", 
          "3. url: Represents URL/ip address that is supposed to be tested", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: http://httpbin.org", 
          "", 
          "4. params: Represents parameters that need to be sent along with the URL", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: postId=1; comments=5", 
          "", 
          "5. data: Represents data to be posted. HTTP GET does NOT accept this argument.", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Encoding: Unicode", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Other Restrictions: Should be a valid file path", 
          "", 
          "eg: userId=1;id=1;title=Changed Post;body=New Comment", 
          "\\u0075\\u0073\\u0065\\u0072\\u0049\\u0064\\u003d\\u0031\\u003b\\u0069\\u0064\\u003d\\u0031\\u003b\\u0074", 
          "path/to/file/containing/data", 
          "", 
          "6. json: Represents the JSON data that goes into the body of the request", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "Format: Valid JSON format", 
          "", 
          "eg: {\"postId\":\"1\", \"comments\":\"This is a new comment\"}", 
          "", 
          "7. headers: Represents the headers sent along with the request", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: Content-Type=text; Date=04/21/2016; Allow=whatever_you_want_to_allow", 
          "", 
          "8. cookies: Represents the cookies sent along with the request", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Other Restrictions: Should be a valid file path", 
          "", 
          "eg: cookie=cookie_name; details=more_details_abput_the_cookie", 
          "path/to/file/containing/cookie/details", 
          "", 
          "9. files: Lets User accomplish multipart encoding upload", 
          "", 
          "Pattern: string pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"path_to_file1, path_to_file2, path_to_file3\"/>", 
          "", 
          "Pattern: dict-tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"file_group_name=path_to_file1, path_to_file2, path_to_file4, path_to_file5\"/>", 
          "", 
          "Pattern: tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separators: As specified in Glossary", 
          "Max Numbers of Values inside a Group: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type),", 
          "(path_to_file2;content_type),", 
          "(path_to_file3;content_type)\"/>", 
          "", 
          "Pattern: dict-in-tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separators: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Max Numbers of Values inside a Group: As specified in Glossary", 
          "Max Numbers of Values inside the Dictionary Pattern: No Restrictions", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type;(custom_header_1=value1; custom_header_2:value2)),", 
          "(path_to_file2;content_type;(custom_header_1=value1)),", 
          "(path_to_file3;content_type;(custom_header_1=value1;", 
          "custom_header_2=value2;", 
          "custom_header_3=value3))\"/>", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type),", 
          "path_to_file2,", 
          "(path_to_file3;content_type;(custom_header_1=value1; custom_header_2=value2),", 
          "(path_to_file4;content_type),", 
          "(path_to_file5;content_type;(custom_header_1=value1;", 
          "custom_header_2=value2;", 
          "custom_header_3=value3)),", 
          "path_to_file6, path_to_file_7\"/>", 
          "", 
          "10. user: Represents the username that would be required for authentication.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: Sanika", 
          "", 
          "11. password: Represents the password that would be required for authentication.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: password", 
          "", 
          "12. timeout: Represents the time barrier in which the request should be completed", 
          "If 2 values are given, the first value would be treated as a constraint for", 
          "sending the request, the second would be treated as a constraint for", 
          "receiving the response. If only one value is given, it would be treated as", 
          "constraint for sending the request and receiving a response.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: 2", 
          "Characters Accepted: Numerical Characters - Int or Float", 
          "", 
          "eg: 0.5, 0.75", 
          "0.6", 
          "", 
          "13. allow_redirects: Allows or disallows redirection", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'yes'", 
          "", 
          "eg: yes", 
          "", 
          "14. proxies: Allows the User to set up proxies for ip addresses", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: http=157.126.12.196:8081; https:157.126.12.144:80", 
          "", 
          "15. verify: Allows user to enable or disable authentication", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'yes'", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Other Restrictions: Should be a valid file path to a .pem file", 
          "", 
          "eg: path/to/CA_BUNDLE", 
          "no", 
          "", 
          "16. stream: Allows user to enable or disable immediate data downloading", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'no'", 
          "", 
          "eg: yes", 
          "", 
          "17. cert: Allows user to send  his/her own certificate", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: 2", 
          "Characters Accepted: All Characters", 
          "", 
          "Other Restrictions:", 
          "Both the inputs should be valid file paths.", 
          "Input 1 should be a file path to the certificate file", 
          "If the file specified in Input 1 contains the key, Input 2 is not necessary", 
          "If the key is stored in a different file, Input 2 should contain the path to that file.", 
          "", 
          "eg: path/to/certificate/file, path/to/key/file", 
          "path/to/certificate/file/which/contains/the/key", 
          "", 
          "18. expected_response: User specified expected response.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: Numerical Characters - Integers only", 
          "Default: The entire 200 series of HTTP Responses", 
          "", 
          "eg: 200, 302, 404", 
          "200", 
          "", 
          "19. variable_config: The variable config file that contains", 
          "variables that need to be substituted into the json that is", 
          "being passed to this request. This can either be a relative or", 
          "an absolute path.", 
          "", 
          "Eg: ../Config_files/var_config.xml", 
          "/home/user/warrior_main/Warrior/Warriorspace/Config_files/var_config.xml", 
          "", 
          "20. var_sub: the pattern [var_sub] in the json will get substituted", 
          "with this value.", 
          "", 
          ":Returns:", 
          "1. <system_name>_status(boolean) = status code of the http delete", 
          "2. <system_name>_api_response = the entire response object of the", 
          "http request", 
          "", 
          "Note: The Request Number is applicable when variable substitution in", 
          "JSON is being used. As variables get substituted in JSON, multiple", 
          "JSONs are formed and each JSON is sent as a separate request. These", 
          "requests are differentiated by adding add \"request_number\" which is", 
          "basically the serial number of those requests.", 
          "", 
          "3. The entire response object of the http request is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_object", 
          "<system_name>_api_response_object_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_object", 
          "<system_name>_<request_id>_api_response_object_<request_number>", 
          "", 
          "4. The response text (in text format) returned by the http request", 
          "is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_text", 
          "<system_name>_api_response_text_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_text", 
          "<system_name>_<request_id>_api_response_text_<request_number>", 
          "", 
          "5. The status code returned by the http request is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_status", 
          "<system_name>_api_response_status_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_status", 
          "<system_name>_<request_id>_api_response_status_<request_number>", 
          "", 
          "6. The content_type of the response returned by the http request", 
          "is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_content_type", 
          "<system_name>_api_response_content_type_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_content_type", 
          "<system_name>_<request_id>_api_response_content_type_<request_number>", 
          "", 
          "7. The extracted response returned from the response object (stored", 
          "in the format that it is returned in - JSON, XML, Text) is stored", 
          "as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_content", 
          "<system_name>_api_response_content_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_content", 
          "<system_name>_<request_id>_api_response_content_<request_number>"
        ], 
        "wdesc": "Perform a http delete to the url", 
        "args": [
          "self", 
          "system_name", 
          "variable_config=None", 
          "request_id=None", 
          "data=None", 
          "url=None", 
          "expected_response=None", 
          "headers=None", 
          "user=None", 
          "password=None", 
          "allow_redirects=None", 
          "timeout=None", 
          "json=None", 
          "cookies=None", 
          "files=None", 
          "proxies=None", 
          "verify=None", 
          "stream=None", 
          "cert=None", 
          "var_sub=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "files": "None", 
          "cookies": "None", 
          "proxies": "None", 
          "stream": "None", 
          "url": "None", 
          "verify": "None", 
          "self": "", 
          "cert": "None", 
          "headers": "None", 
          "json": "None", 
          "expected_response": "None", 
          "user": "None", 
          "timeout": "None", 
          "request_id": "None", 
          "variable_config": "None", 
          "password": "None", 
          "data": "None", 
          "allow_redirects": "None", 
          "var_sub": "None"
        }, 
        "def": "def perform_http_delete(self, system_name, variable_config=None,request_id=None, data=None,url=None, expected_response=None,headers=None, user=None, password=None,allow_redirects=None, timeout=None,json=None, cookies=None, files=None, proxies=None,verify=None, stream=None, cert=None, var_sub=None):", 
        "line": 1721, 
        "type": "fn", 
        "fn": "perform_http_delete"
      }, 
      {
        "comment": [
          "Perform a http post actions and get the response", 
          "This keyword uses the warrior recommended Input datafile format for rest", 
          "", 
          "Please refer to perform_http_post keyword documentation to understand all", 
          "patterns", 
          "", 
          ":Arguments:", 
          "1. system_name: Name of the system from the datafile", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "Other Restrictions: Should be valid system name from the datafile", 
          "", 
          "eg: http_system_1", 
          "", 
          "2. request_id: A unique request ID for this request", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: 01", 
          "", 
          "3. url: Represents URL/ip address that is supposed to be tested", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: http://httpbin.org", 
          "", 
          "4. params: Represents parameters that need to be sent along with the URL", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: postId=1; comments=5", 
          "", 
          "5. data: Represents data to be posted. HTTP GET does NOT accept this argument.", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Encoding: Unicode", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Other Restrictions: Should be a valid file path", 
          "", 
          "eg: userId=1;id=1;title=Changed Post;body=New Comment", 
          "\\u0075\\u0073\\u0065\\u0072\\u0049\\u0064\\u003d\\u0031\\u003b\\u0069\\u0064\\u003d\\u0031\\u003b\\u0074", 
          "path/to/file/containing/data", 
          "", 
          "6. json: Represents the JSON data that goes into the body of the request", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "Format: Valid JSON format", 
          "", 
          "eg: {\"postId\":\"1\", \"comments\":\"This is a new comment\"}", 
          "", 
          "7. headers: Represents the headers sent along with the request", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: Content-Type=text; Date=04/21/2016; Allow=whatever_you_want_to_allow", 
          "", 
          "8. cookies: Represents the cookies sent along with the request", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Other Restrictions: Should be a valid file path", 
          "", 
          "eg: cookie=cookie_name; details=more_details_abput_the_cookie", 
          "path/to/file/containing/cookie/details", 
          "", 
          "9. files: Lets User accomplish multipart encoding upload", 
          "", 
          "Pattern: string pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"path_to_file1, path_to_file2, path_to_file3\"/>", 
          "", 
          "Pattern: dict-tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"file_group_name=path_to_file1, path_to_file2, path_to_file4, path_to_file5\"/>", 
          "", 
          "Pattern: tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separators: As specified in Glossary", 
          "Max Numbers of Values inside a Group: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type),", 
          "(path_to_file2;content_type),", 
          "(path_to_file3;content_type)\"/>", 
          "", 
          "Pattern: dict-in-tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separators: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Max Numbers of Values inside a Group: As specified in Glossary", 
          "Max Numbers of Values inside the Dictionary Pattern: No Restrictions", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type;(custom_header_1=value1; custom_header_2:value2)),", 
          "(path_to_file2;content_type;(custom_header_1=value1)),", 
          "(path_to_file3;content_type;(custom_header_1=value1;", 
          "custom_header_2=value2;", 
          "custom_header_3=value3))\"/>", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type),", 
          "path_to_file2,", 
          "(path_to_file3;content_type;(custom_header_1=value1; custom_header_2=value2),", 
          "(path_to_file4;content_type),", 
          "(path_to_file5;content_type;(custom_header_1=value1;", 
          "custom_header_2=value2;", 
          "custom_header_3=value3)),", 
          "path_to_file6, path_to_file_7\"/>", 
          "", 
          "10. user: Represents the username that would be required for authentication.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: Sanika", 
          "", 
          "11. password: Represents the password that would be required for authentication.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: password", 
          "", 
          "12. timeout: Represents the time barrier in which the request should be completed", 
          "If 2 values are given, the first value would be treated as a constraint for", 
          "sending the request, the second would be treated as a constraint for", 
          "receiving the response. If only one value is given, it would be treated as", 
          "constraint for sending the request and receiving a response.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: 2", 
          "Characters Accepted: Numerical Characters - Int or Float", 
          "", 
          "eg: 0.5, 0.75", 
          "0.6", 
          "", 
          "13. allow_redirects: Allows or disallows redirection", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'yes'", 
          "", 
          "eg: yes", 
          "", 
          "14. proxies: Allows the User to set up proxies for ip addresses", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: http=157.126.12.196:8081; https:157.126.12.144:80", 
          "", 
          "15. verify: Allows user to enable or disable authentication", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'yes'", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Other Restrictions: Should be a valid file path to a .pem file", 
          "", 
          "eg: path/to/CA_BUNDLE", 
          "no", 
          "", 
          "16. stream: Allows user to enable or disable immediate data downloading", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'no'", 
          "", 
          "eg: yes", 
          "", 
          "17. cert: Allows user to send  his/her own certificate", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: 2", 
          "Characters Accepted: All Characters", 
          "", 
          "Other Restrictions:", 
          "Both the inputs should be valid file paths.", 
          "Input 1 should be a file path to the certificate file", 
          "If the file specified in Input 1 contains the key, Input 2 is not necessary", 
          "If the key is stored in a different file, Input 2 should contain the path to that file.", 
          "", 
          "eg: path/to/certificate/file, path/to/key/file", 
          "path/to/certificate/file/which/contains/the/key", 
          "", 
          "18. expected_response: User specified expected response.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: Numerical Characters - Integers only", 
          "Default: The entire 200 series of HTTP Responses", 
          "", 
          "eg: 200, 302, 404", 
          "200", 
          "", 
          "19. variable_config: The variable config file that contains", 
          "variables that need to be substituted into the json that is", 
          "being passed to this request. This can either be a relative or", 
          "an absolute path.", 
          "", 
          "Eg: ../Config_files/var_config.xml", 
          "/home/user/warrior_main/Warrior/Warriorspace/Config_files/var_config.xml", 
          "", 
          "20. var_sub: the pattern [var_sub] in the json will get substituted", 
          "with this value.", 
          "", 
          ":Returns:", 
          "1. <system_name>_status(boolean) = status code of the http options", 
          "2. <system_name>_api_response = the entire response object of the", 
          "http request", 
          "", 
          "Note: The Request Number is applicable when variable substitution in", 
          "JSON is being used. As variables get substituted in JSON, multiple", 
          "JSONs are formed and each JSON is sent as a separate request. These", 
          "requests are differentiated by adding add \"request_number\" which is", 
          "basically the serial number of those requests.", 
          "", 
          "3. The entire response object of the http request is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_object", 
          "<system_name>_api_response_object_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_object", 
          "<system_name>_<request_id>_api_response_object_<request_number>", 
          "", 
          "4. The response text (in text format) returned by the http request", 
          "is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_text", 
          "<system_name>_api_response_text_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_text", 
          "<system_name>_<request_id>_api_response_text_<request_number>", 
          "", 
          "5. The status code returned by the http request is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_status", 
          "<system_name>_api_response_status_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_status", 
          "<system_name>_<request_id>_api_response_status_<request_number>", 
          "", 
          "6. The content_type of the response returned by the http request", 
          "is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_content_type", 
          "<system_name>_api_response_content_type_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_content_type", 
          "<system_name>_<request_id>_api_response_content_type_<request_number>", 
          "", 
          "7. The extracted response returned from the response object (stored", 
          "in the format that it is returned in - JSON, XML, Text) is stored", 
          "as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_content", 
          "<system_name>_api_response_content_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_content", 
          "<system_name>_<request_id>_api_response_content_<request_number>"
        ], 
        "wdesc": "Perform a http options to the url", 
        "args": [
          "self", 
          "system_name", 
          "variable_config=None", 
          "request_id=None", 
          "data=None", 
          "url=None", 
          "expected_response=None", 
          "headers=None", 
          "user=None", 
          "password=None", 
          "allow_redirects=None", 
          "timeout=None", 
          "json=None", 
          "cookies=None", 
          "files=None", 
          "proxies=None", 
          "verify=None", 
          "stream=None", 
          "cert=None", 
          "var_sub=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "files": "None", 
          "cookies": "None", 
          "proxies": "None", 
          "stream": "None", 
          "url": "None", 
          "verify": "None", 
          "self": "", 
          "cert": "None", 
          "headers": "None", 
          "json": "None", 
          "expected_response": "None", 
          "user": "None", 
          "timeout": "None", 
          "request_id": "None", 
          "variable_config": "None", 
          "password": "None", 
          "data": "None", 
          "allow_redirects": "None", 
          "var_sub": "None"
        }, 
        "def": "def perform_http_options(self, system_name, variable_config=None,request_id=None, data=None,url=None, expected_response=None,headers=None, user=None, password=None,allow_redirects=None, timeout=None,json=None, cookies=None, files=None, proxies=None,verify=None, stream=None, cert=None, var_sub=None):", 
        "line": 2134, 
        "type": "fn", 
        "fn": "perform_http_options"
      }, 
      {
        "comment": [
          "Perform a http post actions and get the response", 
          "This keyword uses the warrior recommended Input datafile format for rest", 
          "", 
          "Please refer to perform_http_post keyword documentation to understand all", 
          "patterns", 
          "", 
          ":Arguments:", 
          "1. system_name: Name of the system from the datafile", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "Other Restrictions: Should be valid system name from the datafile", 
          "", 
          "eg: http_system_1", 
          "", 
          "2. request_id: A unique request ID for this request", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: 01", 
          "", 
          "3. url: Represents URL/ip address that is supposed to be tested", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: http://httpbin.org", 
          "", 
          "4. params: Represents parameters that need to be sent along with the URL", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: postId=1; comments=5", 
          "", 
          "5. data: Represents data to be posted. HTTP GET does NOT accept this argument.", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Encoding: Unicode", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Other Restrictions: Should be a valid file path", 
          "", 
          "eg: userId=1;id=1;title=Changed Post;body=New Comment", 
          "\\u0075\\u0073\\u0065\\u0072\\u0049\\u0064\\u003d\\u0031\\u003b\\u0069\\u0064\\u003d\\u0031\\u003b\\u0074", 
          "path/to/file/containing/data", 
          "", 
          "6. json: Represents the JSON data that goes into the body of the request", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "Format: Valid JSON format", 
          "", 
          "eg: {\"postId\":\"1\", \"comments\":\"This is a new comment\"}", 
          "", 
          "7. headers: Represents the headers sent along with the request", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: Content-Type=text; Date=04/21/2016; Allow=whatever_you_want_to_allow", 
          "", 
          "8. cookies: Represents the cookies sent along with the request", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Other Restrictions: Should be a valid file path", 
          "", 
          "eg: cookie=cookie_name; details=more_details_abput_the_cookie", 
          "path/to/file/containing/cookie/details", 
          "", 
          "9. files: Lets User accomplish multipart encoding upload", 
          "", 
          "Pattern: string pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"path_to_file1, path_to_file2, path_to_file3\"/>", 
          "", 
          "Pattern: dict-tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"file_group_name=path_to_file1, path_to_file2, path_to_file4, path_to_file5\"/>", 
          "", 
          "Pattern: tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separators: As specified in Glossary", 
          "Max Numbers of Values inside a Group: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type),", 
          "(path_to_file2;content_type),", 
          "(path_to_file3;content_type)\"/>", 
          "", 
          "Pattern: dict-in-tuple pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separators: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Max Numbers of Values inside a Group: As specified in Glossary", 
          "Max Numbers of Values inside the Dictionary Pattern: No Restrictions", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type;(custom_header_1=value1; custom_header_2:value2)),", 
          "(path_to_file2;content_type;(custom_header_1=value1)),", 
          "(path_to_file3;content_type;(custom_header_1=value1;", 
          "custom_header_2=value2;", 
          "custom_header_3=value3))\"/>", 
          "", 
          "eg: <argument name=\"files\" value=\"(path_to_file1;content_type),", 
          "path_to_file2,", 
          "(path_to_file3;content_type;(custom_header_1=value1; custom_header_2=value2),", 
          "(path_to_file4;content_type),", 
          "(path_to_file5;content_type;(custom_header_1=value1;", 
          "custom_header_2=value2;", 
          "custom_header_3=value3)),", 
          "path_to_file6, path_to_file_7\"/>", 
          "", 
          "10. user: Represents the username that would be required for authentication.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: Sanika", 
          "", 
          "11. password: Represents the password that would be required for authentication.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: password", 
          "", 
          "12. timeout: Represents the time barrier in which the request should be completed", 
          "If 2 values are given, the first value would be treated as a constraint for", 
          "sending the request, the second would be treated as a constraint for", 
          "receiving the response. If only one value is given, it would be treated as", 
          "constraint for sending the request and receiving a response.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: 2", 
          "Characters Accepted: Numerical Characters - Int or Float", 
          "", 
          "eg: 0.5, 0.75", 
          "0.6", 
          "", 
          "13. allow_redirects: Allows or disallows redirection", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'yes'", 
          "", 
          "eg: yes", 
          "", 
          "14. proxies: Allows the User to set up proxies for ip addresses", 
          "", 
          "Pattern: Dictionary Pattern", 
          "Multiple Values: As specified in Glossary", 
          "Separator: As specified in Glossary", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: http=157.126.12.196:8081; https:157.126.12.144:80", 
          "", 
          "15. verify: Allows user to enable or disable authentication", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'yes'", 
          "", 
          "OR", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Other Restrictions: Should be a valid file path to a .pem file", 
          "", 
          "eg: path/to/CA_BUNDLE", 
          "no", 
          "", 
          "16. stream: Allows user to enable or disable immediate data downloading", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: 'yes' and 'no'", 
          "Default: 'no'", 
          "", 
          "eg: yes", 
          "", 
          "17. cert: Allows user to send  his/her own certificate", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: 2", 
          "Characters Accepted: All Characters", 
          "", 
          "Other Restrictions:", 
          "Both the inputs should be valid file paths.", 
          "Input 1 should be a file path to the certificate file", 
          "If the file specified in Input 1 contains the key, Input 2 is not necessary", 
          "If the key is stored in a different file, Input 2 should contain the path to that file.", 
          "", 
          "eg: path/to/certificate/file, path/to/key/file", 
          "path/to/certificate/file/which/contains/the/key", 
          "", 
          "18. expected_response: User specified expected response.", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: Yes", 
          "Separator: ,", 
          "Max Numbers of Values Accepted: No Restrictions", 
          "Characters Accepted: Numerical Characters - Integers only", 
          "Default: The entire 200 series of HTTP Responses", 
          "", 
          "eg: 200, 302, 404", 
          "200", 
          "", 
          "19. variable_config: The variable config file that contains", 
          "variables that need to be substituted into the json that is", 
          "being passed to this request. This can either be a relative or", 
          "an absolute path.", 
          "", 
          "Eg: ../Config_files/var_config.xml", 
          "/home/user/warrior_main/Warrior/Warriorspace/Config_files/var_config.xml", 
          "", 
          "20. var_sub: the pattern [var_sub] in the json will get substituted", 
          "with this value.", 
          "", 
          ":Returns:", 
          "1. <system_name>_status(boolean) = status code of the http head", 
          "2. <system_name>_api_response = the entire response object of the", 
          "http request", 
          "", 
          "Note: The Request Number is applicable when variable substitution in", 
          "JSON is being used. As variables get substituted in JSON, multiple", 
          "JSONs are formed and each JSON is sent as a separate request. These", 
          "requests are differentiated by adding add \"request_number\" which is", 
          "basically the serial number of those requests.", 
          "", 
          "3. The entire response object of the http request is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_object", 
          "<system_name>_api_response_object_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_object", 
          "<system_name>_<request_id>_api_response_object_<request_number>", 
          "", 
          "4. The response text (in text format) returned by the http request", 
          "is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_text", 
          "<system_name>_api_response_text_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_text", 
          "<system_name>_<request_id>_api_response_text_<request_number>", 
          "", 
          "5. The status code returned by the http request is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_status", 
          "<system_name>_api_response_status_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_status", 
          "<system_name>_<request_id>_api_response_status_<request_number>", 
          "", 
          "6. The content_type of the response returned by the http request", 
          "is stored as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_content_type", 
          "<system_name>_api_response_content_type_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_content_type", 
          "<system_name>_<request_id>_api_response_content_type_<request_number>", 
          "", 
          "7. The extracted response returned from the response object (stored", 
          "in the format that it is returned in - JSON, XML, Text) is stored", 
          "as:", 
          "", 
          "If request_id has not been provided:", 
          "<system_name>_api_response_content", 
          "<system_name>_api_response_content_<request_number>", 
          "", 
          "If request_id has been provided:", 
          "<system_name>_<request_id>_api_response_content", 
          "<system_name>_<request_id>_api_response_content_<request_number>"
        ], 
        "wdesc": "Perform a http head to the url", 
        "args": [
          "self", 
          "system_name", 
          "variable_config=None", 
          "request_id=None", 
          "data=None", 
          "url=None", 
          "expected_response=None", 
          "headers=None", 
          "user=None", 
          "password=None", 
          "allow_redirects=None", 
          "timeout=None", 
          "json=None", 
          "cookies=None", 
          "files=None", 
          "proxies=None", 
          "verify=None", 
          "stream=None", 
          "cert=None", 
          "var_sub=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "files": "None", 
          "cookies": "None", 
          "proxies": "None", 
          "stream": "None", 
          "url": "None", 
          "verify": "None", 
          "self": "", 
          "cert": "None", 
          "headers": "None", 
          "json": "None", 
          "expected_response": "None", 
          "user": "None", 
          "timeout": "None", 
          "request_id": "None", 
          "variable_config": "None", 
          "password": "None", 
          "data": "None", 
          "allow_redirects": "None", 
          "var_sub": "None"
        }, 
        "def": "def perform_http_head(self, system_name, variable_config=None,request_id=None, data=None,url=None, expected_response=None,headers=None, user=None, password=None,allow_redirects=None, timeout=None,json=None, cookies=None, files=None, proxies=None,verify=None, stream=None, cert=None, var_sub=None):", 
        "line": 2548, 
        "type": "fn", 
        "fn": "perform_http_head"
      }, 
      {
        "comment": [
          "Verifies the api response with the expected response", 
          "and returns True or False", 
          "", 
          "Arguments:", 
          "", 
          "1. system_name: Name of the system from the datafile", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "Other Restrictions: Should be valid system name", 
          "from the datafile", 
          "", 
          "eg: http_system_1", 
          "", 
          "2. request_id: A unique request ID for this request", 
          "", 
          "Pattern: String Pattern", 
          "Multiple Values: No", 
          "Max Numbers of Values Accepted: 1", 
          "Characters Accepted: All Characters", 
          "", 
          "eg: 01", 
          "", 
          "3. expected_api_response: expected api response given by", 
          "the user.", 
          "", 
          "pattern: can be string or file name and response can be", 
          "simple text or xml or json", 
          "Multiple Values: No", 
          "Max Number of values accepted: 1", 
          "", 
          "4. expected_response_type: The type of expected response", 
          "Can be xml or json or text", 
          "", 
          "5. comparison_mode:", 
          "This is the mode in which you wish to compare", 
          "The supported comparison modes are", 
          "file, string, regex=expression, jsonpath=path, xpath=path", 
          "If you have given comparison_mode as file or string then", 
          "whole comparison will take place", 
          "If you wish to check content of expected response and", 
          "if it is only one value_check pass it in either data file", 
          "or test case file", 
          "If it is more than one value_check", 
          "then pass it in data file in comparison_mode and expected_api_response", 
          "tags under system", 
          "If it is xml response then you need to give xpath=path to it", 
          "If it is string response then you can pass regex=expressions", 
          "and you can leave expected_api_response empty", 
          "Ex for passing values in data file if it is json response", 
          "<comparison_mode>", 
          "<response_path>jsonpath=1.2.3</response_path>", 
          "<response_path>jsonpath=1.2</response_path>", 
          "</comparison_mode>", 
          "<expected_api_response>", 
          "<response_value>4</response_value>", 
          "<response_value>5</response_value>", 
          "</expected_api_response>", 
          "6. generate_output_diff_file: If the responses doesn't match,", 
          "then saves the difference between", 
          "the responses in a file by default and if this sets to", 
          "'no', doesn't save any difference.", 
          "", 
          "returns:", 
          "If api response matches with expected_api_response", 
          "then returns True else False."
        ], 
        "wdesc": "Verify API response with the expected API response", 
        "args": [
          "self", 
          "system_name", 
          "expected_api_response", 
          "expected_response_type", 
          "comparison_mode", 
          "request_id = None", 
          "generate_output_diff_file=\"Yes\""
        ], 
        "argsmap": {
          "system_name": "", 
          "expected_api_response": "", 
          "comparison_mode": "", 
          "expected_response_type": "", 
          "self": "", 
          "generate_output_diff_file": "\"Yes\"", 
          "request_id ": " None"
        }, 
        "def": "def verify_response(self, system_name, expected_api_response,expected_response_type, comparison_mode,request_id = None, generate_output_diff_file=\"Yes\"):", 
        "line": 2963, 
        "type": "fn", 
        "fn": "verify_response"
      }
    ]
  ], 
  "fw9500_driver": [], 
  "cloudshell_driver": [
    [
      {
        "comment": [
          "This is the CloudShell Actions module that has all Cloudshell related keywords "
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "cloudshell_actions.py", 
        "line": 1, 
        "type": "package", 
        "fn": "cloudshell_actions"
      }, 
      {
        "comment": [
          "Cloudshell wrapper APIs to create reservations, adding topologies and", 
          "deletion"
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "CloudShellActions(object):", 
        "line": 31, 
        "type": "class", 
        "fn": "CloudShellActions"
      }, 
      {
        "comment": [
          "Constructor for Cloudshell Actions"
        ], 
        "wdesc": "__init__", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def __init__(self):", 
        "line": 36, 
        "type": "fn", 
        "fn": "__init__"
      }, 
      {
        "comment": [
          "Logs in to API host using passed user credentials and domain", 
          "", 
          ":Datafile usage:", 
          "NA", 
          ":Arguments:", 
          "1. system_name(string) = Name of the system from the datafile", 
          "", 
          ":Returns:", 
          "1. status(bool)= True/False"
        ], 
        "wdesc": "Logon to CloudShell API Host", 
        "args": [
          "self", 
          "system_name"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": ""
        }, 
        "def": "def connect_to_cs(self, system_name):", 
        "line": 47, 
        "type": "fn", 
        "fn": "connect_to_cs"
      }, 
      {
        "comment": [
          "To logoff from CS", 
          "", 
          ":Datafile usage:", 
          "NA", 
          ":Arguments:", 
          "NA", 
          ":Returns:", 
          "1. status(bool)= True/False"
        ], 
        "wdesc": "To logoff from CS", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def cs_logoff(self):", 
        "line": 82, 
        "type": "fn", 
        "fn": "cs_logoff"
      }, 
      {
        "comment": [
          "Defines a reservation to be created.", 
          "", 
          "This keyword only defines the reservation with all its details by saving", 
          "the details in the data repository. Actual creation is done by using the", 
          "cs_add_topology_to_reservation keyword by providing the reservation name", 
          "to it.", 
          "", 
          ":Datafile usage:", 
          "Tags or attributes to be used in input datafile for the system", 
          "or subsystem.If both tag and attribute is provided the attribute", 
          "will be used.", 
          "1. username   = name of the cloudshell user", 
          "", 
          ":Arguments:", 
          "1. system_name(string) = Name of the UAP system from the datafile", 
          "2. reservation_name(string) = Specify the name of the reservation.", 
          "3. duration_in_mins(int) = Specify the length of the reservation.", 
          "4. notify_on_start(bool) = Indicate whether to notify the", 
          "reservation owner when the reservation starts.", 
          "5. notify_on_end(bool) = Indicate whether to notify the reservation", 
          "owner when the reservation ends.", 
          "6. notify_mins_before_end(int) = Notification Minutes Before End -", 
          "Indicate the number of minutes before the end of the reservation", 
          "to send out a Notify On End alert to the reservation owner.", 
          "(0 = disabled)", 
          "", 
          ":Returns:", 
          "1. status(bool)= True/False", 
          "2. output_dict = consists of following key value pairs:", 
          "1. domain_id: Domain Id returned after login to cloudshell.", 
          "2. reservation_id: Reservation Id returned after successful", 
          "creation of resources."
        ], 
        "wdesc": "Save reservation details for the reservation name provided", 
        "args": [
          "self", 
          "system_name", 
          "reservation_name", 
          "duration_in_mins", 
          "notify_on_start", 
          "notify_on_end", 
          "notify_mins_before_end"
        ], 
        "argsmap": {
          "system_name": "", 
          "notify_on_end": "", 
          "self": "", 
          "notify_mins_before_end": "", 
          "reservation_name": "", 
          "duration_in_mins": "", 
          "notify_on_start": ""
        }, 
        "def": "def cs_create_reservation(self, system_name, reservation_name,duration_in_mins, notify_on_start, notify_on_end,notify_mins_before_end):", 
        "line": 112, 
        "type": "fn", 
        "fn": "cs_create_reservation"
      }, 
      {
        "comment": [
          "Defines a reservation to be started immediately", 
          "", 
          ":Datafile usage:", 
          "Tags or attributes to be used in input datafile for the system", 
          "or subsystem.If both tag and attribute is provided the attribute", 
          "will be used.", 
          "1. username   = name of the cloudshell user", 
          "", 
          ":Arguments:", 
          "1. system_name(string) = Name of the UAP system from the datafile", 
          "2. reservation_name(string) = Specify the name of the reservation.", 
          "3. duration_in_mins(int) = Specify the length of the reservation.", 
          "4. notify_on_start(bool) = Indicate whether to notify the", 
          "reservation owner when the reservation starts.", 
          "5. notify_on_end(bool) = Indicate whether to notify the reservation", 
          "owner when the reservation ends.", 
          "6. notify_mins_before_end(int) = Notification Minutes Before End -", 
          "Indicate the number of minutes before the end of the reservation", 
          "to send out a Notify On End alert to the reservation owner.", 
          "(0 = disabled)", 
          "7. topology_full_path(string) = Specify the full topology name. Include", 
          "the full path from the root to the topology, separated by slashes.", 
          "For example: FolderName/Topologies/TopologyName", 
          "", 
          ":Returns:", 
          "1. status(bool)= True/False", 
          "2. output_dict = consists of following key value pairs:", 
          "1. domain_id: Domain Id returned after login to cloudshell.", 
          "2. reservation_id: Reservation Id returned after successful", 
          "creation of resources."
        ], 
        "wdesc": "Create Topology Reservation in CloudShell API Host", 
        "args": [
          "self", 
          "system_name", 
          "reservation_name", 
          "duration_in_mins", 
          "notify_on_start", 
          "notify_on_end", 
          "notify_mins_before_end", 
          "topology_full_path"
        ], 
        "argsmap": {
          "system_name": "", 
          "notify_on_end": "", 
          "self": "", 
          "notify_mins_before_end": "", 
          "reservation_name": "", 
          "topology_full_path": "", 
          "duration_in_mins": "", 
          "notify_on_start": ""
        }, 
        "def": "def cs_create_topology_reservation(self, system_name, reservation_name,duration_in_mins, notify_on_start, notify_on_end,notify_mins_before_end, topology_full_path):", 
        "line": 196, 
        "type": "fn", 
        "fn": "cs_create_topology_reservation"
      }, 
      {
        "comment": [
          "Create the reservation and add topology to the reservation in Cloudshell", 
          "", 
          ":Datafile usage:", 
          "NA", 
          ":Arguments:", 
          "1. system_name(string) = Name of the UAP system from the datafile", 
          "2. reservation_name(string) = Specify the name of the reservation.", 
          "3. topology_full_path(string) = Specify the full topology name. Include", 
          "the full path from the root to the topology, separated by slashes.", 
          "For example: FolderName/Topologies/TopologyName", 
          "", 
          ":Returns:", 
          "1. status(bool)= True/False"
        ], 
        "wdesc": "Create the reservation and add Topology to Reservation in CloudShell API Host", 
        "args": [
          "self", 
          "system_name", 
          "reservation_name", 
          "topology_full_path"
        ], 
        "argsmap": {
          "system_name": "", 
          "reservation_name": "", 
          "self": "", 
          "topology_full_path": ""
        }, 
        "def": "def cs_add_topology_to_reservation(self, system_name, reservation_name, topology_full_path):", 
        "line": 274, 
        "type": "fn", 
        "fn": "cs_add_topology_to_reservation"
      }, 
      {
        "comment": [
          "Activate Topology to reservation in Cloudshell", 
          "", 
          ":Datafile usage:", 
          "NA", 
          ":Arguments:", 
          "1. system_name(string) = Name of the UAP system from the datafile", 
          "2. reservation_name(string) = Specify the name of the reservation.", 
          "3. topology_path(string) = Specify the full topology name. Include", 
          "the full path from the root to the topology, separated by slashes.", 
          "For example: FolderName/Topologies/TopologyName", 
          "4. time_out(int): Before activating topology, we need to check status", 
          "of the reservation. If it is started, then we need to activate the", 
          "topology.", 
          "Need to wait for some time before activating topology for", 
          "reservation status to get started, making the default value of", 
          "time_out as 60 sec and can change the value depending on number", 
          "of resources.", 
          ":Returns:", 
          "1. status(bool)= True/False"
        ], 
        "wdesc": "Activate Topology to Reservation in CloudShell API Host", 
        "args": [
          "self", 
          "system_name", 
          "reservation_name", 
          "topology_full_path", 
          "time_out=60"
        ], 
        "argsmap": {
          "system_name": "", 
          "reservation_name": "", 
          "self": "", 
          "time_out": "60", 
          "topology_full_path": ""
        }, 
        "def": "def cs_activate_topology(self, system_name, reservation_name,topology_full_path, time_out=60):", 
        "line": 360, 
        "type": "fn", 
        "fn": "cs_activate_topology"
      }, 
      {
        "comment": [
          "Disconnects the routes in the cloud shell", 
          "", 
          ":Arguments:", 
          "1. system_name(string) = Name of the UAP system from the datafile", 
          "2. reservation_name(string) = Specify the name of the reservation.", 
          "3. first_endpoint(str) = The first endpoint of the two end points", 
          "4. second_endpoint(str) = The second endpoint of the two end points", 
          ":Returns:", 
          "1. status(bool)= True/False"
        ], 
        "wdesc": "Disconnect Routes in CloudShell API Host", 
        "args": [
          "self", 
          "system_name", 
          "reservation_name", 
          "first_endpoint", 
          "second_endpoint"
        ], 
        "argsmap": {
          "system_name": "", 
          "reservation_name": "", 
          "self": "", 
          "first_endpoint": "", 
          "second_endpoint": ""
        }, 
        "def": "def cs_disconnect_routes(self, system_name, reservation_name, first_endpoint, second_endpoint):", 
        "line": 432, 
        "type": "fn", 
        "fn": "cs_disconnect_routes"
      }, 
      {
        "comment": [
          "Connects the routes in the cloud shell", 
          "", 
          ":Arguments:", 
          "1. system_name(string) = Name of the UAP system from the datafile", 
          "2. reservation_name(string) = Specify the name of the reservation.", 
          "3. first_endpoint(str) = The first endpoint of the two end points", 
          "4. second_endpoint(str) = The second endpoint of the two end points", 
          "5. mapping_type(str) = Specify bi-directional or uni-directional as the mapping type", 
          ":Returns:", 
          "1. status(bool) = True/False"
        ], 
        "wdesc": "Connect Routes in CloudShell API Host", 
        "args": [
          "self", 
          "system_name", 
          "reservation_name", 
          "first_endpoint", 
          "second_endpoint", 
          "mapping_type"
        ], 
        "argsmap": {
          "system_name": "", 
          "mapping_type": "", 
          "self": "", 
          "first_endpoint": "", 
          "reservation_name": "", 
          "second_endpoint": ""
        }, 
        "def": "def cs_connect_routes(self, system_name, reservation_name, first_endpoint, second_endpoint, mapping_type):", 
        "line": 475, 
        "type": "fn", 
        "fn": "cs_connect_routes"
      }, 
      {
        "comment": [
          "Disconnects two endpoints and removes the mapped route between", 
          "them", 
          "", 
          ":Arguments:", 
          "1. system_name(string) = Name of the UAP system from the datafile", 
          "2. reservation_name(string) = Specify the name of the reservation.", 
          "3. first_endpoint(str) = The first endpoint of the two end points", 
          "4. second_endpoint(str) = The second endpoint of the two end points", 
          "5. mapping_type(string) = Specify bi-directional or uni-directional", 
          "as the mapping type", 
          ":Returns:", 
          "1. status(bool) = True/False"
        ], 
        "wdesc": "Remove Route From Reservation in CloudShell API Host", 
        "args": [
          "self", 
          "system_name", 
          "reservation_name", 
          "first_endpoint", 
          "second_endpoint", 
          "mapping_type"
        ], 
        "argsmap": {
          "system_name": "", 
          "mapping_type": "", 
          "self": "", 
          "first_endpoint": "", 
          "reservation_name": "", 
          "second_endpoint": ""
        }, 
        "def": "def cs_remove_route_from_reservation(self, system_name, reservation_name,first_endpoint, second_endpoint,mapping_type):", 
        "line": 520, 
        "type": "fn", 
        "fn": "cs_remove_route_from_reservation"
      }, 
      {
        "comment": [
          "Creates routes between the specified source and target resources.", 
          "", 
          ":Arguments:", 
          "1. system_name(string) = Name of the UAP system from the datafile", 
          "2. reservation_name(string) = Specify the name of the reservation.", 
          "3. source_resource_full_path(string) = Specify the source resource", 
          "full path", 
          "4. target_resource_full_path(string) = Specify the target resource", 
          "full path", 
          "5. mapping_type(string) = Specify bi-directional or uni-directional", 
          "as the mapping type", 
          "6. max_hops(integer) = The maximum number of allowed hops.", 
          "7. route_alias(string) = Specify the route alias", 
          "8. override_active_routes(bool) = Specify whether the new route", 
          "can override existing routes.", 
          "9. is_shared(bool) = Specify whether these routes are shared.", 
          ":Returns:", 
          "1. status(bool) = True/False"
        ], 
        "wdesc": "Create Route In Reservation in CloudShell API Host", 
        "args": [
          "self", 
          "system_name", 
          "reservation_name", 
          "source_resource_full_path", 
          "target_resource_full_path", 
          "override_active_routes", 
          "mapping_type", 
          "max_hops", 
          "route_alias", 
          "is_shared"
        ], 
        "argsmap": {
          "system_name": "", 
          "override_active_routes": "", 
          "mapping_type": "", 
          "self": "", 
          "route_alias": "", 
          "reservation_name": "", 
          "target_resource_full_path": "", 
          "max_hops": "", 
          "source_resource_full_path": "", 
          "is_shared": ""
        }, 
        "def": "def cs_create_route_in_reservation(self, system_name, reservation_name,source_resource_full_path,target_resource_full_path,override_active_routes,mapping_type, max_hops, route_alias,is_shared):", 
        "line": 569, 
        "type": "fn", 
        "fn": "cs_create_route_in_reservation"
      }, 
      {
        "comment": [
          "Disconnects a list of endpoints and removes the mapped route between", 
          "them", 
          "", 
          ":Arguments:", 
          "1. system_name(string) = Name of the UAP system from the datafile", 
          "2. reservation_name(string) = Specify the name of the reservation.", 
          "3. list_of_endpoints(list) = The list of endpoints which needs to", 
          "be removed", 
          "4. mapping_type(string) = Specify bi-directional or uni-directional", 
          "as the mapping type", 
          ":Returns:", 
          "1. status(bool) = True/False"
        ], 
        "wdesc": "Remove Routes From Reservation in CloudShell API Host", 
        "args": [
          "self", 
          "system_name", 
          "reservation_name", 
          "list_of_endpoints", 
          "mapping_type"
        ], 
        "argsmap": {
          "system_name": "", 
          "reservation_name": "", 
          "self": "", 
          "mapping_type": "", 
          "list_of_endpoints": ""
        }, 
        "def": "def cs_remove_routes_from_reservation(self, system_name, reservation_name,list_of_endpoints, mapping_type):", 
        "line": 628, 
        "type": "fn", 
        "fn": "cs_remove_routes_from_reservation"
      }, 
      {
        "comment": [
          "Creates routes between the listed source and target resources.", 
          "Routes will be created for each pair of source and target resources", 
          "", 
          ":Arguments:", 
          "1. system_name(string) = Name of the UAP system from the datafile", 
          "2. reservation_name(string) = Specify the name of the reservation.", 
          "3. list_of_source_resources(list) = The list of source resource", 
          "names.", 
          "4. list_of_target_resources(list) = The list of target resource", 
          "names.", 
          "5. override_active_routes(bool) = Specify whether the new route", 
          "can override existing routes.", 
          "6. mapping_type(string) = Specify bi-directional or uni-directional", 
          "as the mapping type", 
          "7. max_hops(integer) = The maximum number of allowed hops.", 
          "8. route_alias(string) = Specify the route alias", 
          "9. is_shared(bool) = Specify whether these routes are shared.", 
          ":Returns:", 
          "1. status(bool) = True/False"
        ], 
        "wdesc": "Create Routes In Reservation in CloudShell API Host", 
        "args": [
          "self", 
          "system_name", 
          "reservation_name", 
          "list_of_source_resources", 
          "list_of_target_resources", 
          "override_active_routes", 
          "mapping_type", 
          "max_hops", 
          "route_alias", 
          "is_shared"
        ], 
        "argsmap": {
          "system_name": "", 
          "override_active_routes": "", 
          "mapping_type": "", 
          "self": "", 
          "list_of_source_resources": "", 
          "reservation_name": "", 
          "max_hops": "", 
          "route_alias": "", 
          "list_of_target_resources": "", 
          "is_shared": ""
        }, 
        "def": "def cs_create_routes_in_reservation(self, system_name, reservation_name,list_of_source_resources,list_of_target_resources,override_active_routes,mapping_type, max_hops, route_alias,is_shared):", 
        "line": 674, 
        "type": "fn", 
        "fn": "cs_create_routes_in_reservation"
      }, 
      {
        "comment": [
          "End the reservation in Cloudshell", 
          "", 
          ":Datafile usage:", 
          "NA", 
          ":Arguments:", 
          "1. system_name(string) = Name of the UAP system from the datafile", 
          "2. reservation_name(string) = Specify the name of the reservation.", 
          "3. unmap(bool) = Unmap resources - Specify whether to keep mappings", 
          "or release mapped resources when deleting the reservation.", 
          ":Returns:", 
          "1. status(bool)= True/False"
        ], 
        "wdesc": "End Reservation in CloudShell API Host", 
        "args": [
          "self", 
          "system_name", 
          "reservation_name", 
          "unmap"
        ], 
        "argsmap": {
          "system_name": "", 
          "reservation_name": "", 
          "self": "", 
          "unmap": ""
        }, 
        "def": "def cs_end_reservation(self, system_name, reservation_name, unmap):", 
        "line": 736, 
        "type": "fn", 
        "fn": "cs_end_reservation"
      }, 
      {
        "comment": [
          "Add one or more permitted users to the specified reservation.", 
          "", 
          ":Datafile usage:", 
          "NA", 
          ":Arguments:", 
          "1. system_name(string) = Name of the UAP system from the datafile", 
          "2. reservation_name(string) = Specify the name of the reservation.", 
          "3. list_of_usernames(list) = list of usernames to permit access to", 
          "reservation.", 
          "For example: To add many users to access the reservation", 
          "list_of_usernames = ['user1','user2','userx']", 
          "", 
          ":Returns:", 
          "1. status(bool)= True/False"
        ], 
        "wdesc": "Add one or more permitted users to the reservation", 
        "args": [
          "self", 
          "system_name", 
          "reservation_name", 
          "list_of_usernames"
        ], 
        "argsmap": {
          "system_name": "", 
          "reservation_name": "", 
          "self": "", 
          "list_of_usernames": ""
        }, 
        "def": "def cs_add_users_to_reservation(self, system_name, reservation_name, list_of_usernames):", 
        "line": 779, 
        "type": "fn", 
        "fn": "cs_add_users_to_reservation"
      }, 
      {
        "comment": [
          "To get the Cloudshell topology details for a given path", 
          "", 
          ":Datafile usage:", 
          "NA", 
          ":Arguments:", 
          "1. topology_path(string) = Specify the full topology name. Include", 
          "the full path from the root to the topology, separated by slashes.", 
          "For example: FolderName/Topologies/TopologyName", 
          "", 
          ":Returns:", 
          "1. status(bool)= True/False"
        ], 
        "wdesc": "To get the Cloudshell topology details for a given path", 
        "args": [
          "self", 
          "topology_path"
        ], 
        "argsmap": {
          "self": "", 
          "topology_path": ""
        }, 
        "def": "def cs_get_topo_details(self, topology_path):", 
        "line": 830, 
        "type": "fn", 
        "fn": "cs_get_topo_details"
      }, 
      {
        "comment": [
          "Retrieves current reservations for the specified owner", 
          "", 
          ":Datafile usage:", 
          "NA", 
          ":Arguments:", 
          "1. reservation_owner(string) = Specify the user name of the", 
          "reservation owner.", 
          "", 
          ":Returns:", 
          "1. status(bool)= True/False"
        ], 
        "wdesc": "To retrieve current reservations for the specified owner", 
        "args": [
          "self", 
          "reservation_owner"
        ], 
        "argsmap": {
          "self": "", 
          "reservation_owner": ""
        }, 
        "def": "def cs_get_current_reservation(self, reservation_owner):", 
        "line": 867, 
        "type": "fn", 
        "fn": "cs_get_current_reservation"
      }, 
      {
        "comment": [
          "Retrieves all details and parameters for a specified reservation", 
          "", 
          ":Datafile usage:", 
          "NA", 
          ":Arguments:", 
          "1. system_name(string) = Name of the UAP system from the datafile", 
          "2. reservation_name(string) = Specify the name of the reservation.", 
          "", 
          ":Returns:", 
          "1. status(bool)= True/False"
        ], 
        "wdesc": "To retrieve all details and parameters for a specified\"\\", 
        "args": [
          "self", 
          "system_name", 
          "reservation_name"
        ], 
        "argsmap": {
          "system_name": "", 
          "reservation_name": "", 
          "self": ""
        }, 
        "def": "def cs_get_reservation_details(self, system_name, reservation_name):", 
        "line": 906, 
        "type": "fn", 
        "fn": "cs_get_reservation_details"
      }, 
      {
        "comment": [
          "Initializes the CloudShell object and logons to cloudshell", 
          "returns the cloudshell object"
        ], 
        "wdesc": "_create_cs_obj", 
        "args": [
          "self", 
          "system_name"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": ""
        }, 
        "def": "def _create_cs_obj(self, system_name):", 
        "line": 949, 
        "type": "fn", 
        "fn": "_create_cs_obj"
      }, 
      {
        "comment": [
          "Fetch the reservation id from the xml response of get current", 
          "reservation", 
          "returns the cloudshell reservation id"
        ], 
        "wdesc": "_get_reservation_id", 
        "args": [
          "self", 
          "responseObject", 
          "topology"
        ], 
        "argsmap": {
          "self": "", 
          "responseObject": "", 
          "topology": ""
        }, 
        "def": "def _get_reservation_id(self, responseObject, topology):", 
        "line": 962, 
        "type": "fn", 
        "fn": "_get_reservation_id"
      }
    ]
  ], 
  "file_driver": [
    [
      {
        "comment": [
          "import Framework.Utils as Utils", 
          "import re", 
          "from Framework.Utils.testcase_Utils import pNote, pStep", 
          "from Framework.Utils import file_Utils", 
          "This is file_actions module that has all file related keywords "
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "file_actions.py", 
        "line": 1, 
        "type": "package", 
        "fn": "file_actions"
      }, 
      {
        "comment": [
          "FileActions class which has methods(keywords)", 
          "related to actions used in file KW"
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "FileActions(object):", 
        "line": 19, 
        "type": "class", 
        "fn": "FileActions"
      }, 
      {
        "comment": [
          "Constructor for FileActions Class", 
          "self.resultfile = Utils.config_Utils.resultfile", 
          "self.datafile = Utils.config_Utils.datafile", 
          "self.logsdir = Utils.config_Utils.logsdir", 
          "self.filename = Utils.config_Utils.filename", 
          "self.logfile = Utils.config_Utils.logfile"
        ], 
        "wdesc": "__init__", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def __init__(self):", 
        "line": 24, 
        "type": "fn", 
        "fn": "__init__"
      }, 
      {
        "comment": [
          "def write(self, filename, string, index=None):", 
          "write string in the filename at index location", 
          ":Arguments:", 
          "filename - filename path in which to write the string", 
          "string - the string to be written", 
          "index - the index in the filename at which to write. writes at the", 
          "end of file if not provided", 
          ":Returns:", 
          "True if successful otherwise False"
        ], 
        "wdesc": "write string in the filename at index location", 
        "args": [
          "self", 
          "filename", 
          "string", 
          "index=None"
        ], 
        "argsmap": {
          "index": "None", 
          "self": "", 
          "string": "", 
          "filename": ""
        }, 
        "def": "def write(self, filename, string, index=None):", 
        "line": 32, 
        "type": "fn", 
        "fn": "write"
      }, 
      {
        "comment": [
          "find regex/string in the filename and replace it with newstring", 
          ":Arguments:", 
          "filename - file path in which to do the operation", 
          "regex - regex or string to be replaced", 
          "newstring - the new string to replace the regex", 
          "occurrence - list of comma separated lines index to find/replace,", 
          "empty to replace all occurrences", 
          "startidx - starting line from which to do find/replace, first line", 
          "if not given", 
          "endidx - ending line to do the find/replace, last line if not given", 
          ":Returns:", 
          "True if successfully replaced else False"
        ], 
        "wdesc": "(\"find regex/string in the filename and replace it with ", 
        "args": [
          "self", 
          "filename", 
          "regex", 
          "newstring", 
          "occurrence=\"\"", 
          "int_startidx=0", 
          "int_endidx=-1"
        ], 
        "argsmap": {
          "regex": "", 
          "occurrence": "\"\"", 
          "int_endidx": "-1", 
          "self": "", 
          "filename": "", 
          "int_startidx": "0", 
          "newstring": ""
        }, 
        "def": "def findreplace(self, filename, regex, newstring, occurrence=\"\",int_startidx=0, int_endidx=-1):", 
        "line": 59, 
        "type": "fn", 
        "fn": "findreplace"
      }, 
      {
        "comment": [
          "find regex/string in the filename", 
          ":Arguments:", 
          "filename - file path in which to do the operation", 
          "regex - regex or string to be checked", 
          "occurrence - list of comma separated lines index to check,", 
          "empty to check all lines", 
          "startidx - starting line from which to do check, first line", 
          "if not given", 
          "endidx - ending line to do the check, last line if not given", 
          ":Returns:", 
          "True if successfully checked for all occurrences else False"
        ], 
        "wdesc": "find regex/string in the filename in the desired location", 
        "args": [
          "self", 
          "filename", 
          "regex", 
          "occurrence=\"\"", 
          "int_startidx=0", 
          "int_endidx=-1"
        ], 
        "argsmap": {
          "regex": "", 
          "occurrence": "\"\"", 
          "int_endidx": "-1", 
          "self": "", 
          "filename": "", 
          "int_startidx": "0"
        }, 
        "def": "def check_text_occurrence(self, filename, regex, occurrence=\"\",int_startidx=0, int_endidx=-1):", 
        "line": 122, 
        "type": "fn", 
        "fn": "check_text_occurrence"
      }, 
      {
        "comment": [
          "remove the filename from the system", 
          ":Arguments:", 
          "filename - filename path to be removed from system", 
          ":Returns:", 
          "True if successful otherwise False"
        ], 
        "wdesc": "remove the filename from the system", 
        "args": [
          "self", 
          "filename"
        ], 
        "argsmap": {
          "self": "", 
          "filename": ""
        }, 
        "def": "def remove(self, filename):", 
        "line": 167, 
        "type": "fn", 
        "fn": "remove"
      }, 
      {
        "comment": [
          "rename or move filename to newname", 
          ":Arguments:", 
          "filename - filename path to be renamed or moved", 
          "newname - new file name or path to which the file has to be moved", 
          ":Returns:", 
          "True if successful otherwise False"
        ], 
        "wdesc": "rename or move a file", 
        "args": [
          "self", 
          "filename", 
          "newname"
        ], 
        "argsmap": {
          "newname": "", 
          "self": "", 
          "filename": ""
        }, 
        "def": "def rename(self, filename, newname):", 
        "line": 181, 
        "type": "fn", 
        "fn": "rename"
      }, 
      {
        "comment": [
          "copy filename to newname", 
          ":Arguments:", 
          "filename - filename path to be copied", 
          "newname - new file name or path to which the file has to be copied", 
          ":Returns:", 
          "True if successful otherwise False"
        ], 
        "wdesc": "copy filename to newname", 
        "args": [
          "self", 
          "filename", 
          "newname"
        ], 
        "argsmap": {
          "newname": "", 
          "self": "", 
          "filename": ""
        }, 
        "def": "def copy(self, filename, newname):", 
        "line": 196, 
        "type": "fn", 
        "fn": "copy"
      }, 
      {
        "comment": [
          "copy only stats of filename to newname and not its contents", 
          ":Arguments:", 
          "filename - stats of the filename path to be copied", 
          "newname - new file name or path to which the stats has to be copied", 
          ":Returns:", 
          "True if successful otherwise False"
        ], 
        "wdesc": "copy stats of filename to newname", 
        "args": [
          "self", 
          "filename", 
          "newname"
        ], 
        "argsmap": {
          "newname": "", 
          "self": "", 
          "filename": ""
        }, 
        "def": "def copystat(self, filename, newname):", 
        "line": 211, 
        "type": "fn", 
        "fn": "copystat"
      }, 
      {
        "comment": [
          "copy filename to newname along with stats", 
          ":Arguments:", 
          "filename - filename path to be copied along with stats", 
          "newname - new file name or path to which the file and stats has", 
          "to be moved", 
          ":Returns:", 
          "True if successful otherwise False"
        ], 
        "wdesc": "copy filename to newname along with stats", 
        "args": [
          "self", 
          "filename", 
          "newname"
        ], 
        "argsmap": {
          "newname": "", 
          "self": "", 
          "filename": ""
        }, 
        "def": "def copy2(self, filename, newname):", 
        "line": 226, 
        "type": "fn", 
        "fn": "copy2"
      }
    ]
  ], 
  "demo_driver": [
    [
      {
        "comment": [
          "This is demo_actions module that has all demo test case related keywords "
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "demo_actions.py", 
        "line": 1, 
        "type": "package", 
        "fn": "demo_actions"
      }, 
      {
        "comment": [
          "DemoActions class which has methods(keywords)", 
          "related to actions used in demo KW "
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "DemoActions(object):", 
        "line": 27, 
        "type": "class", 
        "fn": "DemoActions"
      }, 
      {
        "comment": [
          "constructor"
        ], 
        "wdesc": "__init__", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def __init__(self):", 
        "line": 31, 
        "type": "fn", 
        "fn": "__init__"
      }, 
      {
        "comment": [
          "Call the pc_replacement or testset_calibration KW to validate", 
          "lab PC or test set calibration are up-to-date or not."
        ], 
        "wdesc": "Check lab PC replacement or test set calibration status", 
        "args": [
          "self", 
          "system_name"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": ""
        }, 
        "def": "def check_lab_equipment(self, system_name):", 
        "line": 41, 
        "type": "fn", 
        "fn": "check_lab_equipment"
      }, 
      {
        "comment": [
          "Verify lab PC is current if less than 4 years old, otherwise", 
          "a replacement is required."
        ], 
        "wdesc": "Check if lab PC is current or need replacement", 
        "args": [
          "self", 
          "system_name"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": ""
        }, 
        "def": "def pc_replacement(self, system_name):", 
        "line": 77, 
        "type": "fn", 
        "fn": "pc_replacement"
      }, 
      {
        "comment": [
          "Check if the test set calibration is current if less than 1 year old,", 
          "otherwise, re-calibration is required."
        ], 
        "wdesc": "Check if Lab Test set calibration is current.", 
        "args": [
          "self", 
          "system_name"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": ""
        }, 
        "def": "def testset_calibration(self, system_name):", 
        "line": 124, 
        "type": "fn", 
        "fn": "testset_calibration"
      }, 
      {
        "comment": [
          "For testing/demo/placeholder", 
          "return true/false/exception based on input", 
          ":Argument:", 
          "desired_status = user desired status", 
          "input pass->true, fail->false and everything else ->exception"
        ], 
        "wdesc": "local_data_test", 
        "args": [
          "self", 
          "desired_status"
        ], 
        "argsmap": {
          "self": "", 
          "desired_status": ""
        }, 
        "def": "def local_data_test(self, desired_status):", 
        "line": 170, 
        "type": "fn", 
        "fn": "local_data_test"
      }, 
      {
        "comment": [
          "connect to jira server and create an issue under a specific project", 
          "", 
          "", 
          "credential_handler=urllib2.HTTPPasswordMgrWithDefaultRealm()", 
          "credential_handler.add_password(None, postdata_url, username, password)", 
          "auth = urllib2.HTTPBasicAuthHandler(credential_handler)", 
          "userpassword = username + \":\" + password", 
          "password = base64.b64encode(userpassword)", 
          "#Create an Authentication handler", 
          "opener = urllib2.build_opener(auth)", 
          "urllib2.install_opener(opener)", 
          "opener = urllib2.build_opener(urllib2.HTTPHandler(debuglevel=1))", 
          "#Create a POST request", 
          "headers={\"Authorization\" : \"Basic \"+password,\"Content-Type\": \"application/json\"}", 
          "request=urllib2.Request(str(postdata_url),postdata,headers)", 
          "try:", 
          "handler = urllib2.urlopen(request)", 
          "extension = json.loads(handler.read())", 
          "issue_id = str(extension['key'])", 
          "pNote(\"JIRA Issue Created. Issue-Id: {0}\".format(issue_id))", 
          "output_dict[\"issue_id\"] = issue_id", 
          "except Exception as e:", 
          "status = False", 
          "pNote(\"Problem creating JIRA issue.\" , \"error\")", 
          "pNote(\"JIRA Error Code: ({0})\".format(e) , \"error\")", 
          "", 
          "Utils.data_Utils.update_datarepository(output_dict)", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "return status"
        ], 
        "wdesc": "Creates a JIRA issue", 
        "args": [
          "self", 
          "server_url", 
          "username", 
          "password", 
          "issue_summary", 
          "issue_description", 
          "project_key", 
          "issue_type='Bug'"
        ], 
        "argsmap": {
          "username": "", 
          "issue_summary": "", 
          "issue_description": "", 
          "self": "", 
          "project_key": "", 
          "server_url": "", 
          "issue_type": "'Bug'", 
          "password": ""
        }, 
        "def": "def create_jira_issue(self, server_url, username, password, issue_summary, issue_description, project_key, issue_type='Bug'):", 
        "line": 187, 
        "type": "fn", 
        "fn": "create_jira_issue"
      }
    ]
  ], 
  "snmp_driver": [
    [
      {
        "comment": [
          "import os, re", 
          "import Framework.Utils as Utils", 
          "from Framework.Utils.print_Utils import print_exception", 
          "from Framework.ClassUtils.snmp_utlity_class import WSnmp as ws", 
          "from Framework.Utils import testcase_Utils, config_Utils, data_Utils, snmp_utils", 
          "from threading import Thread", 
          "from time import sleep", 
          "import Queue", 
          "from pysnmp.smi import builder, view, compiler, error", 
          "from pysnmp.entity.rfc3413 import ntfrcv"
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "common_snmp_actions.py", 
        "line": 1, 
        "type": "package", 
        "fn": "common_snmp_actions"
      }, 
      {
        "comment": [
          "class CommonSnmpActions(object):"
        ], 
        "args": [], 
        "argsmap": {}, 
        "def": "CommonSnmpActions(object):", 
        "line": 33, 
        "type": "class", 
        "fn": "CommonSnmpActions"
      }, 
      {
        "comment": [
          "def __init__(self):", 
          "self.resultfile = Utils.config_Utils.resultfile", 
          "self.datafile = Utils.config_Utils.datafile", 
          "self.logsdir = Utils.config_Utils.logsdir", 
          "self.filename = Utils.config_Utils.filename", 
          "self.logfile = Utils.config_Utils.logfile", 
          "self.snmpver = {'1':'0', '2':'1', '2c':'1', '3':'2'}"
        ], 
        "wdesc": "__init__", 
        "args": [
          "self"
        ], 
        "argsmap": {
          "self": ""
        }, 
        "def": "def __init__(self):", 
        "line": 38, 
        "type": "fn", 
        "fn": "__init__"
      }, 
      {
        "comment": [
          "def snmp_get(self, snmp_ver, system_name, mib_name=None,", 
          "mib_index=None, mib_value=None,", 
          "oid_string=None, communityname=None,", 
          "snmp_timeout=60,", 
          "userName=None, authKey=None, privKey=None,authProtocol=None,", 
          "privProtocol=None,", 
          "custom_mib_paths=None,", 
          "load_mib_modules=None):", 
          "", 
          "", 
          "", 
          "wdesc = \"Executing SNMP GET command\"", 
          "Utils.testcase_Utils.pSubStep(wdesc)", 
          "", 
          "snmp_parameters = ['ip', 'snmp_port']", 
          "snmp_param_dic = Utils.data_Utils.get_credentials(self.datafile,", 
          "system_name,", 
          "snmp_parameters)", 
          "ipaddr = snmp_param_dic.get('ip')", 
          "port = snmp_param_dic.get('snmp_port')", 
          "", 
          "output_dict = {}", 
          "", 
          "wsnmp = ws(communityname, self.snmpver.get(snmp_ver), ipaddr, port, snmp_timeout,", 
          "userName, authKey, privKey,authProtocol,", 
          "privProtocol)", 
          "cmdgen = wsnmp.commandgenerator()", 
          "if self.snmpver.get(snmp_ver) is '2':# for ssnmp v3", 
          "auth_data = wsnmp.usmuserdata()", 
          "else:                              #for snmp v1 or v2c", 
          "auth_data = wsnmp.communitydata()", 
          "if ':' in ipaddr:#for ipv6", 
          "transport = wsnmp.udp6transporttarget()", 
          "else:    #for ipv4", 
          "transport = wsnmp.udptransporttarget()", 
          "if oid_string == None and mib_name == None:", 
          "testcase_Utils.pNote(\"Please provide OID or MIB Information!\", \"error\")", 
          "if oid_string:", 
          "oid = tuple([int(e) if e.isdigit() else e for e in oid_string.split('.')])", 
          "else:", 
          "if custom_mib_paths:", 
          "__custom_mib_paths = snmp_utils.split_mib_path(custom_mib_paths)", 
          "oid = wsnmp.mibvariable(mib_name, mib_index, mib_value).addAsn1MibSource(*__custom_mib_paths)", 
          "else:", 
          "oid = wsnmp.mibvariable(mib_name, mib_index, mib_value)", 
          "try:", 
          "errindication, errstatus,\\", 
          "errindex, result = cmdgen.getCmd(auth_data, transport, oid)", 
          "output_dict = {", 
          "'{0}_errindication'.format(system_name):errindication,", 
          "'{0}_errstatus'.format(system_name):errstatus,", 
          "'{0}_errindex'.format(system_name):errindex,", 
          "'{0}_result'.format(system_name):result}", 
          "", 
          "status = True", 
          "testcase_Utils.pNote(\"Successfully executed SNMP GET command {}\".format(result), \"info\")", 
          "", 
          "except wsnmp.exception:", 
          "status = False", 
          "testcase_Utils.pNote(\"SNMP GET command Failed.\", \"error\")", 
          "", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "return status, output_dict"
        ], 
        "wdesc": "Executing SNMP GET command", 
        "args": [
          "self", 
          "snmp_ver", 
          "system_name", 
          "mib_name=None", 
          "mib_index=None", 
          "mib_value=None", 
          "oid_string=None", 
          "communityname=None", 
          "snmp_timeout=60", 
          "userName=None", 
          "authKey=None", 
          "privKey=None", 
          "authProtocol=None", 
          "privProtocol=None", 
          "custom_mib_paths=None", 
          "load_mib_modules=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "mib_index": "None", 
          "load_mib_modules": "None", 
          "userName": "None", 
          "custom_mib_paths": "None", 
          "self": "", 
          "authProtocol": "None", 
          "privProtocol": "None", 
          "authKey": "None", 
          "oid_string": "None", 
          "snmp_timeout": "60", 
          "mib_value": "None", 
          "mib_name": "None", 
          "privKey": "None", 
          "snmp_ver": "", 
          "communityname": "None"
        }, 
        "def": "def snmp_get(self, snmp_ver, system_name, mib_name=None,mib_index=None, mib_value=None,oid_string=None, communityname=None,snmp_timeout=60,userName=None, authKey=None, privKey=None,authProtocol=None,privProtocol=None,custom_mib_paths=None,load_mib_modules=None):", 
        "line": 46, 
        "type": "fn", 
        "fn": "snmp_get"
      }, 
      {
        "comment": [
          "def snmp_getnext(self, snmp_ver, system_name, mib_name=None,", 
          "mib_index=None, mib_value=None,", 
          "oid_string=None, communityname=None,", 
          "snmp_timeout=60,", 
          "max_rows=1,", 
          "userName=None, authKey=None, privKey=None,authProtocol=None,", 
          "privProtocol=None,", 
          "custom_mib_paths=None,", 
          "load_mib_modules=None):", 
          "", 
          "", 
          "", 
          "wdesc = \"Executing SNMP GETNEXT command\"", 
          "Utils.testcase_Utils.pSubStep(wdesc)", 
          "", 
          "snmp_parameters = ['ip', 'snmp_port']", 
          "snmp_param_dic = Utils.data_Utils.get_credentials(self.datafile,", 
          "system_name,", 
          "snmp_parameters)", 
          "ipaddr = snmp_param_dic.get('ip')", 
          "port = snmp_param_dic.get('snmp_port')", 
          "", 
          "output_dict = {}", 
          "", 
          "wsnmp = ws(communityname, self.snmpver.get(snmp_ver), ipaddr, port, snmp_timeout,", 
          "userName, authKey, privKey,authProtocol,", 
          "privProtocol)", 
          "cmdgen = wsnmp.commandgenerator()", 
          "if self.snmpver.get(snmp_ver) is '2':# for ssnmp v3", 
          "auth_data = wsnmp.usmuserdata()", 
          "else:                              #for snmp v1 or v2c", 
          "auth_data = wsnmp.communitydata()", 
          "", 
          "if ':' in ipaddr:#for ipv6", 
          "transport = wsnmp.udp6transporttarget()", 
          "else:    #for ipv4", 
          "transport = wsnmp.udptransporttarget()", 
          "if oid_string == None and mib_name == None:", 
          "testcase_Utils.pNote(\"Please provide OID or MIB Information!\", \"error\")", 
          "", 
          "if oid_string:", 
          "oid = tuple([int(e) if e.isdigit() else e for e in oid_string.split('.')])", 
          "else:", 
          "if custom_mib_paths:", 
          "__custom_mib_paths = snmp_utils.split_mib_path(custom_mib_paths)", 
          "oid = wsnmp.mibvariable(mib_name, mib_index, mib_value).addAsn1MibSource(*__custom_mib_paths)", 
          "else:", 
          "oid = wsnmp.mibvariable(mib_name, mib_index, mib_value)", 
          "try:", 
          "errindication, errstatus, errindex, \\", 
          "result = cmdgen.nextCmd(auth_data,", 
          "transport, oid, lexicographicMode=True,", 
          "ignoreNonIncreasingOid=True, maxRows=int(max_rows),", 
          "lookupNames=True, lookupValues=True)", 
          "#  maxRows=1 will control the mib walk", 
          "output_dict = {", 
          "'{0}_errindication'.format(system_name):errindication,", 
          "'{0}_errstatus'.format(system_name):errstatus,", 
          "'{0}_errindex'.format(system_name):errindex,", 
          "'{0}_result'.format(system_name):result}", 
          "", 
          "status = True", 
          "testcase_Utils.pNote(\"Successfully executed SNMP GET-NEXT \"", 
          "\"command {}\".format(result), \"info\")", 
          "except wsnmp.exception:", 
          "status = False", 
          "testcase_Utils.pNote(\"SNMP GET-Next command Failed.\", \"error\")", 
          "", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "", 
          "return status, output_dict"
        ], 
        "wdesc": "Executing SNMP GETNEXT command", 
        "args": [
          "self", 
          "snmp_ver", 
          "system_name", 
          "mib_name=None", 
          "mib_index=None", 
          "mib_value=None", 
          "oid_string=None", 
          "communityname=None", 
          "snmp_timeout=60", 
          "max_rows=1", 
          "userName=None", 
          "authKey=None", 
          "privKey=None", 
          "authProtocol=None", 
          "privProtocol=None", 
          "custom_mib_paths=None", 
          "load_mib_modules=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "mib_index": "None", 
          "load_mib_modules": "None", 
          "userName": "None", 
          "custom_mib_paths": "None", 
          "self": "", 
          "max_rows": "1", 
          "authProtocol": "None", 
          "privProtocol": "None", 
          "authKey": "None", 
          "oid_string": "None", 
          "snmp_timeout": "60", 
          "mib_value": "None", 
          "mib_name": "None", 
          "privKey": "None", 
          "snmp_ver": "", 
          "communityname": "None"
        }, 
        "def": "def snmp_getnext(self, snmp_ver, system_name, mib_name=None,mib_index=None, mib_value=None,oid_string=None, communityname=None,snmp_timeout=60,max_rows=1,userName=None, authKey=None, privKey=None,authProtocol=None,privProtocol=None,custom_mib_paths=None,load_mib_modules=None):", 
        "line": 173, 
        "type": "fn", 
        "fn": "snmp_getnext"
      }, 
      {
        "comment": [
          "def snmp_walk(self, snmp_ver, system_name, mib_name=None,", 
          "mib_index=None, mib_value=None,", 
          "oid_string=None, communityname=None,", 
          "snmp_timeout=60,", 
          "userName=None, authKey=None, privKey=None,authProtocol=None,", 
          "privProtocol=None,", 
          "custom_mib_paths=None,", 
          "load_mib_modules=None,", 
          "lexicographicMode=False):", 
          "", 
          "", 
          "", 
          "wdesc = \"Executing SNMP WALK command\"", 
          "Utils.testcase_Utils.pSubStep(wdesc)", 
          "", 
          "snmp_parameters = ['ip', 'snmp_port']", 
          "snmp_param_dic = Utils.data_Utils.get_credentials(self.datafile,", 
          "system_name,", 
          "snmp_parameters)", 
          "ipaddr = snmp_param_dic.get('ip')", 
          "port = snmp_param_dic.get('snmp_port')", 
          "", 
          "output_dict = {}", 
          "", 
          "wsnmp = ws(communityname, self.snmpver.get(snmp_ver), ipaddr, port, snmp_timeout,", 
          "userName, authKey, privKey,authProtocol,", 
          "privProtocol)", 
          "cmdgen = wsnmp.commandgenerator()", 
          "if self.snmpver.get(snmp_ver) is '2':# for snmp v3", 
          "auth_data = wsnmp.usmuserdata()", 
          "else:                              #for snmp v1 or v2c", 
          "auth_data = wsnmp.communitydata()", 
          "", 
          "if ':' in ipaddr:#for ipv6", 
          "transport = wsnmp.udp6transporttarget()", 
          "else:    #for ipv4", 
          "transport = wsnmp.udptransporttarget()", 
          "", 
          "if oid_string == None and mib_name == None:", 
          "testcase_Utils.pNote(\"Please provide OID or MIB Information!\", \"error\")", 
          "", 
          "if oid_string: #OID String is optional", 
          "oid = tuple([int(e) if e.isdigit() else e for e in oid_string.split('.')])", 
          "else:", 
          "if custom_mib_paths:", 
          "__custom_mib_paths = snmp_utils.split_mib_path(custom_mib_paths)", 
          "oid = wsnmp.mibvariable(mib_name, mib_index).addAsn1MibSource(*__custom_mib_paths)", 
          "else:", 
          "oid = wsnmp.mibvariable(mib_name, mib_index)", 
          "try:", 
          "errindication, errstatus, errindex,\\", 
          "result = cmdgen.nextCmd(auth_data,", 
          "transport,", 
          "oid, lexicographicMode=lexicographicMode,", 
          "ignoreNonIncreasingOid=True, maxRows=5000,", 
          "lookupNames=True, lookupValues=True)", 
          "output_dict = {", 
          "'{0}_errindication'.format(system_name):errindication,", 
          "'{0}_errstatus'.format(system_name):errstatus,", 
          "'{0}_errindex'.format(system_name):errindex,", 
          "'{0}_result'.format(system_name):result}", 
          "", 
          "status = True", 
          "testcase_Utils.pNote(\"Successfully executed SNMP WALK command {}\".format(result), \"info\")", 
          "except wsnmp.exception:", 
          "status = False", 
          "testcase_Utils.pNote(\"SNMP Walk command Failed.\", \"error\")", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "return status, output_dict"
        ], 
        "wdesc": "Executing SNMP WALK command", 
        "args": [
          "self", 
          "snmp_ver", 
          "system_name", 
          "mib_name=None", 
          "mib_index=None", 
          "mib_value=None", 
          "oid_string=None", 
          "communityname=None", 
          "snmp_timeout=60", 
          "userName=None", 
          "authKey=None", 
          "privKey=None", 
          "authProtocol=None", 
          "privProtocol=None", 
          "custom_mib_paths=None", 
          "load_mib_modules=None", 
          "lexicographicMode=False"
        ], 
        "argsmap": {
          "system_name": "", 
          "mib_index": "None", 
          "load_mib_modules": "None", 
          "userName": "None", 
          "custom_mib_paths": "None", 
          "self": "", 
          "authProtocol": "None", 
          "privProtocol": "None", 
          "authKey": "None", 
          "oid_string": "None", 
          "snmp_timeout": "60", 
          "lexicographicMode": "False", 
          "mib_value": "None", 
          "mib_name": "None", 
          "privKey": "None", 
          "snmp_ver": "", 
          "communityname": "None"
        }, 
        "def": "def snmp_walk(self, snmp_ver, system_name, mib_name=None,mib_index=None, mib_value=None,oid_string=None, communityname=None,snmp_timeout=60,userName=None, authKey=None, privKey=None,authProtocol=None,privProtocol=None,custom_mib_paths=None,load_mib_modules=None,lexicographicMode=False):", 
        "line": 311, 
        "type": "fn", 
        "fn": "snmp_walk"
      }, 
      {
        "comment": [
          "def snmp_bulkget(self, snmp_ver, system_name, mib_name=None,", 
          "mib_index=None, mib_value=None,", 
          "oid_string=None, communityname=None,", 
          "snmp_timeout=60,", 
          "userName=None, authKey=None, privKey=None,authProtocol=None,", 
          "privProtocol=None,", 
          "custom_mib_paths=None,", 
          "load_mib_modules=None,", 
          "lexicographicMode=False):", 
          "", 
          "", 
          "", 
          "wdesc = \"Executing SNMP BULKGET command\"", 
          "Utils.testcase_Utils.pSubStep(wdesc)", 
          "", 
          "snmp_parameters = ['ip', 'snmp_port']", 
          "snmp_param_dic = Utils.data_Utils.get_credentials(self.datafile,", 
          "system_name,", 
          "snmp_parameters)", 
          "ipaddr = snmp_param_dic.get('ip')", 
          "port = snmp_param_dic.get('snmp_port')", 
          "", 
          "output_dict = {}", 
          "", 
          "wsnmp = ws(communityname, self.snmpver.get(snmp_ver), ipaddr, port, snmp_timeout,", 
          "userName, authKey, privKey,authProtocol,", 
          "privProtocol)", 
          "cmdgen = wsnmp.commandgenerator()", 
          "if self.snmpver.get(snmp_ver) is '2':# for ssnmp v3", 
          "auth_data = wsnmp.usmuserdata()", 
          "else:                              #for snmp v1 or v2c", 
          "auth_data = wsnmp.communitydata()", 
          "", 
          "if ':' in ipaddr:#for ipv6", 
          "transport = wsnmp.udp6transporttarget()", 
          "else:    #for ipv4", 
          "transport = wsnmp.udptransporttarget()", 
          "if oid_string == None and mib_name == None:", 
          "testcase_Utils.pNote(\"Please provide OID or MIB Information!\", \"error\")", 
          "", 
          "if oid_string:", 
          "oid = tuple([int(e) if e.isdigit()", 
          "else e for e in oid_string.split('.')])", 
          "else:", 
          "if custom_mib_paths:", 
          "__custom_mib_paths = snmp_utils.split_mib_path(custom_mib_paths)", 
          "oid = wsnmp.mibvariable(mib_name, mib_index, mib_value).addAsn1MibSource(*__custom_mib_paths)", 
          "else:", 
          "oid = wsnmp.mibvariable(mib_name, mib_index, mib_value)", 
          "try:", 
          "errindication, errstatus, errindex, \\", 
          "result = cmdgen.bulkCmd(auth_data,", 
          "transport,", 
          "1, 25, oid,", 
          "lexicographicMode=lexicographicMode,", 
          "lookupNames=True,", 
          "lookupValues=True,", 
          "maxRows=20)", 
          "# nonRepeaters(1)(int): One MIB variable is requested in response", 
          "# for the first nonRepeaters MIB variables in request.", 
          "# maxRepetitions(25)(int): maxRepetitions MIB variables are", 
          "# requested in response for each of the remaining MIB variables in", 
          "# the request (e.g. excluding nonRepeaters). Remote SNMP engine may", 
          "# choose lesser value than requested.", 
          "output_dict = {", 
          "'{0}_errindication'.format(system_name):errindication,", 
          "'{0}_errstatus'.format(system_name):errstatus,", 
          "'{0}_errindex'.format(system_name):errindex,", 
          "'{0}_result'.format(system_name):result}", 
          "", 
          "status = True", 
          "testcase_Utils.pNote(\"Successfully executed SNMP BULK GET \"", 
          "\"command\".format(result), \"info\")", 
          "except wsnmp.exception:", 
          "status = False", 
          "testcase_Utils.pNote(\"SNMP BULK GET command Failed.\", \"error\")", 
          "", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "", 
          "return status, output_dict"
        ], 
        "wdesc": "Executing SNMP BULKGET command", 
        "args": [
          "self", 
          "snmp_ver", 
          "system_name", 
          "mib_name=None", 
          "mib_index=None", 
          "mib_value=None", 
          "oid_string=None", 
          "communityname=None", 
          "snmp_timeout=60", 
          "userName=None", 
          "authKey=None", 
          "privKey=None", 
          "authProtocol=None", 
          "privProtocol=None", 
          "custom_mib_paths=None", 
          "load_mib_modules=None", 
          "lexicographicMode=False"
        ], 
        "argsmap": {
          "system_name": "", 
          "mib_index": "None", 
          "load_mib_modules": "None", 
          "userName": "None", 
          "custom_mib_paths": "None", 
          "self": "", 
          "authProtocol": "None", 
          "privProtocol": "None", 
          "authKey": "None", 
          "oid_string": "None", 
          "snmp_timeout": "60", 
          "lexicographicMode": "False", 
          "mib_value": "None", 
          "mib_name": "None", 
          "privKey": "None", 
          "snmp_ver": "", 
          "communityname": "None"
        }, 
        "def": "def snmp_bulkget(self, snmp_ver, system_name, mib_name=None,mib_index=None, mib_value=None,oid_string=None, communityname=None,snmp_timeout=60,userName=None, authKey=None, privKey=None,authProtocol=None,privProtocol=None,custom_mib_paths=None,load_mib_modules=None,lexicographicMode=False):", 
        "line": 446, 
        "type": "fn", 
        "fn": "snmp_bulkget"
      }, 
      {
        "comment": [
          "def verify_snmp_action(self, system_name, snmp_result, mib_string=None", 
          "):", 
          "", 
          "", 
          "wdesc = \"Verify the SNMP Action Results\"", 
          "Utils.testcase_Utils.pSubStep(wdesc)", 
          "", 
          "errindication = Utils.data_Utils.get_object_from_datarepository(str(system_name)+\"_errindication\")", 
          "varBindTable = Utils.data_Utils.get_object_from_datarepository(str(system_name)+\"_result\")", 
          "errorstatus = Utils.data_Utils.get_object_from_datarepository(str(system_name)+\"_errstatus\")", 
          "errindex = Utils.data_Utils.get_object_from_datarepository(str(system_name)+\"_errindex\")", 
          "", 
          "#Non-empty errorIndication string indicates SNMP engine-level error.", 
          "#The pair of errorStatus and errorIndex variables determines SNMP", 
          "#PDU-level error. If errorStatus evaluates to true, this indicates SNMP", 
          "#PDU error caused by Managed Object at position errorIndex-1 in \\", 
          "#varBinds. Doing errorStatus.prettyPrint() would return an", 
          "# explanatory text error message.", 
          "", 
          "result_list = []", 
          "status = False", 
          "if errindication:", 
          "testcase_Utils.pNote(\"%s\" % errindication)", 
          "else:", 
          "if errorstatus:", 
          "testcase_Utils.pNote('%s at %s' % (errorstatus.prettyPrint(),", 
          "errindex and", 
          "varBindTable[-1][int(errindex)-1][0]or '?'))", 
          "else:", 
          "if type(varBindTable[0]) is not list:", 
          "# for SNMP Get/Get-Next output only", 
          "for name, val in varBindTable:", 
          "if ws.checkoctetstring(val):", 
          "if '0x' == val.prettyPrint()[:2]: # to", 
          "# confirm if it is a hex string or not", 
          "if len(val.prettyPrint()) == 14:# for MAC", 
          "s = val.prettyPrint()", 
          "val = ':'.join( s[x:x+2] for x in", 
          "range(2,len(s), 2))", 
          "if len(val.prettyPrint()) == 12:# for IP", 
          "s = val.prettyPrint()", 
          "val = '.'.join( s[x:x+2] for x in", 
          "range(2,len(s), 2))", 
          "", 
          "result_list.append((name.prettyPrint(),", 
          "val))", 
          "testcase_Utils.pNote('%s = %s' %(", 
          "name.prettyPrint(),val))", 
          "else:", 
          "result_list.append((name.prettyPrint(),", 
          "val.prettyPrint()))", 
          "testcase_Utils.pNote('%s = %s' % (", 
          "name.prettyPrint(),val.prettyPrint()))", 
          "else:", 
          "# for SNMP Getbulk/walk output only", 
          "for varBindTableRow in varBindTable:", 
          "for name, val in varBindTableRow:", 
          "if ws.checkoctetstring(val):", 
          "if '0x' == val.prettyPrint()[:2]: # to", 
          "# confirm if it is a hex string or not", 
          "if len(val.prettyPrint()) == 14:# for MAC", 
          "s = val.prettyPrint()", 
          "val = ':'.join( s[x:x+2] for x in", 
          "range(2,len(s), 2))", 
          "if len(val.prettyPrint()) == 12:# for IP", 
          "s = val.prettyPrint()", 
          "val = '.'.join( s[x:x+2] for x in", 
          "range(2,len(s), 2))", 
          "", 
          "result_list.append((name.prettyPrint(),", 
          "val))", 
          "testcase_Utils.pNote('%s = %s' %(", 
          "name.prettyPrint(),val))", 
          "else:", 
          "result_list.append((name.prettyPrint(),", 
          "val.prettyPrint()))", 
          "testcase_Utils.pNote('%s = %s' %", 
          "(name.prettyPrint(),", 
          "val.prettyPrint()))", 
          "", 
          "for element in result_list:", 
          "if mib_string:", 
          "if mib_string in element and snmp_result in element:", 
          "status = True", 
          "testcase_Utils.pNote('%s and %s found in SNMP Output' %(", 
          "mib_string, snmp_result))", 
          "break", 
          "else:", 
          "if snmp_result in element:", 
          "status = True", 
          "testcase_Utils.pNote('%s found in SNMP Output' %(", 
          "snmp_result))", 
          "break", 
          "", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "", 
          "return status"
        ], 
        "wdesc": "Verify the SNMP Action Results", 
        "args": [
          "self", 
          "system_name", 
          "snmp_result", 
          "mib_string=None"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": "", 
          "mib_string": "None", 
          "snmp_result": ""
        }, 
        "def": "def verify_snmp_action(self, system_name, snmp_result, mib_string=None):", 
        "line": 592, 
        "type": "fn", 
        "fn": "verify_snmp_action"
      }, 
      {
        "comment": [
          "def add_snmp_v3_user(self, port, username, securityEngineId,", 
          "authkey=None, privkey=None,", 
          "authProtocol=None, privProtocol=None):", 
          "", 
          "", 
          "status = True", 
          "wdesc = \"Add SNMP V3 User for TRAP and Inform\"", 
          "Utils.testcase_Utils.pSubStep(wdesc)", 
          "status = ws.add_user(port, username, securityEngineId,", 
          "authkey, privkey, authProtocol, privProtocol)", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "return status"
        ], 
        "wdesc": "Add SNMP V3 User for TRAP and Inform", 
        "args": [
          "self", 
          "port", 
          "username", 
          "securityEngineId", 
          "authkey=None", 
          "privkey=None", 
          "authProtocol=None", 
          "privProtocol=None"
        ], 
        "argsmap": {
          "username": "", 
          "self": "", 
          "authProtocol": "None", 
          "privProtocol": "None", 
          "authkey": "None", 
          "securityEngineId": "", 
          "port": "", 
          "privkey": "None"
        }, 
        "def": "def add_snmp_v3_user(self, port, username, securityEngineId,authkey=None, privkey=None,authProtocol=None, privProtocol=None):", 
        "line": 701, 
        "type": "fn", 
        "fn": "add_snmp_v3_user"
      }, 
      {
        "comment": [
          "def add_snmp_community(self, port, community_string):", 
          "", 
          "", 
          "status = True", 
          "status = ws.add_community(port, community_string)", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "return status"
        ], 
        "wdesc": "add_snmp_community", 
        "args": [
          "self", 
          "port", 
          "community_string"
        ], 
        "argsmap": {
          "self": "", 
          "port": "", 
          "community_string": ""
        }, 
        "def": "def add_snmp_community(self, port, community_string):", 
        "line": 738, 
        "type": "fn", 
        "fn": "add_snmp_community"
      }, 
      {
        "comment": [
          "def start_trap_listener(self, system_name,", 
          "custom_mib_path=None,", 
          "load_mib_module='SNMPv2-MIB,SNMP-COMMUNITY-MIB'", 
          "):", 
          "", 
          "", 
          "status = True", 
          "wdesc = \"Starting Trap listener\"", 
          "Utils.testcase_Utils.pSubStep(wdesc)", 
          "snmp_parameters = ['ip', 'snmp_trap_port', 'community', 'snmp_username',", 
          "'securityEngineId', 'authkey', 'privkey',", 
          "'authProtocol', 'privProtocol']", 
          "snmp_param_dic = Utils.data_Utils.get_credentials(self.datafile,", 
          "system_name,", 
          "snmp_parameters)", 
          "", 
          "ip = snmp_param_dic.get('ip')", 
          "port = snmp_param_dic.get('snmp_trap_port')", 
          "community = snmp_param_dic.get('community', None)", 
          "username = snmp_param_dic.get('snmp_username', None)", 
          "securityEngineId = snmp_param_dic.get('securityEngineId', None)", 
          "privkey = snmp_param_dic.get('privkey', None)", 
          "authkey = snmp_param_dic.get('authkey', None)", 
          "authProtocol = snmp_param_dic.get('authProtocol', None)", 
          "privProtocol = snmp_param_dic.get('privProtocol', None)", 
          "", 
          "engine = ws.get_asyncoredispatcher(port)", 
          "", 
          "ntfrcv.NotificationReceiver(engine, ws.trap_decoder)", 
          "ws.data_repo.update({\"custom_mib_path\":custom_mib_path,", 
          "\"load_mib_module\":load_mib_module})", 
          "_trap_listner_job = Thread(target=ws.create_trap_listner_job, args=(port, ))", 
          "_trap_listner_job_start = Thread(target=ws.start_trap_listner_job, args=(port,))", 
          "_trap_listner_job.daemon = True", 
          "_trap_listner_job_start.daemon = True", 
          "_trap_listner_job.start()", 
          "if community:", 
          "__status = ws.add_community(port, community)", 
          "status = status and __status", 
          "if username and securityEngineId:", 
          "__status = self.add_snmp_v3_user(port, username, securityEngineId,", 
          "authkey, privkey,", 
          "authProtocol, privProtocol)", 
          "status = status and __status", 
          "sleep(1)", 
          "_trap_listner_job_start.start()", 
          "sleep(2)", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "return status"
        ], 
        "wdesc": "Starting Trap listener", 
        "args": [
          "self", 
          "system_name", 
          "custom_mib_path=None", 
          "load_mib_module='SNMPv2-MIB", 
          "SNMP-COMMUNITY-MIB'"
        ], 
        "argsmap": {
          "system_name": "", 
          "custom_mib_path": "None", 
          "self": "", 
          "SNMP-COMMUNITY-MIB'": "", 
          "load_mib_module": "'SNMPv2-MIB"
        }, 
        "def": "def start_trap_listener(self, system_name,custom_mib_path=None,load_mib_module='SNMPv2-MIB,SNMP-COMMUNITY-MIB'):", 
        "line": 750, 
        "type": "fn", 
        "fn": "start_trap_listener"
      }, 
      {
        "comment": [
          "def stop_trap_listener(self, system_name):", 
          "", 
          "", 
          "status = True", 
          "wdesc = \"Stop Trap listener\"", 
          "Utils.testcase_Utils.pSubStep(wdesc)", 
          "snmp_parameters = ['ip', 'snmp_trap_port']", 
          "snmp_param_dic = Utils.data_Utils.get_credentials(self.datafile,", 
          "system_name,", 
          "snmp_parameters)", 
          "ip = snmp_param_dic.get('ip')", 
          "port = snmp_param_dic.get('snmp_trap_port')", 
          "_stop_list = Thread(target=ws.close_trap_listner_job, args=(port,))", 
          "_stop_list.daemon = True", 
          "_stop_list.start()", 
          "_stop_list.join()", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "return status"
        ], 
        "wdesc": "Stop Trap listener", 
        "args": [
          "self", 
          "system_name"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": ""
        }, 
        "def": "def stop_trap_listener(self, system_name):", 
        "line": 838, 
        "type": "fn", 
        "fn": "stop_trap_listener"
      }, 
      {
        "comment": [
          "def validate_trap(self, system_name, value, oid_string=None, match_oid_op_value_pair=\"no\"):", 
          "", 
          "", 
          "__status = []", 
          "status = False", 
          "wdesc = \"Validate the Received Trap Messages from {}\".format(system_name)", 
          "Utils.testcase_Utils.pSubStep(wdesc)", 
          "snmp_parameters = ['ip', 'snmp_trap_port']", 
          "snmp_param_dic = Utils.data_Utils.get_credentials(self.datafile,", 
          "system_name,", 
          "snmp_parameters)", 
          "agent_ip = snmp_param_dic.get('ip')", 
          "port = snmp_param_dic.get('snmp_trap_port')", 
          "__op_trap = ws.data_repo.get(\"snmp_trap_messages_{}\".format(agent_ip))", 
          "if __op_trap:", 
          "testcase_Utils.pNote(\"Total No# {} of Trap message(s) Received from {}\".format(len(__op_trap), agent_ip))", 
          "for __list in __op_trap:", 
          "for __items in __list[4:]:", 
          "if match_oid_op_value_pair.lower() == \"no\":", 
          "if value and value in __items[1]:", 
          "testcase_Utils.pNote(\"Value# {} is present in: \\n# {} = {}\".format(value, __items[0], __items[1]))", 
          "__status.append(True)", 
          "break", 
          "elif oid_string and value:", 
          "if oid_string in __items[0] and value in __items[1]:", 
          "testcase_Utils.pNote(\"OID #{} and Value #{} is present in: \\n# {} = {}\".format(oid_string, value, __items[0], __items[1]))", 
          "__status.append(True)", 
          "break", 
          "if True in __status:", 
          "break", 
          "if True in __status:", 
          "break", 
          "else:", 
          "testcase_Utils.pNote(\"No Trap Received!\", \"error\")", 
          "if True in __status:", 
          "status = True", 
          "else:", 
          "if value and oid_string:", 
          "testcase_Utils.pNote(\"OID #{} and Value #{} is NOT Present!\".format(oid_string, value), \"error\")", 
          "else:", 
          "testcase_Utils.pNote(\"Value #{} is NOT present!\".format(oid_string, value), \"error\")", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "return status"
        ], 
        "wdesc": "Validate the Received Trap Messages from {}\".format(system_name)", 
        "args": [
          "self", 
          "system_name", 
          "value", 
          "oid_string=None", 
          "match_oid_op_value_pair=\"no\""
        ], 
        "argsmap": {
          "system_name": "", 
          "match_oid_op_value_pair": "\"no\"", 
          "self": "", 
          "oid_string": "None", 
          "value": ""
        }, 
        "def": "def validate_trap(self, system_name, value, oid_string=None, match_oid_op_value_pair=\"no\"):", 
        "line": 861, 
        "type": "fn", 
        "fn": "validate_trap"
      }, 
      {
        "comment": [
          "def show_received_traps(self, system_name):", 
          "", 
          "", 
          "status = True", 
          "wdesc = \"List out the trap messages from {}\".format(system_name)", 
          "Utils.testcase_Utils.pSubStep(wdesc)", 
          "snmp_parameters = ['ip', 'snmp_trap_port']", 
          "snmp_param_dic = Utils.data_Utils.get_credentials(self.datafile,", 
          "system_name,", 
          "snmp_parameters)", 
          "agent_ip = snmp_param_dic.get('ip')", 
          "port = snmp_param_dic.get('snmp_trap_port')", 
          "sleep(5)", 
          "__op_trap = ws.data_repo.get(\"snmp_trap_messages_{}\".format(agent_ip))", 
          "if __op_trap:", 
          "testcase_Utils.pNote(\"Total No# {} of Trap message(s) Received from {}\".format(len(__op_trap), agent_ip))", 
          "for __list in __op_trap:", 
          "__ticks = __list[0].get(\"time_stamp\")", 
          "__contextengineid = __list[1].get(\"contextEngineId\")", 
          "__snmpver = __list[2].get(\"SNMPVER\")", 
          "__securityname = __list[3].get(\"securityName\")", 
          "testcase_Utils.pNote(\" --------->>Notification message(Time Stamp:{})<<------- \\n From: {}:\\n \"", 
          "\"contextEngineId :{}\\n SNMPVER :{}\\n securityName: {}\"", 
          ".format(__ticks, agent_ip, __contextengineid, __snmpver, __securityname))", 
          "testcase_Utils.pNote(\"--------------\")", 
          "for __items in __list[4:]:", 
          "testcase_Utils.pNote(\"{} = {}\".format(__items[0], __items[1]))", 
          "else:", 
          "testcase_Utils.pNote(\"No Trap Received from {}!\".format(agent_ip), \"error\")", 
          "status = False", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "return status"
        ], 
        "wdesc": "List out the trap messages from {}\".format(system_name)", 
        "args": [
          "self", 
          "system_name"
        ], 
        "argsmap": {
          "system_name": "", 
          "self": ""
        }, 
        "def": "def show_received_traps(self, system_name):", 
        "line": 913, 
        "type": "fn", 
        "fn": "show_received_traps"
      }, 
      {
        "comment": [
          "def browse_mib(self, mib_filepath, mib_filename, browse='yes'):", 
          "", 
          "", 
          "status = True", 
          "wdesc = \"Browse the MIB File\"", 
          "Utils.testcase_Utils.pSubStep(wdesc)", 
          "oid, label, suffix, mibView, mibBuilder = ws.get_first_node_name(mib_filepath, mib_filename)", 
          "__modName, nodeDesc, suffix = mibView.getNodeLocation(oid)", 
          "while 1:", 
          "try:", 
          "modName, nodeDesc, suffix = mibView.getNodeLocation(oid)", 
          "mibNode, = mibBuilder.importSymbols(modName, nodeDesc)", 
          "nodetype = re.search(r\"([\\w]+)\\(\", str(mibNode)).group(1)", 
          "if browse.lower() == 'yes':", 
          "if modName in mib_filename:", 
          "if nodetype == 'MibScalar':", 
          "testcase_Utils.pNote('%s     %s -> %s == %s' % ('$$', nodetype, modName+'::'+nodeDesc+'.0', '.'.join(map(str,(oid)))+'.0'))", 
          "else:", 
          "testcase_Utils.pNote('** %s -> %s == %s' % (nodetype, modName+'::'+nodeDesc, '.'.join(map(str,(oid)))))", 
          "elif browse.lower() == 'no' :", 
          "if nodetype == 'MibScalar':", 
          "testcase_Utils.pNote('%s     %s -> %s == %s' % ('$$', nodetype, modName+'::'+nodeDesc+'.0', '.'.join(map(str,(oid)))+'.0'))", 
          "else:", 
          "testcase_Utils.pNote('** %s -> %s == %s' % (nodetype, modName+'::'+nodeDesc, '.'.join(map(str,(oid)))))", 
          "oid, label, suffix = mibView.getNextNodeName(oid)", 
          "except error.SmiError:", 
          "break", 
          "Utils.testcase_Utils.report_substep_status(status)", 
          "return status"
        ], 
        "wdesc": "Browse the MIB File", 
        "args": [
          "self", 
          "mib_filepath", 
          "mib_filename", 
          "browse='yes'"
        ], 
        "argsmap": {
          "mib_filepath": "", 
          "browse": "'yes'", 
          "self": "", 
          "mib_filename": ""
        }, 
        "def": "def browse_mib(self, mib_filepath, mib_filename, browse='yes'):", 
        "line": 950, 
        "type": "fn", 
        "fn": "browse_mib"
      }
    ]
  ]
}
[]
